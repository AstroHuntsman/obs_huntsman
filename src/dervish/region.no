#include "shCRegUtils.h"
#include "shCMaskUtils.h"
#include "prvt/utils_p.h"

/*****************************************************************************/

static MASK *makeMask(const char *name, int ncol);
static REGINFO regInfo;
static MASKINFO maskInfo;
static int subRegIndex;        /*Use to suff teh array subRegions.*/
static int subMaskIndex;        /*Use to suff teh array subMasks.*/
static void loadSubRegAddress ( const IPTR key, const IPTR val, void *subRegArray);
static void loadSubMaskAddress ( const IPTR key, const IPTR val, void *subMaskArray);

/*****************************************************************************/
/*
 * return a pointer to the parent of the given region
 *
 * RETURN VALUE:
 *	always the parent pointer (can be NULL)
 */
REGION *
parentRegion(const REGION *region)
{
   return(region == NULL ? NULL : region->prvt->parent);
}


/*****************************************************************************/
/*
 * Return 1 if the given region is READ/WRITE or 0 if it's READ_ONLY,
 * or dervish_genericError if the given pointer is NULL.
 */
int
isRWRegion(const REGION *region)
{
   if(region == NULL) {
      return(SH_GENERIC_ERROR);
   } 
   if(region->prvt->flags & READ_ONLY) {
      return(0);
   } else {
      return(1);
   }
}
	     
/*****************************************************************************/
/*
 * create a MASK structure with the given number of rows and columns.
 * fill the array with 0s, and place the appropriate values into
 * the 'nrow', 'ncol', fields.  set the 'parent' and 'prvt' fields
 * to NULL.
 *
 * RETURN VALUE:
 *	a pointer to the mask, or NULL on error
 */
MASK *
shMaskNew(const char *name, int nrow, int ncol)
{
   MASK *masknew;
   
   masknew = makeMask(name,nrow);

   p_shMaskRowsGet(masknew, nrow, ncol);

   return(masknew);
}

/*****************************************************************************/
/*
 * Return 1 if the given mask is READ/WRITE, 0 if it's READ_ONLY,
 * or dervish_genericError if the given pointer is NULL.
 */
int
isRWMask(const MASK *mask)
{
   if(mask == NULL) {
      return(SH_GENERIC_ERROR);
   }
   if(mask->prvt->flags & READ_ONLY) {
      return(0);
   } else {
      return(1);
   }
}

/*****************************************************************************/
/*
 * ROUTINE: shRegInfoGet
 *
 * Public interface to the public state information implied by 
 * the private bits of the region structure.  This is returned
 * in the REGINFO structure. The REGINFO structure is static. The 
 * caller shold ensure that all interesting information in the 
 * structure is copied out before another call to shRegInfoGet
 * can potentially occur.
 *
 * RETURN VALUES: 
 *	SH_SUCCESS		Call succeeded
 *	otherwise      		otherwise
 */

RET_CODE
shRegInfoGet(const REGION *reg, REGINFO **reginfo)
{
  regInfo.modCntr =  reg->prvt->ModCntr;
  regInfo.crc =      reg->prvt->crc;
  regInfo.parent =   reg->prvt->parent;
  if (reg->prvt->type == SHREGPHYSICAL) {
    regInfo.isPhysical = 1;
    shAssert(reg->prvt->phys);
    regInfo.physicalRegNum = reg->prvt->phys->physIndex;
  } else {
    regInfo.isPhysical = 0;
    regInfo.physicalRegNum = 0;
  }
  regInfo.isSubReg = ((reg->prvt->parent == (REGION *)0) ? 0 : 1);
  /*for now, regions are contiguous, subregions are not*/
  regInfo.pxAreContiguous =((reg->prvt->parent == (REGION *)0) ? 1 : 0);
  regInfo.hasHeader = (reg->hdr.hdrVec == (char **)0 ? 0 : 1);
  regInfo.headerModCntr = reg->hdr.modCnt;
  regInfo.hasMask = (reg->mask == (MASK *)0 ? 0 : 1);
  regInfo.nSubReg = reg->prvt->nchild;

  subRegIndex = 0;
  shTreeTraverse (reg->prvt->children, loadSubRegAddress, (void *)0);
  *reginfo = &regInfo;
  
  return(SH_SUCCESS);
}

static void loadSubRegAddress ( const IPTR key, const IPTR val, void *subRegArrayPtr) {
   regInfo.subRegs[subRegIndex++] = (REGION *)key;
}

/*****************************************************************************/
/*
 * ROUTINE: shMaskInfoGet
 *
 * Public interface to the public state information implied by 
 * the private bits of the mask structure.  This is returned
 * in the MASKINFO structure. The MASKINFO structure is static. The 
 * caller shold ensure that all interesting information in the 
 * structure is copied out before another call to shMaskInfoGet
 * can potentially occur.
 *
 * RETURN VALUES: 
 *	SH_SUCCESS		Call succeeded
 *	otherwise      		otherwise
 */

RET_CODE
shMaskInfoGet(const MASK *mask, MASKINFO **maskinfo)
{
  maskInfo.crc =      mask->prvt->crc;
  maskInfo.parent =   mask->prvt->parent;
  maskInfo.isSubMask = ((mask->prvt->parent == (MASK *)0) ? 0 : 1);

  /*for now, masks are contiguous, submasks are not*/
  maskInfo.pxAreContiguous =((mask->prvt->parent == (MASK *)0) ? 1 : 0);
  maskInfo.nSubMask = mask->prvt->nchild;

  subMaskIndex = 0;
  shTreeTraverse (mask->prvt->children, loadSubMaskAddress, (void *)0);
  *maskinfo = &maskInfo;
  
  return(SH_SUCCESS);
}

static void loadSubMaskAddress ( const IPTR key, const IPTR val, void *subMaskArrayPtr) {
   maskInfo.subMasks[subMaskIndex++] = (MASK *)key;
}
/*****************************************************************************/
/*
** ROUTINE: shRegNewFromReg
**
** DESCRIPTION:
**	Create a new region based on an existing region.
**
** RETURN VALUES:
**	SH_SUCCESS
**	SH_GENERIC_ERROR
**	return values from shHdrCopy
**
*/
REGION *
shRegNewFromReg
  (
  const REGION	*a_reg,	    /* IN : Source region pointer */
  const char	*a_name,    /* IN : ASCII name for new region */
  PIXDATATYPE	a_type,	    /* IN : Pixel data type for new region */
  REGION_FLAGS  a_flags,    /* IN : Flags for copied header and or mask */
  RET_CODE	*a_rstat    /* OUT: Return status */
  )
{
  RET_CODE  rstat      = SH_SUCCESS;
  REGION    *newRegPtr = NULL;
  char      nameBuf[25];

  /*
  ** MAKE SURE SOURCE REGION EXISTS
  */
  if (a_reg == NULL)
    {
    shErrStackPush("shRegNewFromReg: Passed a NULL region pointer");
    rstat = SH_GENERIC_ERROR;
    goto exitit;
    }

  /*
  ** CREATE DESTINATION REGION AND COPY FROM SOURCE
  */
  /* Create new virtual region of specified size and pixel type */
  newRegPtr = shRegNew(a_name, a_reg->nrow, a_reg->ncol, a_type);
  if (newRegPtr == NULL)
    {
    rstat = SH_GENERIC_ERROR;
    goto exitit;
    }

  /* Copy the image (and perform pixel type conversion if necessary) */
  shRegPixCopy(a_reg, newRegPtr);

/* 
** Check if header and mask need to be copied too. 
*/
  if (a_flags & COPY_HEADER_DEEP) {
  /*
  ** CREATE DESTINATION HDR VECTOR AND COPY HDR FROM SOURCE (IF NECESSARY)
  */
    if (a_reg->hdr.hdrVec != NULL)    /* If source has header, then copy it */
      {
    /* Note: header copy routine will allocate header vector for us */
      rstat = shHdrCopy(&a_reg->hdr, &newRegPtr->hdr);
      if (rstat != SH_SUCCESS)
        {
        shErrStackPush("shRegNewFromReg: Failure to allocate new header");
        shRegDel(newRegPtr);
        newRegPtr = NULL;
        goto exitit;
        }
      }
    }

  /*
  ** COPY REGION MASK (IF NECESSARY) 
  */
  if (a_flags & COPY_MASK) {
    if (a_reg->mask != NULL) {
      if ((newRegPtr->mask = shMaskNew(a_reg->mask->name, a_reg->mask->nrow,
				       a_reg->mask->ncol)) == NULL) {
        shErrStackPush("shRegNewFromReg: Failure to allocate new mask");
        shRegDel(newRegPtr);
        newRegPtr = NULL;
        goto exitit;
      }
      shMaskCopy(a_reg->mask, newRegPtr->mask);
    } else {
      /* Original region has no mask so have to make one up */
      sprintf(nameBuf, "%s-mask", a_reg->name);
      if ((newRegPtr->mask = shMaskNew(nameBuf, a_reg->nrow,
				       a_reg->ncol)) == NULL) {
        shErrStackPush("shRegNewFromReg: Failure to allocate new mask");
        shRegDel(newRegPtr);
        newRegPtr = NULL;
        goto exitit;
      }
    }
  }

exitit:
  if (a_rstat)
     {*a_rstat = rstat;}
  return(newRegPtr);
}


/*****************************************************************************/


/*============================================================================
 * ROUTINE: p_shRegCntrIncrement
 *
 * DESCRIPTION:
 *   This routine increments a region modification counter each time the region
 *   is modified.
 *
 * CALL:
 *   (void) p_shRegCntrIncrement(REGION *a_reg);
 *          a_reg - pointer to the region structure
 *============================================================================
 */
void p_shRegCntrIncrement(REGION *a_reg)
{
   if (a_reg != NULL)
       a_reg->prvt->ModCntr += 1;

   return;
}


/*
 * ROUTINE: p_shMaskRowsGet
 *
 * Given a mask structure and the number of rows and columns in the mask,
 * malloc the space for the mask itself.
 *
 * RETURN VALUES:
 *	NONE (shFatal is called if there is a mallocing error.)
 */
void
p_shMaskRowsGet(
		MASK *mask,
		int  nrow,
		int  ncol
		)
{
   int i;

   if(nrow*ncol != 0) {
      if((mask->rows[0] = (unsigned char *)shMalloc(nrow*ncol)) == NULL) {
         shFatal("p_shMaskRowsGet: Can't allocate storage for rows");
      }
      for(i = 0;i < nrow;i++) {
	 mask->rows[i] = mask->rows[0] + i*ncol;
      }
      mask->ncol = ncol;
   }

   shMaskClear(mask);
}

