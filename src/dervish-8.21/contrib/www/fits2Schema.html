<HTML>
<TITLE>
Nifty Contrib Tcl Verbs
</TITLE>
The following procedures are not recommended for use within production
pipelines; however, they are very useful for interactive QA type activities
These routines are useful for reading and writing FITS tables and getting
information from TBLCOL structures.
<P>
<DIR>
<li><a href=#fits2Schema>fits2Schema</a>
<li><a href=#schema2Fits>schema2Fits</a>
<li><a href=#schemaRecurseGetFromType>schemaRecurseGetFromType</a>
<li><a href=#schemaRecursePrintFromType>schemaRecursePrintFromType</a>
<li><a href=#schemaTransAuto>schemaTransAuto</a>
<li><a href=#tblPrint>tblPrint</a>
<li><a href=#tblArrayGet>tblArrayGet</a>
<li><a href=#fldPrint>fldPrint</a>
<li><a href=#tblFldScaleInfoGet>tblFldScaleInfoGet</a>
<li><a href=#tblFix>tblFix</a>
<li><a href=#tblDataGet>tblDataGet</a>
<li><a href=#tblDataPrint>tblDataPrint</a>
<li><a href=#typeNewFromTbl>typeNewFromTbl</a>
<li><a href=#chainMatchType>chainMatchType</a>
</DIR>
The following routines provide a convenient interface to the schemaDefine
facility (which allows defining new Dervish TYPEs at runtime):
<P>
<DIR>
<li><a href=#typedef>typedef</a>
<li><a href=#makeio>makeio</a>
</DIR>
*********************************************************************
<P>
<a name=fits2Schema><h2>fits2Schema</h2></a>
<pre>
Convert a FITS ascii or binary table file into a chain automatically.
The table is assumed to be located in the first HDU.
A translation table is constructed on the fly.  The Dervish TYPE of the chain is
specified as an argument.  If the type does not exist, a new one is created
using table column information stored in the FITS table.  Heap data are ignored
at present (although this may be relaxes in the future) except for data of
type "char", which is converted to "char *" type variables.
If the type already exists, one should be careful that it matches the
column names and data types in the FITS table.

	Usage:	fits2Schema file type

	file:	Input file
	type:	Dervish TYPE (will be created if it does not exist)

	Return: A chain

*****************************************************************************
</PRE>
<P>
<a name=schema2Fits><h2>schema2Fits</h2></a>
<pre>
Convert a chain into a FITS binary table file automatically.  A translation
table is constructed on the fly.  Only inline data items are copied;
data referenced by pointers area ignored, with the exception of "char *"
items, which are assumed to be character strings and which are copied
into heap storage in the table.

	Usage:	schema2Fits chain file

	chain:	The chain to be copied
	file:	Output file

	Return: None

*****************************************************************************
</PRE>
<P>
<a name=schemaRecurseGetFromType><h2>schemaRecurseGetFromType</h2></a>
<PRE>
Given a Dervish TYPE, return the schema definition.  Embedded structures
are expanded in the returned definition until only primitive data types
result.

	Usage: schemaRecurseGetFromType type

	type: Dervish TYPE

	Return: A TCL list

*****************************************************************************
</pre>
<P>
<a name=schemaRecursePrintFromType><h2>schemaRecursePrintFromType</h2></a>
<PRE>
Given a Dervish TYPE, print the schema definition.  Embedded structures
are expanded in the returned definition until only primitive data types
result.

	Usage: schemaRecursePrintFromType type

	type: Dervish TYPE

	Return: None (prints to screen)

*****************************************************************************
</pre>
<P>
<a name=schemaTransAuto><h2>schemaTransAuto</h2></a>
<PRE>
Given a Dervish TYPE, construct a translation table automatically.  All data
types are converted with the exception of pointers (which are ignored).
Elements of type "char *" are treated as strings and an entry is created
to convert the element into heap storage.  Embedded structures are
handled automatically.

	Usage: schemaTransAuto type {direction write} {argList ""}

	type:	Dervish TYPE
	direction:	write for schema to table
			read for table to schema
			(this is of consequence only for character strings)
	argList:	If specified, this is a TCL list of elements to
			be entered in the table.  If omitted, all elements
			are entered.

	Return:	Handle to a SCHEMATRANS

*****************************************************************************
</pre>
<P>
<a name=tblPrint><h2>tblPrint</h2></a>
<PRE>
Print out the column names in a TBLCOL with other information

	Usage:	tblPrint tbl

	tbl: A TBLCOL structure

	Return: None (prints to screen)

*****************************************************************************
</PRE>
<P>
<a name=tblArrayGet><h2>tblArrayGet</h2></a>
<PRE>
Return a handle to the ARRAY structure corresponding to the specified
column number in a TBLCOL

	Usage:	tblArrayGet tbl col

	tbl:	The TBLCOL structure
	col:	The column number within the TBLCOL (0 based indexing)

	Return:	A handle to an ARRAY

*****************************************************************************
</PRE>
<P>
<a name=fldPrint><h2>fldPrint</h2></a>
<PRE>
I forget what this does

	Usage:	fldPrint tbl col

	tbl:	A TBLCOL structure
	col:	The column number within the TBLCOL (0 based indexing)

	Return: None (prints to screen)

*****************************************************************************
</PRE>
<P>
<a name=tblFldScaleInfoGet><h2>tblFldScaleInfoGet</h2></a>
<PRE>
Return TSCALE and TZERO information for a given column in a TBLCOL

	Usage:	tblFldScaleInfoGet tbl col

	tbl:	A TBLCOL structure
	col:	The column number within the TBLCOL (0 based indexing)

	Return:	A TCL list

*****************************************************************************
</PRE>
<P>
<a name=tblFix><h2>tblFix</h2></a>
<PRE>
Convert all names of columns in a TBLCOL to uppercase.

	Usage:	tblFix tbl

	tbl:	A TBLCOL structure

	Return:

*****************************************************************************
</PRE>
<P>
<a name=tblDataGet><h2>tblDataGet</h2></a>
<PRE>
Return the data element in a TBLCOL for a specified column and row number.
May not work on heap items.

	Usage:	tblDataGet tbl col index

	tbl:	A TBLCOL structure
	col:	The column number within the TBLCOL (0 based indexing)
	index:	The row number

	Return:	The value of the data element
	
*****************************************************************************
</PRE>
<P>
<a name=tblDataPrint><h2>tblDataPrint</h2></a>
<PRE>
Print the data element in a TBLCOL for a specified column and row number.
May not work on heap items.

	Usage:	tblDataPrint tbl col index

	tbl:	A TBLCOL structure
	col:	The column number within the TBLCOL (0 based indexing)
	index:	The row number

	Return: None (prints to screen)

*****************************************************************************
</PRE>
<P>
<a name=typeNewFromTbl><h2>typeNewFromTbl</h2></a>
<PRE>
Create a new Dervish data type from column definitions given in a TBLCOL

	Usage:	typeNewFromTbl tbl type

	tbl:	A TBLCOL structure
	type:	The new Dervish TYPE

	Return:	None

*****************************************************************************
</PRE>
<P>
<a name=chainMatchType><h2>chainMatchType</h2></a>
Match two chains using <a href=chainUtils.html#match>chainMatch</a>.
Let TYPE1 be the Dervish type of objects on the first chain and TYPE2 be the
type of objects on the second chain.  A new Dervish TYPE is created with the
following definition:
<PRE>
   typedef struct tag {
	TYPE1 *object1;
	TYPE2 *object2;
	double res1;
	double res2;
	} TYPE1TYPE2MERGE;	/* pragma SCHEMA */

The output chain can be walked conveniently using the chainPage command

	Usage:	chainMatchType	chain1 chain2 &lt;predicates&gt;

	chain1:	First chain (can have objects of any type)
	chain2:	Second chain (can have objects of any type)
	predicates:	A TCL list of predicates.  Each predicate is of
		the form {arg1 arg2 window [wrap]}  where arg1 is an element in
		an object on the first chain, arg2 is an element in an
		object on the second chain, window is a matchup window,
		and wrap (optional) is used for arguments that "wrap-around"
		(e.g., if arg1 and arg2 are right ascensions in degrees,
		then set wrap to 360.)

	Return:	A chain of TYPE1TYPE2MERGE objects

*****************************************************************************
</PRE>
<P>
<a name=typedef><h2>typedef</h2></a>
<PRE>
Create a new dervish type using a syntax that is identical that used to
declare typdef's in C programs.

   Example Usage (structs): 
		typedef struct [tag] {
			int i;		/* Index */
			float s1, s2;	/* Values */
			...
		   } NEWTYPE;

   Example Usage (enums): 
		typedef enum {BIG, SMALL, ...} NEWTYPE;

For struct definitions, a tag is optional.  Use of the tag inside the
definition  (e.g., struct tag *next, *prev) is OK.  Most standard C syntax is
supported (e.g., const, unsigned, all supported primitive DERVISH types).
Comments may be embedded in the body of the definition.  Inline array
dimensions may be specified with either [] or &lt;&gt; notation.  Unions
are not supported.  Restrictions: embedded members in structures that are
of complex data types must have had the types previously declared to Dervish.
Structure definitions within a structure are not supported.  For
enums, no explicit values may be assigned to members (thus, typdef enum
{BIG=10, SMALL=2} doesn't work).  For structs, an array dimension may be
specified with a symbolic name; that name is interpreted as a global TCL
variable, which must exist and have a positive integer value.

*****************************************************************************
</PRE>
<P>
<a name=makeio><h2>makeio</h2></a>
<PRE>
Scan one or more .h files and interpret all #define and typedef statements.

	Usage:	makeio [-pragma] filespec1 [filespec2 ...]

		filespec1:  Name of a .h file.  Wildcard notation is allowed.
		filespec2 ...: more of the same.

The specified files are scanned.  All #define statements are interpreted;
the first element is used to create a TCL global variable of that name;
the rest of the line is assigned as its value.  All typedef statements
are interpreted using the "typedef" facility of Dervish to define new Dervish
types.  If the -pragma flag is specified, only those typedefs with a
following comment of the form /* pragma SCHEMA */  or /* pragma USER */
or /* pragma CONSTRUCTOR */ are loaded.  (If multiple pragmas are given
in the comment and one is of the stated forms, then the typedef is loaded).

Note: in many cases, this routine can achieve the same effect as using
Dervish's compile time makeio facility.  This may require loading .h
files in a particular order so types are all defined before they are
used.  Tests show that many pipeline .h files and Dervish's .h files
can be loaded this way.  photo is hopeless.

If mixed data types are present, alignment of members within the typedef is
not guaranteed to match the alignment of the C compiler.  However, it is
thought that matching does occur with the SGI compiler's algorithm, and a
sampling of Dec Alpha and Sun compiler alignment properties does not show
any discrepancies.
*****************************************************************************
</PRE>
