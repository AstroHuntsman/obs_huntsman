# shTapes.tcl - Dervish tape commands
# 
# Vijay K. Gurbani
# (C) 1994 Fermi National Accelerator Laboratory, Batavia, Illinois
#     All Rights Reserved
#
# These set of TCL extensions provide a consistent wrapper around the
# system mt(1) command. 
# Their intention is a) to hide the mt(1) command line interface from the
# users, and b) provide a consistent interface to mt(1) from any survey
# supported UNIX platform.
# 
# All these TCL extensions take an optional command line parameter which
# denotes the tape drive being used. This may be omitted, in which
# case the value of $TAPE is used instead. If $TAPE is defined, and
# the user specifies the optional command line parameter, then
# the latter takes precedence.
# 
# TCL extension shTapePositionOverImage takes an extra optional parameter 
# which specifies how many EOF marks to skip. If omitted, the default is
# 1.
#
# Background:
# -----------
# FITS standard specifes that images stored on tape appear as follows:
#
#     image-1 <EOF> image-2 <EOF> ... image-n <EOF><EOF>
#
# Each image is delineated by an EOF marker. End of tape is delineated
# by two (2) EOF markers. Through my testing, I have determined that device
# drivers (at least the ones I tested on, and this should be true for all
# others as well) automatically write an EOF marker when they encounter
# a close(2) system call. So, the user does not have to write an explicit 
# EOF after writing the fits image on tape. On reaching the end of tape,
# the user HAS to explicitly write one EOF to denote end of tape. TCL
# extension shTapeWriteEot does that.
#     
# Help facility is "Tape"
#
# NOTE: The tape device driver must be a no-rewind, variable blocking,
#       no-swap driver.
#
# FUNCTIONS:
#
# Name                      Scope   Description
# -----------------------------------------------------------------------------
# showHelp                  Local   Displays a help message
# performErrorChecks        Local   Performs standard error checks
# tapeRewind                Global  Rewinds the tape device
# tapeEject                 Global  Ejects the tape from it's drive
# tapePositionOverImage     Global  Position tape head over nth FITS image
#                                      (where n is relative to the beginning
#                                       of tape)
# tapePositionOverNextImage Global  Position tape head over next FITS image
#                                      (or EOT)
# tapeWriteEot              Global  Write an EOT marker on tape
#
# RETURN VALUES:
#   All the above global functions return 1 on success, 0 otherwise.
#
# SHORTCOMINGS/BUGS:
#    - Should use switches for parameters, example -tape=tapeDevice and
#      -skip=n (switches being -tape and -skip)
#    - Could be more robust; for instance, have all functions return 1 on
#      success, 0 otherwise, or catch any errors generated by mt(1) command
#      or the uname(1) command.


set g_tapeToUse ""
catch {set g_tapeToUse $env(TAPE)} msg

# Help subsystem
set g_rewindHelp    "  Rewinds the tape device to the beginning of tape"
set g_ejectHelp     "  Ejects the tape from the drive"
set g_positionHelp  "  Position the tape over the nth FITS image"
set g_writeEotHelp  "  Write FITS standard End-Of-Tape marker"
set g_nextImageHelp "  Position tape over next FITS image (or EOT)"

ftclHelpDefine shTape tapeRewind                $g_rewindHelp
ftclHelpDefine shTape tapeEject                 $g_ejectHelp
ftclHelpDefine shTape tapePositionOverImage     $g_positionHelp
ftclHelpDefine shTape tapeWriteEot              $g_writeEotHelp
ftclHelpDefine shTape tapePositionOverNextImage $g_nextImageHelp
proc showHelp cmdName  {
     echo "  Usage: $cmdName \[tapeDevice\]"
     echo "     If tapeDevice is omitted, value of \$TAPE is used."
     echo "     Specifying tapeDevice takes precedence over using \$TAPE."
     echo "     Please specify a no-rewind, variable length and no-swapping"
     echo "     tape device driver"
     
     return
}

proc performErrorChecks {procName eString tDevice}  {

   if [string match -* $tDevice]  {
       echo $eString
       showHelp $procName
       return
   } elseif {$tDevice == ""}  {
      echo "  No tape device specified."
      showHelp $procName
      return 
   } elseif {![string match /dev/* $tDevice]}  {
      echo "  Please specify full device name; example /dev/nrst8"
      showHelp $procName
      return 
   }

   return
}

proc tapeRewind {{tapeDevice ""}}  {
   global g_tapeToUse
   global g_rewindHelp
   
   set procName "tapeRewind"

   if {$tapeDevice != ""}  {
       set tmp $tapeDevice
   } else  {
       set tmp $g_tapeToUse
   }

   if {[performErrorChecks $procName $g_rewindHelp $tmp] == 1}  {
      return 
   }
 
   exec mt -t $tmp rewind
}

proc tapeEject {{tapeDevice ""}}  {
   global g_tapeToUse
   global g_ejectHelp

   set procName "tapeEject"

   if {$tapeDevice != ""}  {
       set tmp $tapeDevice
   } else  {
       set tmp $g_tapeToUse
   }

   if {[performErrorChecks $procName $g_ejectHelp $tmp] == 1}  {
      return
   }

   # Find out what OS we are running on. On SunOS, the eject command is 
   # 'mt offline'; on IRIX it is 'mt unload'
   
   set ejectCmd "unload"
   set os [exec uname -s]
   if {$os == "SunOS"}  {
      set ejectCmd "offline"
   }

   exec mt -t $tmp $ejectCmd
}

proc tapePositionOverNextImage {{tapeDevice ""}}  {
   global g_tapeToUse
   global g_nextImageHelp

   set procName "tapePositionOverNextImage"

   if {$tapeDevice != ""}  {
       set tmp $tapeDevice
   } else  {
       set tmp $g_tapeToUse
   }

   if {[performErrorChecks $procName $g_nextImageHelp $tmp] == 1}  {
      return 
   }

   exec mt -t $tmp fsf 1
}


proc tapePositionOverImage args {
   global g_tapeToUse
   global g_positionHelp

   set errString "  Usage: tapePositionOverImage \[tapeDevice\] n\n\
      If tapeDevice is omitted, value of \$TAPE is used.\n \
     Specifying tapeDevice takes precedence over using \$TAPE.\n \
     Tape will be positioned over the nth FITS image.\n \
     Please specify a no-rewind, variable length and no-swapping\n \
     tape device driver."

#  Do all error checking locally, since the template of this extension
#  is different from the rest.

   set argLength [llength $args]

   if {$argLength == 0}  {
       echo $errString
       return 
   } elseif {$argLength == 1}  {
       set tapeDevice ""
       set n [lindex $args 0]
       if [string match -* $n]  {
          echo $g_positionHelp
          echo $errString
          return
       }
       if [regexp {^[0-9]} $n]  {
          set n [expr $n-1]
       } else  {
          echo "  Expected integral value for n, got $n instead"
          echo $errString
          return 
       }
   } elseif {$argLength == 2} {
       set tapeDevice [lindex $args 0]
       if [string match -* $tapeDevice]  {
          echo $g_positionHelp
          echo $errString
          return 
       }
       set n [lindex $args 1]      
       set n [expr $n-1]
   } else  {
       echo $errString
       return 
   }

   if {$tapeDevice != ""}  {
       set tmp $tapeDevice
   } else  {
       set tmp $g_tapeToUse
   }

   if {$tmp == ""}  {
      echo "  No tape device specified."
      echo $errString
      return 
   } elseif {![string match /dev/* $tmp]}  {
      echo "  Please specify full device name; example /dev/nrst8"
      echo $errString
      return 
   }

   exec mt -t $tmp fsf $n
}

proc tapeWriteEot {{tapeDevice ""}}  {
   global g_tapeToUse
   global g_writeEotHelp
   
   set procName "tapeWriteEot"

   if {$tapeDevice != ""}  {
       set tmp $tapeDevice
   } else  {
       set tmp $g_tapeToUse
   }

   if {[performErrorChecks $procName $g_writeEotHelp $tmp] == 1}  {
      return 
   }
   
   exec mt -t $tmp weof 1
}


























































