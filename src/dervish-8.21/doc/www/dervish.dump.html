<HTML>
<HEAD>

<TITLE>Dumping Data to Disk</TITLE>
<BODY>

<H1>Dumping Data to Disk</H1>

<H2>TCL API</H2>
<UL>
<LI><A HREF="tclDiskio.html">Dumping Data</A>
</UL>

<H2>C Routine Interface</H2>
<UL>
<LI><A HREF="diskio.html">Dumping Data</A>
</UL>

<H2><A NAME="diskio">Object Schema</A></H2>

<dir>
<li>
<a href=#schemaIntro>An introduction to Object Schema</a>
<li>
<a href=#schemaExample>Manipulating Values from TCL</a>
</dir>

<h3><a name=schemaIntro>An introduction to Object Schema</a></h3>

An object's schema is a term stolen from the world of databases, and means
a description of the internals of a complex object (the sort of information
that is available from the symbol table information generated by compilers).
Because one incarnation of DERVISH is as a high-level debugger, DERVISH needs
access to this information. It is automatically generated by a program
called make_io, which reads the definitions in C header files (.h files)
and generates the requisite C.<p>

<h3><a name=schemaExample>Manipulating Values from TCL</a></h3>


The source code for this example may be found in
$DERVISH_DIR/etc/dump_example.tcl.
An executable that knows about the
type FOO that this example uses may be built as
$DERVISH_DIR/examples/dervish_foo, but analogous examples could be built around
any of the SDSS data types (e.g. Regions).<p>

Let us imagine that you are running dervish_foo, and are curious about what
a FOO is. That's easily discovered, type:
<listing>
schemaPrintFromType FOO
</listing>
and dervish will say:
<listing>
type TYPE
next FOO*
prev FOO*
name char*
i int
l long
f float
</listing>
If you now look for the relevant include file, $DERVISH_DIR/examples/foo.h,
you'll find that the C is:
<listing>
typedef struct foo {
   TYPE type;
   struct foo *next, *prev;
   char *name;
   int i;
   long l;
   float f;
} FOO;
</listing>
which is reassuring. Let's now make a FOO and print it:
<listing>
set foo [fooNew]
exprPrint -header $foo
</listing>
to which the reply is:
<listing>
h7		FOO
(h7).type       (enum)1009
(h7).next       0x0
(h7).prev       0x0
(h7).name       (null)
(h7).i          0
(h7).l          0
(h7).f          0
</listing>
The first line "h7       FOO" tells you that $foo is a handle-to-FOO, the
rest are the values of the elements (and are not very interesting). Let's
set one of them:
<listing>
handleSet $foo.name "Hello World"
exprPrint -header -noquote $foo
</listing>
to which the reply is:
<listing>
h7		FOO
(h7).type       (enum)1009
(h7).next       0x0
(h7).prev       0x0
(h7).name       Hello World
(h7).i          0
(h7).l          0
(h7).f          0
</listing>
<p>

Thus emboldened, we can write a procedure to initialise FOOs:
<listing>
proc fooInit { foo name i l f } {
	foreach el "name i l f" {
		handleSet $foo.$el [set $el]
	}
	return $foo
}
</listing>
and say things like
<listing>
set foo2 [fooInit [fooNew] "God Bless the Queen" 12 65536 1.234]
exprPrint -header -noquote $foo2

h9	        FOO
(h9).type       (enum)1009
(h9).next       0x0
(h9).prev       0x0
(h9).name       God Bless the Queen
(h9).i          12
(h9).l          65536
(h9).f          1.234
</listing>

If you want to know how these procedures work, you should look at the
description of the TCL interface for <a href=tclDiskio.html>schema</a>
or for <A HREF=dervish.exprGet.html>accessing handle and their contents</A>; the basic
routines are <A HREF=tclDiskio.html#schemaGet>schemaGet</A> and
<A HREF=dervish.exprGet.html#exprGet>exprGet</A> which return TCL lists. For example:
<listing>
exprGet -header $foo2

{type FOO} {type (enum)1009} {next 0x0} {prev 0x0}
{name {God Bless the Queen}} {i 12} {l 65536} {f 1.234}
</listing>

<H2>Dumping and Restoring Complex Objects to Disk</H2>

<dir>
<li>
<a href=#dumpIntro>An introduction to disk dumps</a>
<li>
<a href=#dumpExample>An example of generating and reading a dump from TCL</a>
</dir>

<h3><a name=#dumpIntro>An introduction to disk dumps</a></h3>

Details of the
<a href=diskio.html>C</a> and <a href=tclDiskio.html>TCL</a> interfaces
may be found elsewhere.

<h3><a name=dumpExample>
An example of generating and reading a dump from TCL
</a></h3>

The source code for this example may be found in
$DERVISH_DIR/etc/dump_example.tcl. An executable that knows about the
type FOO that this example uses may be built as
$DERVISH_DIR/examples/dervish_foo, but the code will work even with a
vanilla version of dervish.<p>

This code generates a dump, and then reads it back. There are two procs:
<dl>
<dt> <a href=#fooInit>fooInit</a>
<dd> Initialises a FOO
<dt> <a href=#testDumpWrite>testDumpWrite</a>
<dd> Writes a test dump file
</dl>

There is then a section of code that writes a dump file, and reads it back.<p>

There are also a number of other procs in dervishStartup.tcl, which should
have been read for you automatically. These deal with
<a href=tclDiskio.html>disk dumps</a>.

The way that dumpRead works is to generate a list of handles; I put
this list into a variable d1. So to look at the
<a name=dumpListing>results</a> of the dump say
<listing>
	dumpPrint $d1
</listing>
which will print something like:

<listing>
tst_dump.dat: Created Fri Jun 11 09:01:18 1993
h3  REGION
h4  REGION
h5  REGION
h6  FLOAT
h7  STR
h8  INT
h9  FOO
h10 LIST
</listing>

Then you can say
<listing>
	exprPrint h4
</listing>
to look at things. I pretty soon get fed up with typing exprPrint, so:
<listing>
	alias p exprPrint
	alias pl listPrint
</listing>
and
<listing>
	p h10
	pl h10
</listing>

You get the point.<p>

First <a name="fooInit">a utility proc to initialise FOOs</a>:
<listing>
#
# TCL procedures to manipulate FOOs
#
# Initialise a FOO
#
proc fooInit { foo name i l f } {
	foreach el "name i l f" {
		handleSet $foo.$el [set $el]
	}
	return $foo
}
</listing>
And then <a name="testDumpWrite">a proc to generate things to dump, and then
dump them</a>:
<listing>
#
# Write a test disk dump to &lt;file&gt;
#
proc testDumpWrite { file } {
	#
	# create a set of regions
	#
	set r0 [regNew -type=S16 -mask 20 10]
	regSetWithDbl $r0 10
	regPixSetWithDbl $r0 5 8 100
	set r1 [subRegNew $r0 10 5 2 4]
	set r2 [subRegNew $r0 8  5 1 4]
	#
	# dump various things to a file; first these [sub]regions,
	# then some primitive types, then a FOO and a list of FOOs
	# if FOOs are available
	#
	dumpOpen $file w

	dumpHandleWrite $r0
	dumpHandleWrite $r1
	dumpHandleWrite $r2
	dumpValueWrite 3.14159 FLOAT
	dumpValueWrite "For the Snark was a Boojum, you see" STR
	dumpValueWrite 32767 INT
	catch {					# we may not be FOO capable
		set foo [fooInit [fooNew] "Hello World" 10 1000 3.14159]
		dumpHandleWrite $foo; handleDel $foo

		set list [listNew FOO]
		foreach n {"Yr Wyfdda" "Carnedd Llewellyn" "Pen Yr Oleu Wen"} {
			set foo [fooInit [fooNew] $n 0 1 2.71828]
			listAdd $list $foo
			handleDel $foo
		}
		dumpHandleWrite $list; handleDel $list
	}

	dumpClose
}
</listing>
We can now actually write a dump, read it back, and
<a href=#dumpListing>see what we got</a>:
<listing>
#
# write a dump
#
set test_file_name "tst_dump.dat"
testDumpWrite $test_file_name
#
# and read it back. The list of handles is in $d1
#
set d1 [dumpRead $test_file_name]
dumpPrint $d1
</listing>

</html>

</HTML>
