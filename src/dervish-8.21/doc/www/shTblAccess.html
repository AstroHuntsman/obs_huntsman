<HTML>
<HEAD>
<!-- *********************************************************************** -->
<!-- *++
<!-- * FACILITY:	Dervish
<!-- *			Documentation
<!-- *
<!-- * ABSTRACT:	Dervish Tables.  Internals.
<!-- *
<!-- * ENVIRONMENT:	HTML (HyperText Markup Language).
<!-- *			shTblAccess.html
<!-- *
<!-- * AUTHOR:		Tom Nicinski, Creation date:  22-Nov-1993
<!-- *--
<!-- *********************************************************************** -->

<TITLE>Table Access Under Dervish / TBLCOL Format</TITLE>

<H1><A NAME="TBLCOL Tables">Table Access Under Dervish / TBLCOL Format</A></H1>

<P>
The columnar (<SAMP>TBLCOL</SAMP>) format provides two benefits for the Dervish
user:

<UL>
<LI>	The form of the <A HREF="dervish.fitsio.html#tblcol">ASCII or Binary Table</A> 
	in the FITS file does not need to be known prior to reading the FITS
	file.
<P>
<LI>	The data is stored in a field-oriented way, allowing efficient access to
	all values of a particular field from the Table.
</UL>

<P>
The fields of a <SAMP>TBLCOL</SAMP> Table are described with a
<A HREF="dervish.chain.html#chain"><SAMP>CHAIN</SAMP></A> of
<A HREF="dervish.home.html"><SAMP>ARRAY</SAMP></A> and
<A HREF="#TBLFLD"><SAMP>TBLFLD</SAMP></A>
type <A HREF="dervish.dump.html#diskio">object schemas</A>.
Generally, a <SAMP>TBLCOL</SAMP> Table looks like:

<LISTING>
                                  +--------+
                                  |        |
                                  | TBLCOL +-----+
                                  |        | HDR |
                                  +--------+-----+
        .-------------------------| CHAIN  |------------------------.
        |                         +--------+                        |
        |                                                           |
        |   +-------+     +-------+       +-------+     +-------+   |
        `-->|   o   |<--->|   o   |<-...->|   o   |<--->|   o   |<--'
            +---+---+     +---+---+       +---+---+     +---+---+
                |             |               |             |
                V             V               V             V
      .---->+-------+     +-------+       +-------+  .->+-------+
      |     |       |     |       |       |       |  |  |       |
      |     | ARRAY |     | ARRAY |  ...  | ARRAY |  |  | ARRAY |
      |     |       |     |       |       |       |  |  |       |
      |  .--+o     o|     |      o|       |o     o|  |  |o     o|
      |  |  +------|+     +------|+       +|-----|+  |  +|-----|+
      |  |         |             |         V     V   |   |     `--.
      |  V         V             V                   |   V        V
     +|-------+  +------+      +------+             +|-------+  +------+
     |o       |  |      |      |      |             |o       |  |      |
     |        |  /      /      /      /             |        |  /      /
     | TBLFLD |  / data /      / data /     ...     | TBLFLD |  / data /
     |        |  |      |      |      |             |        |  |      |
     +--------+  +------+      +------+             +--------+  +------+
</LISTING>

<P>
The <A HREF="#TBLCOL"><SAMP>TBLCOL</SAMP> structure</A> mainly
heads the <SAMP>CHAIN</SAMP> of <SAMP>ARRAY</SAMP>s, one per Table field.
Each <SAMP>ARRAY</SAMP> describes the field data and points off to it.
The <A HREF="#TBLFLD"><SAMP>TBLFLD</SAMP> structure</A> is
optional.  It provides additional information about a Table field.

<P>
At first glance, having a <SAMP>CHAIN</SAMP> of <SAMP>ARRAY</SAMP>s point off
to the data and additional Table information in <SAMP>TBLFLD</SAMP>
object schemas may appear to be illogical.
Since <SAMP>ARRAY</SAMP>s have already described the field data,
the "non-essential" information in the <SAMP>TBLFLD</SAMP>s can now be
optional.
Thus, the construction of Tables by the user is simplified, as there are less
mandatory structures that need to be filled in.
Another benefit is that the <SAMP>ARRAY</SAMP> objects used to describe field
data are <EM>not</EM> Table-specific;  they can be used to describe other
arrays in the Dervish environment, reducing the proliferation of application
specific structures that are similar.

<P>
The above drawing is not all-encompasing.
The concept of <A HREF="#Heap">heap</A> storage is not shown.
A Table field consisting of heap allows variable length data to be stored
efficiently.

<H2><A NAME="Scalars/Arrays">Scalars and Arrays Under TBLCOL Format</A></H2>

<P>
<SAMP>TBLCOL</SAMP> data is maintained by
<A HREF="dervish.array.html#intro"><SAMP>ARRAY</SAMP>s</A>.
When reading about <SAMP>ARRAY</SAMP>s, keep in mind that when a FITS Table
is read into a Dervish Table, an additional array dimension, namely the Table
row is added to the Dervish Table.  This is the slowest varying
(first) index.  A Binary Table scalar field becomes a 1-dimensional array in
a Dervish Table.  A Binary Table field containing an <I>n</I>-dimensional array
becomes an <I>(n+1)</I>-dimensional array in the Dervish Table.

<P>
FITS ASCII and Binary Tables differ when it comes to arrays as data within a
field.
ASCII Tables (<SAMP>TABLE</SAMP> HDUs) do not permit arrays;  a field can only
hold a scalar value (or a character string).
Binary Tables (<SAMP>BINTABLE</SAMP> HDUs), on the other hand, permit a field
to contain both a scalar or an array of values.

<P>
Since the ASCII Table is more restrictive, it is still possible to discuss
them as if they allowed 1-dimensional arrays (to permit character strings
to be handled).
In the discussion below, for an ASCII Table, <SAMP>TFORM</SAMP>n's element
count would always be one (1).  Additionally, even though ASCII Tables do
not permit the <SAMP>TDIM</SAMP>n keyword, allowing its limited use (only
row index and character string index are allowed) permits <SAMP>TBLCOL</SAMP>
Tables to remain generic.

<P>
<A NAME="ARRAY's 1st Dimension">Although a Table field form</A>
(<SAMP>TFORM</SAMP>n keyword) can indicate a scalar
value (a element count of one (1) without a corresponding <SAMP>TDIM</SAMP>n
specification) or a multidimension array, <EM>all</EM> field values are stored
as an array in the <SAMP>TBLCOL</SAMP> format.
The <A HREF="dervish.array.html#intro"><SAMP>ARRAY</SAMP></A> object schema describes
how data is stored.
At a minimum, the Table row number is the slowest varying index, as in this C
code example:

<LISTING>
     myField[row][d ][d ]...[d ]     (where row is equivalent to d )
                   1   2      c                                   0
</LISTING>

where <VAR>c</VAR> is the number of dimensions specified by <SAMP>TDIM</SAMP>n.

<P>
The notation used throughout follows C's <EM>row-major</EM> ordering of array
elements, that is, the last subscript varies most rapidly.
FITS' <EM>column-major</EM> ordering of array dimensions (where the first
subscript varies most rapidly) specified by <SAMP>TDIM</SAMP>n is reversed
under Dervish.
In the example above:

<PRE WIDTH="132">
                     <CODE>     </CODE><VAR> </VAR><CODE>     </CODE><I>th</I>
     d   is  TDIMn's <CODE>(c - </CODE><VAR>i</VAR><CODE> + 1)</CODE>   subscript
      <VAR>i</VAR>
</PRE>

where <VAR>i</VAR> and <SAMP>TDIM</SAMP>n's subscripts are 1-indexed:

<LISTING>
     TDIMn = '(s ,s , ...,s )'
                1  2       c
</LISTING>

<P>
The analogy to C arrays applies only to notation
(<A HREF="dervish.array.html#Notation Limitations">other limitations</A>
with respect to the notation also apply).
Since the <SAMP>TBLCOL</SAMP> format is generic, array dimensions are unknown
until the file is read.  Therefore, multidimension arrays are stored in such
a manner that regular C syntax can be used to access these arrays without
knowing their dimensions at compilation-time (thus, they're not stored the
same a C arrays).
The C concept of an array name representing a pointer to the array is used to
accomplish this type of addressing.  For <I>n</I>-dimensional arrays, <I>n</I>
sets of pointers are used.  The first pointer is associated with the array name.
It points to the data in a 1-dimensional array or to the second set of pointers.
These pointers in turn point to the data in a 2-dimensional array or to the
third set of pointers; and so forth.

<H2><A NAME="Headers">Dervish Headers</A></H2>

<P>
Besides information maintained by the
<A HREF="dervish.array.html#intro"><SAMP>ARRAY</SAMP></A> and
<A HREF="#TBLFLD"><SAMP>TBLFLD</SAMP></A> strutures,
additional information can be retrieved from the Table's
<A HREF="hdr.html">Dervish header</A>.
Dervish headers are <EM>not</EM> FITS headers, though they look remarkably
similar.
The similarity does extend to some restrictions Dervish places on the format of
Dervish headers (for example, the length of character string values is limited).
These restrictions allow Dervish headers to be readily converted to FITS headers,
when a Table is written out to a FITS file, without any information loss.

<P>
The Dervish header is accessed through a Dervish handle.  For example, in Tcl, if
`<SAMP>h3</SAMP>' is the handle for a <SAMP>TBLCOL</SAMP> Table,
the Dervish header entries can be accessed with

<PRE WIDTH="132">
     <B>dervish&gt;</B> hdrGetLine h3.hdr AUTHOR
</PRE>

<P>
<A NAME="Unaccessible Header Keywords">Information about the Table</A>
is maintained in several places, but never duplicated.
Therefore, many FITS header keywords from the original FITS ASCII or Binary
Table (if the Dervish Table was created by reading it from a FITS file) are not
accessible from the Dervish header:

<DIR>
<LI>	<SAMP>XTENSION</SAMP>
<LI>	<SAMP>BITPIX</SAMP>
<LI>	<SAMP>NAXIS</SAMP>
<LI>	<SAMP>NAXIS</SAMP>n
<LI>	<SAMP>TFIELDS</SAMP>
<LI>	<SAMP>PCOUNT</SAMP>
<LI>	<SAMP>GCOUNT</SAMP>
<LI>	<SAMP>THEAP</SAMP>
<LI>	<SAMP>END</SAMP>
</DIR>

Some of that information is available from the
<A HREF="#TBLCOL"><SAMP>TBLCOL</SAMP></A> handle.
Per-field keywords are also not accessible from the Dervish header:

<DIR>
<LI>	<SAMP>TBCOL</SAMP>n
<LI>	<SAMP>TFORM</SAMP>n
<LI>	<SAMP>TTYPE</SAMP>n
<LI>	<SAMP>TUNIT</SAMP>n
<LI>	<SAMP>TDISP</SAMP>n
<LI>	<SAMP>TSCAL</SAMP>n
<LI>	<SAMP>TZERO</SAMP>n
<LI>	<SAMP>TNULL</SAMP>n
<LI>	<SAMP>TDIM</SAMP>n
</DIR>

Much of this per-field information is available from the optional
<A HREF="#TBLFLD"><SAMP>TBLFLD</SAMP></A> handle associated
with the field.

<P>
Information in the <SAMP>TBLCOL</SAMP> and <SAMP>TBLFLD</SAMP> structures
that was originally filled from a FITS header will accurately represent
the value from the FITS header keyword.  But it will <EM>not</EM> retain
any comment associated with the FITS header keyword.  That information is
lost.

<H3><A NAME="Forbidden Header Keywords">Modifying the FITS Header into a Dervish Header</A></H3>

<P>
This Dervish header fields listed
<A HREF="#Unaccessible Header Keywords">above</A> are a superset of those found
in ASCII and Binary Tables.
If the Table was read from a FITS file (extension HDU), the values for these
fields came from the FITS header.  These keywords, indexed by a field position
(e.g., <SAMP>TTYPE</SAMP>5), are removed from the FITS header.
Some of these keywords are recognized only for a particular Table type.
For example, <SAMP>TDIM</SAMP>n is recognized in Binary Table headers only,
while <SAMP>TBCOL</SAMP>n is recognized only in ASCII Table headers.
Yet, these keywords <EM>are still</EM> removed from the FITS header for other
Table types, <EM>without</EM> reading and saving their values in a
<SAMP>TBLFLD</SAMP> handle.
The resulting Dervish header has very little information categorizing it as
coming from an ASCII or Binary Table, achieving the goal of a generic Table.

<P>
<A NAME="Unknown Header Keywords">Unknown keywords</A>
(non-standard and not Dervish extension keywords) which are
indexed by a field position (for example, <SAMP>TMINE</SAMP>n) are <EM>not</EM>
removed from the Dervish header.  This may cause problems if fields are inserted
into or removed from the Table.  In that case, the field positions (ordinals)
might not match the user-defined keywords in the Dervish header.
This does not happen with known keywords that have been removed from the
Dervish header and are maintained in the <SAMP>TBLFLD</SAMP> handle, without any
reference to a positional index (<VAR>n</VAR>).

<P>
Users may (but should not) add keywords that were removed from the header
(for example, <SAMP>NAXIS</SAMP>).
When a Table is written out to a FITS file,
<A HREF="shTblWrite.html#Headers">these "forbidden" keywords in the header are <EM>not</EM> used</A>.

<H2><A NAME="Special Data Types">Special Data Types</A></H2>

<P>
Additional <A HREF="dervish.dump.html#diskio">object schemas</A> have been defined
to handle Dervish Table needs.

<P>
<A NAME="LOGICAL">The object schema type <SAMP>LOGICAL</SAMP></A> describes a
logical value, either zero (0) value to represent "false" or a non-zero value
(which should be one (1)) to represent "true."
<SAMP>LOGICAL</SAMP> is provided to differentiate between a byte and a boolean
value.
This is needed to support the Binary Table `<SAMP>L</SAMP>' data type (which
takes on the values `<SAMP>T</SAMP>' and `<SAMP>F</SAMP>' rather than a binary
number as a byte does).

<P>
<A NAME="Special Data Types:STR"><SAMP>ARRAY</SAMP>s also use</A>
the object schema type <SAMP>STR</SAMP> in a manner that
<A HREF="dervish.array.html#Data Type Conventions">may not be intuitive</A>
at first (but it is self consistent).
<SAMP>STR</SAMP>'s use is necessary to distinguish an array of bytes
representing a character string from an array of numeric valued bytes.

<P>
Finally, the <SAMP>TBLHEAPDSC</SAMP> object schema type is used to implement
<A HREF="#Heap">heap storage</A> (from Binary Tables).

<!-- *********************************************************************** -->

<!-- *********************************************************************** -->

<H2><A NAME="TBLCOL">TBLCOL Structure/Object Schema</A></H2>

<P>
Dervish Tables are headed by the <SAMP>TBLCOL</SAMP>
<A HREF="dervish.dump.html#diskio">object schema</A>.
<SAMP>TBLCOL</SAMP> provides access to the Dervish header associated with the
Table and the Table fields.

<H3>TBLCOL Fields</H3>

<P>
The <SAMP>TBLCOL</SAMP> structure contains very little information.  It does
allow access to the Dervish header associated with the Table.  It also heads
the <A HREF="dervish.chain.html#chain"><SAMP>CHAIN</SAMP></A> of
<A HREF="dervish.array.html#intro"><SAMP>ARRAY</SAMP>s</A>, one per Table field.
The description is done from a C view, but its use can be easily extended to
Tcl and object schemas.
The C header file, <A HREF="file:../../include/shCTbl.h"><B>shCTbl.h</B></A>,
contains the <SAMP>TBLCOL</SAMP> declaration.

<PRE WIDTH="132">
+-----------+		<I>Number of rows in Table. <EM>Must</EM> match each</I>
| rowCnt    |		<I><SAMP>ARRAY</SAMP>'s first dimension, <CODE>dim[0]</CODE>.</I>
+-----------+------+
|                  |
/ hdr              /	<I>Dervish header.</I>
|                  |
+------------------+
|                  |	<I><SAMP>CHAIN</SAMP> head to fields (<SAMP>ARRAY</SAMP>s).  This</I>
|       -----------+	<I>allows arrays to be added and removed</I>
/ fld   type       /	<I>easily.  <CODE>type</CODE> is <B>makeio</B>'s type for the</I>
|       -----------+	<I><SAMP>ARRAY</SAMP> object schema (return from</I>
|                  |	<I><B>shTypeGetFromName ("ARRAY")</B>).</I>
+------------------+
</PRE>

<!-- *********************************************************************** -->

<!-- *********************************************************************** -->

<H2><A NAME="TBLFLD">TBLFLD Structures/Object Schemas</A></H2>

<P>
For all Tables, information about a Table field's data is maintained in the
<A HREF="dervish.array.html#intro"><SAMP>ARRAY</SAMP></A> structure.
Optional information about a Table field is maintained in the
<SAMP>TBLFLD</SAMP> structure, accessible from both a C structure and a Tcl
<A HREF="tclHandle.html">handle</A> and
<A HREF="dervish.dump.html#diskio">object schema</A>.
Access to a <SAMP>TBLFLD</SAMP> structure for a <SAMP>TBLCOL</SAMP> format
Table is dependent upon the language in use (C or Tcl):

<UL>
<LI>	<A HREF="#TBLCOL Tables"><SAMP>TBLCOL</SAMP></A> format
	Table under C:
	<UL>
	<P>
	<LI>	<A HREF="shTbl.html#shTblFldLoc"><B>shTblFldLoc</B></A>
		locates a particular <SAMP>TBLFLD</SAMP> structure.
	</UL>
	<P>
	Under Tcl:
	<UL>
	<P>
	<LI>	<A HREF="tclTbl.html#tblFldInfoGet"><B>tblFldInfoGet</B></A>
		returns information from a <SAMP>TBLFLD</SAMP> structure.
	</UL>
</UL>

<H3>TBLFLD Fields</H3>

<P>
The <SAMP>TBLFLD</SAMP> structure contains mostly information retrieved from the
FITS header when the ASCII or Binary Table was read (if the Table was created,
the creator needs to fill in this information).
The description is done from a C view, but its use can be easily extended to
Tcl and object schemas.
The C header file, <A HREF="file:../../include/shCTbl.h"><B>shCTbl.h</B></A>,
contains the <SAMP>TBLFLD</SAMP> declaration.

<!--+-----------+------+
<!--|       ascFldWidth|	<I><!--<CODE><!--TFORM</CODE><!-- specifies preferences for how write data to an</I>
<!--|       -----------+	<I><!--ASCII Table (it can't be used to convert ARRAY data</I>
<!--|       ascFldDecPt|	<I><!--types to another). <CODE><!--ascFldFmt</CODE><!-- is an ASCII Table</I>
<!--| TFORM -----------+	<I><!--<A HREF="shTblRead.html#Supported ASCII Table Data Types"><!--data type</A><!--;<CODE><!--ascFldWidth/DecPt</CODE><!-- are the field</I>
<!--|       ascFldFmt  |	<I><!--width/decimal point placement. <CODE><!--ascFldOff</CODE><!-- is the</I>
<!--|       -----------+	<I><!--field offset (0-indexed) in the row (if it's -1, Dervish</I>
<!--|       ascFldOff  |	<I><!--determines the offset). The FITS reader sets <CODE><!--TFORM</CODE><!--.</I>
<!-- -->
<PRE WIDTH="132">
+-----------+		<I>Bitmask indicating <SAMP>T</SAMP>xxx keyword (<SAMP>TBLFLD</SAMP></I>
| Tpres     |		<I>member) presence (a <A HREF="file:../../include/shCUtils.h"><B>shCUtils.h</B></A> set).</I>
+--------+--//--+--+--+
| TTYPE  |  ... |  |  |	<I>Field label.</I>
+--+--+--+--//--+--+--+
| TUNIT  |  ... |  |  |	<I>Physical units of field</I>
+--+--+--+--//--+--+--+
| TDISP  |  ... |  |  |	<I>Suggested FORTRAN 90 format to display</I>
+--+--+--+--//--+--+--+	<I><CODE>   </CODE>field.</I>
| TSCAL     |		<I>Scale factor (<EM>not applied</EM> to data).</I>
+-----------+
| TZERO     |		<I>Zero offset (<EM>not applied</EM> to data).</I>
+-----------+
| TNULLSTR  |		<I>Undefined value for integers (<EM>not applied</EM></I>
+-----------+		<I><CODE>   </CODE> to data) as a character string.</I>
| TNULLINT  |		<I>Undefined value for integers (<EM>not applied</EM></I>
+-----------+		<I><CODE>   </CODE> to data) as a signed 32-bit integer.</I>
| array    o+-->	<I>Permits access to data through <A HREF="dervish.array.html#ARRAY"><SAMP>ARRAY</SAMP></A>.</I>
+-----------+------+
|                  |	<I>Description of <A HREF="#Heap Data">data</A> store in <A HREF="#Heap">heap</A>, along</I>
/ heap             /	<I>with <SAMP>ARRAY</SAMP>'s <SAMP>TBLHEAPDSC</SAMP> data. <CODE>Tpres</CODE></I>
|                  |	<I>has <SAMP>SH_TBL_HEAP</SAMP> set to indicate heap use.</I>
+------------------+
|                  |	<I>Private data used when reading/writing</I>
/ prvt             /	<I>FITS files. None of the fields in <CODE>prvt</CODE></I>
|                  |	<I>should be used/relied upon by the user.</I>
+------------------+
</PRE>

<P>
<SAMP>TTYPE</SAMP>, <SAMP>TUNIT</SAMP>, and <SAMP>TDISP</SAMP> have
preallocated space of <B>shFitsHdrStrSize</B> characters, plus one
additional character for null termination of the string.
Thus, the values of these fields can (<EM>must</EM>) be changed <I>in situ</I>.

<P>
The <SAMP>TBLFLD</SAMP> structure contains information that is the union of
ASCII Table and Binary Table information.
When <A HREF="shTblWrite.html#">writing</A> the Table out to a FITS file,
only the information appropriate to the HDU extension type (<SAMP>TABLE</SAMP>
or <SAMP>BINTABLE</SAMP>) will be written to the FITS header.
Also, when writing the Table,
<SAMP>TSCAL</SAMP>n/<SAMP>TZERO</SAMP>n are treated specially if it is
necessary to
<A HREF="shTblWrite.html#TSCAL/TZERO">generate a FITS-compliant HDU</A>.

<H3>Accessing Data</H3>

<P>
Data is accessed through <SAMP>TBLFLD</SAMP>'s <CODE>array</CODE> field.
<A HREF="dervish.array.html#intro"><SAMP>ARRAY</SAMP></A> object schemas describe
arbitrary <I>n</I>-dimensional arrays and allow
<A HREF="dervish.array.html#Accessing Data">access</A> to them.
Consider a Dervish Table specific example, in C, involving arrays.
The example reflects Dervish Table's use of the slowest varying (first) index
as the Table row index.
<CODE>myField</CODE> is the name of the "array" indexed by the Table row number.
<CODE>array</CODE> points to the <SAMP>ARRAY</SAMP> structure of the field
we're interested in and <CODE>tblFld</CODE> points to the associated
<SAMP>TBLFLD</SAMP> structure:

<LISTING>
     #include "dervish_msg_c.h"
     #include "shCArray.h"
     #include "shCTbl.h"

     ARRAY        *array;         /* Field we're interested in               */
     TBLFLD       *tblFld;        /* Field we're interested in               */
           int     tblFldIdx;     /* Position (0-index) of field             */
     short int   **myField;       /* We know a priori this is a 2-D array    */
                                  /* of shorts (1st dimension is Table row); */
               .                  /* but we don't know the dimensions.       */
               :
     if (shTblFldLoc (..., &amp;array, &amp;tblFld, &amp;tblFldIdx) == SH_SUCCESS)
        {
        myField = ((short int **)array->arrayPtr);
               .
               :
        ... myField[row][x] ...
               .
               :
        /*
         * If TBLFLD information is used, make sure that a TBLFLD is actually
         * present.  TBLFLDs are   N O T   required for Dervish Tables.
         */

        if (tblFld != ((TBLFLD *)0))
           {
           if (   (shInSet (tblFld->Tpres, SH_TBL_TSCAL)
               &amp;&amp; (shInSet (tblFld->Tpres, SH_TBL_TZERO) )
              {
              ... ((myField[row][x] * tblFld->TSCAL) + tblFld->TZERO) ...
              }
           }
        }
</LISTING>

As <A HREF="dervish.array.html#Accessing Data">described for general arrays</A>,
<CODE>array->arrayPtr</CODE> should be used to initialize <CODE>myField</CODE>
in all cases.
<CODE>array->data.dataPtr</CODE>, the pointer to the first byte of data in the
field, should <EM>not</EM> be used for reference through <CODE>myField</CODE>.
But, <CODE>array->data.dataPtr</CODE> can be used when filling in array data
in a linear fashion.

<!-- *********************************************************************** -->

<!-- *********************************************************************** -->

<H2><A NAME="Heap">Heap Storage</A></H2>

<P>
Heap storage is a concept from FITS Binary Tables.  It allows variable length
array data to be stored efficiently with respect to space.
The <A HREF="dervish.array.html#ARRAY"><SAMP>ARRAY</SAMP>'s</A> data consists of
<SAMP>TBLHEAPDSC</SAMP> object schemas which describe the variable length data.
The actual data is owned by the <SAMP>TBLFLD</SAMP>.
The general structure of a <SAMP>TBLCOL</SAMP> Table now expands a bit
for fields with heap data:

<LISTING>
                                  +--------+
                                  |        |
                                  | TBLCOL +-----+
                                  |        | HDR |
                                  +--------+-----+
        .-------------------------| CHAIN  |------------------------.
        |                         +--------+                        |
        |                                                           |
        |   +-------+     +-------+       +-------+     +-------+   |
        `-->|   o   |<--->|   o   |<-...->|   o   |<--->|   o   |<--'
            +---+---+     +---+---+       +---+---+     +---+---+
                |             |               |             |
                V             V               V             V
      .---->+-------+     +-------+       +-------+  .->+-------+
      |     |       |     |       |       |       |  |  |       |
      |     | ARRAY |     | ARRAY |  ...  | ARRAY |  |  | ARRAY |
      |     |       |     |       |       |       |  |  |       |
      |  .--+o     o|     |      o|       |o     o|  |  |o     o|
      |  |  +------|+     +------|+       +|-----|+  |  +|-----|+
      |  |         |             |         V     V   |   |     `--.
      |  V         V             V                   |   V        V
     +|-------+  +------+      +------+             +|-------+  +------+
     |o       |  |      |      |      |             |o       |  | TBL o+-----.
     |        |  /      /      /      /             |        |  / HEAP /     |
     | TBLFLD |  / data /      / data /   ...       | TBLFLD |  / DSCs /     |
     |        |  |      |      |      |         .---+o       |  |     o+-.   |
     +--------+  +------+      +------+         |   +--------+  +------+ |   |
                                                |                        |...|
                 `--.---'      `--.---'         |   +------+             |   |
                    |             |             `-->|      |<------------|---'
     non-heap data -+-------------'                 / heap /      .      |
                                                    / data /      :      |
                                                    |      |<------------'
                                                    +------+
</LISTING>

<H3><A NAME="TBLHEAPDSC">TBLHEAPDSC Fields</A></H3>

<P>
The <SAMP>TBLHEAPDSC</SAMP> data type is used to describe the length, in
datum units, and position of heap data.
The <A HREF="dervish.array.html#ARRAY"><SAMP>ARRAY</SAMP> structure</A>
will have a <SAMP>TBLFLD</SAMP> hung off its <CODE>info</CODE> member.
Dimension information maintained by the <SAMP>ARRAY</SAMP>
(<CODE>dimCnt</CODE> and <CODE>dim</CODE>) reflects the array dimensions of
<SAMP>TBLHEAPDSC</SAMP>s (owned by the <SAMP>ARRAY</SAMP>), <EM>not</EM> the
heap data.  The <SAMP>ARRAY</SAMP>'s
<A HREF="dervish.array.html#Hierarchy of Array Pointers">hierarchy of array pointers</A>
also applies only to the <SAMP>TBLHEAPDSC</SAMP>s.

<PRE WIDTH="132">
+------------------+
|       cnt        |	<I>Number of elements in heap datum.</I>
|       -----------+
|       ptr        |	<I>Address of first element of heap datum.</I>
+------------------+
</PRE>

<P>
<A NAME="TBLHEAPDSC and TDIMn"><B>NOTE:</B></A><I>
There may be some controversy as to what the FITS keyword <SAMP>TDIM</SAMP>n
really means for variable length data
(it should be noted that the FITS Binary Table Standard lists <SAMP>TDIM</SAMP>n
as a convention for multidimensional arrays, not as part of the Standard).
Under Dervish, the FITS <SAMP>TDIM</SAMP>n keyword is <EM>not</EM> supported
with a Binary Table <SAMP>TFORM</SAMP>n data type of `<SAMP>P</SAMP>'.
</I>

<H3><A NAME="Heap Data">Heap Data</A></H3>

<P>
<SAMP>TBLHEAPDSC</SAMP> data in the <SAMP>ARRAY</SAMP> only describes the
amount and location of the data.  It does not provide any information about
the data type.
As data in heap is owned by the <SAMP>TBLFLD</SAMP> structure,
<SAMP>TBLFLD</SAMP>'s <CODE>heap</CODE> member describes that data.
That description is the same as the
<A HREF="dervish.array.html#ARRAY"><SAMP>ARRAY</SAMP>'s</A> <CODE>data</CODE>
member.

<PRE WIDTH="132">
+------------------+	<I>Points to 1st heap data element (all are</I>
|       dataPtr   o+-->	<I>contiguous).  Heap <B>must</B> be <B>shMalloc</B>ed.</I>
|       -----------+
|       schemaType |	<I><B>makeio</B>'s type for the <CODE>heap</CODE>.</I>
|       -----------+
| heap  size       |	<I>Size (bytes) of object schema in heap.</I>
|       -----------+
|       align      |	<I>Alignment factor of 1st object schema.</I>
|       -----------+
|       incr       |	<I>Address increment between object schemas.</I>
+------------------+
</PRE>

<P>
If available, <CODE>heap.schemaType</CODE> describes the object schema type
of the data stored in heap (if it's not available, <CODE>heap.schemaType</CODE>
is set to <SAMP>UNKNOWN</SAMP>).
Heap data types are handled in the same manner as the data types in the
<SAMP>ARRAY</SAMP> data area.
For example, character strings (<SAMP>STR</SAMP> object schema type) must have
an <A HREF="shTblRead.html#Beyond the FITS Standard">additional character</A> used to
guarantee null-termination of character strings.
Heap data types are not restricted to primitive data types.
But, if the data type does not match a
<A HREF="shTblRead.html#Mapping Binary Data Types">Binary Table data type</A>
that is mapped to an object schema, heap data will be
<A HREF="shTblWrite.html#Writing to FITS">written</A> as an unknown type to a
FITS file HDU.

<P>
The location of heap data is maintained in two places:

<UL>
<LI>	the <SAMP>TBLHEAPDSC</SAMP> structure points to the first element of a
	particular variable length array.  The <CODE>ptr</CODE> field should be
	used when referencing heap data.
<P>
<LI>	<CODE>heap.dataPtr</CODE> can be used to point to a heap data area
	which "belongs" to the <SAMP>TBLFLD</SAMP>.  This structure member
	provides information used for memory handling (namely deallocation).
</UL>

Heap data does <EM>not</EM> need to stored in a <SAMP>TBLFLD</SAMP>-owned piece
of memory.
Therefore, <CODE>heap.dataPtr</CODE> can be set to point to a zero (0) address
(null) while <SAMP>ARRAY</SAMP> <SAMP>TBLHEAPDSC</SAMP>s still point off to heap
data.

<P>
Consider an example of 3 rows of <SAMP>TBLHEAPDSC</SAMP> data in the
<SAMP>ARRAY</SAMP>.
The first row points to heap data outside of the heap area owned by the
Table field's <SAMP>TBLFLD</SAMP>.  The remaining 2 rows point to data
contained within the <SAMP>TBLFLD</SAMP>'s heap data area.
<CODE>XXXX</CODE>

<LISTING>
     ARRAY data               +---+---+---+---+---+            TBLFLD
                       .----->|   |   |   |   |   |     |                  |
+--------+--------+    |      +---+---+---+---+---+     +------------------+
| cnt  5 | ptr o--+----'                             .--+--o     dataPtr   |
+--------+--------+            .--------------------'   |        ----------+
|      4 |     o--+----.       V                        / heap      .      /
+--------+--------+    |      +---+---+---+---+         /           :      /
|      2 |     o--+----|----->|   |   |   |   |         +------------------+
+--------+--------+    |      +---+---+---+---+         |                  |
                       `----->|   |   |   |   |
                              +---+---+---+---+
</LISTING>

<P>
For <SAMP>TBLFLD</SAMP> heap information to be considered valid,
<SAMP>SH_TBL_HEAP</SAMP> must be set in <SAMP>TBLFLD</SAMP>'s <CODE>Tpres</CODE>.
<SAMP>SH_TBL_HEAP</SAMP> does not necessarily indicate that the
<SAMP>TBLFLD</SAMP> owns the heap data, rather it indicates that
<SAMP>TBLFLD</SAMP>'s <CODE>heap</CODE> member contains valid information.
If <SAMP>SH_TBL_HEAP</SAMP> is not set and the <SAMP>ARRAY</SAMP> data type is
<SAMP>TBLHEAPDSC</SAMP>, the heap data should be considered of unknown type.

<P>
Heap data not owned by the <SAMP>TBLFLD</SAMP> should be freed prior to
deleting the field or Table
(<A HREF="shTbl.html#shTblfldDel"><B>shTblfldDel</B></A>,
<A HREF="shTbl.html#shTblcolDel"><B>shTblcolDel</B></A>, or
<A HREF="tclTbl.html#tblColDel"><B>tblColDel</B></A>);
otherwise, that memory may become "lost" (a memory leak).

<H3><A NAME="Accessing Heap Data">Accessing Heap Data</A></H3>

<P>
Heap data is accessed through the <SAMP>TBLFLD</SAMP>'s <CODE>array</CODE>
field, just as main <SAMP>ARRAY</SAMP> data.
But, the <SAMP>ARRAY</SAMP> describes a 1-dimensional array of heap descriptors,
<SAMP>TBLHEAPDSC</SAMP>
(<A HREF="#TBLHEAPDSC and TDIMn">see the NOTE above</A> about
why <SAMP>TBLHEAPDSC</SAMP>'s are limited to 1 dimension, namely the row index).
The use of the <SAMP>ARRAY</SAMP> indices will only reference the
<SAMP>TBLHEAPDSC</SAMP>.

<LISTING>
     #include "dervish_msg_c.h"
     #include "shCUtils.h"        /* For shInSet ()                          */
     #include "shCArray.h"
     #include "shCTbl.h"

     ARRAY        *array;         /* Field we're interested in               */
     TBLFLD       *tblFld;        /* Field we're interested in               */
           int     tblFldIdx;     /* Position (0-index) of field             */
           int     myHeapIdx;     /* Index (0-index) w/i variable len array  */
     TBLHEAPDSC   *myHeapDsc;     /* We know a priori that the ARRAY field   */
                                  /* is a 1-D array of heap descriptors; but */
                                  /* we don't know the dimensions.           */
     short int    *myField;       /* We know a priori that the heap data is  */
                                  /* a 1-D array of shorts;  but we don't    */
               .                  /* know the dimensions.                    */
               :
     if (shTblFldLoc (..., &amp;array, &amp;tblFld, &amp;tblFldIdx) == SH_SUCCESS)
        {
        myHeapDsc = ((TBLHEAPDSC *)array->arrayPtr);     /* Heap descriptors */
        myField   = ((short int  *)myHeapDsc[row]->ptr); /* Heap for a row   */
               .
               :
        ... myField[x] ...        /* x is between [0,myHeapDsc[row]->cnt)    */
               .
               :
        /*
         * If TBLFLD information is used, make sure that a TBLFLD is actually
         * present.  TBLFLDs are   N O T   required for Dervish Tables.
         *
         * NOTE: This code does NOT follow the FITS Standard.  TSCAL/TZERO are
         *       applied to heap data. The Standard indicates that TSCAL/TZERO
         *       are undefined for `P' data types (TBLHEAPDSC heap).
         */

        if (tblFld != ((TBLFLD *)0))
           {
           for (myHeapIdx = 0; myHeapIdx &lt; myHeapDsc->cnt; myHeapIdx++)
              {
              if (   (shInSet (tblFld->Tpres, SH_TBL_TSCAL)
                  &amp;&amp; (shInSet (tblFld->Tpres, SH_TBL_TZERO) )
                 {
                 ... ((myField[x] * tblFld->TSCAL) + tblFld->TZERO) ...
                 }
              }
           }
        }
</LISTING>

The use of <VAR>myField</VAR> as an intermediary can be omitted:

<LISTING>
     ... ((short int *)myHeapDsc[row]-ptr)[x] ...
</LISTING>

<!-- *********************************************************************** -->

<!-- *********************************************************************** -->

<H1><A NAME="Creating a Table">Creating and Filling a TBLCOL Table</A></H1>

<P>
Since not all applications will use a
<A HREF="#TBLCOL"><SAMP>TBLCOL</SAMP> Table</A> that was read in from
a FITS file, it's possible to create one from scratch and fill in the data.
The steps required are shown as an example in C.
Much of the work is done in a table-driven fashion.
Also, the label <CODE>rtn_return</CODE> is a convenient place to jump to
when something fails;  it prevents the need to clumsily nest testing to
such an extent that the code becomes unreadable.

<OL>
<LI>	Include the appropriate header files and declare any variables, etc.
	Data is structured to allow much of the code to be table-driven,
	with the field position being the major index.

<!-- *** ******* ******* ******* ******* ******* ******* ******* ** -->
<LISTING>
#include <string.h>             /* For strncpy ()                    */

#include "dervish_msg_c.h"
#include "shCSchema.h"          /* For shTypeGetFromName ()          */
#include "shCUtils.h"           /* For shAddSet ()                   */
#include "shCAlign.h"           /* For heap related work             */
#include "shCTbl.h"
#include "shCArray.h"
#include "shCHdr.h"             /* For shHdrXXX () routines          */

/*********************************************************************/
/*
 * Declarations.
 */

#define ROWCNT       10                 /* Number of rows            */
#define FLDCNT        3                 /* Number of fields          */
#define DIMCNTMAX     5                 /* Max number of dimensions  */

RET_CODE    status = SH_SUCCESS;
      int   fldIdx;
      int   rowIdx;
      int   dimIdx;
TBLCOL     *tblCol;
TBLFLD     *tblFld;
ARRAY      *array;
char        hdrKey[8 + 1];              /* For header keyword generat*/

#define     NULLSTR  ((char *)0)        /* For this example          */

/*
 * Describe Table fields.
 *
 *   fldSchema    Object schema type of the field (ARRAY data area).
 *
 *   heapSchema   Object schema type of the heap data (valid only when
 *                fldSchema is TBLHEAPDSC (heap descriptors)).
 *
 *   fldTTYPE     Optional "label" for the field.
 *
 *   dimCnt       Number of dimensions and the dimensions B E Y O N D
 *   dim          the first ARRAY dimension (the number of Table rows).
 */

char *fldSchema [FLDCNT] = {"INT",       "TBLHEAPDSC", "STR"   };
char *heapSchema[FLDCNT] = {NULLSTR,     "LOGICAL",     NULLSTR};
char *fldTTYPE  [FLDCNT] = {NULLSTR,     "Data Valid", "Name"  };
int   dimCnt    [FLDCNT] = {                2,     0,       2  };
int   dim       [FLDCNT][DIMCNTMAX] = {{ 2, 5 },  { }, { 5, 3 }};


      int  **fld0;              /* Pointer for filling 1st field     */
TBLHEAPDSC  *fld1;              /* Pointer for filling 2nd field     */
      char **fld2;              /* Pointer for filling 3rd field     */

/*
 * Object schema types.  This is done for performance.
 */

TYPE         schemaTypeTBLHEAPDSC = shTypeGetFromName ("TBLHEAPDSC");

/*********************************************************************/
</LISTING>
<!-- *** ******* ******* ******* ******* ******* ******* ******* ** -->

	The second field is explicitly declared as
	<A HREF="#Special Data Types"><SAMP>LOGICAL</SAMP></A>.
	This permits it to be written as a logical field in a FITS Binary
	Table (<SAMP>TFORM</SAMP>n's `<SAMP>L</SAMP>' data type).  Using
	a byte (or any integer type) instead would write the data out as
	a number.

<BR>_________________________________________________________________
<P>
<LI>	Create a skeleton <SAMP>TBLCOL</SAMP> Table:

<!-- *** ******* ******* ******* ******* ******* ******* ******* ** -->
<LISTING>
if ((status = shTblColCreate (ROWCNT, FLDCNT, 0, &amp;tblCol)) != SH_SUCCESS)
   {
   goto rtn_return;
   }
</LISTING>
<!-- *** ******* ******* ******* ******* ******* ******* ******* ** -->

	The skeleton contains the
	<A HREF="#TBLCOL"><SAMP>TBLCOL</SAMP> structure</A>
	heading the chain of
	<A HREF="dervish.array.html#ARRAY"><SAMP>ARRAY</SAMP>s</A>.
	Above, it was decided that
	<A HREF="shTbl.html#shTblColCreate"><B>shTblColCreate</B></A> would not
	allocate space for the optional
	<A HREF="#TBLFLD"><SAMP>TBLFLD</SAMP> structure</A>
	(this is done below through various routines).

<BR>_________________________________________________________________
<P>
<LI>	Insert any overall information into the
	<A HREF="#Headers">Dervish header</A> associated with
	the Table.  Keywords that would be
	<A HREF="#Forbidden Header Keywords">removed</A>
	if the Table were read in from a FITS file <EM>must not</EM> be
	inserted into the Dervish header (as they will only cause
	<A HREF="#Forbidden Header Keywords">confusion</A>
	and are
	<A HREF="shTblWrite.html#Headers">lost when writing the Table</A>
	to a FITS file).

<!-- *** ******* ******* ******* ******* ******* ******* ******* ** -->
<LISTING>
shHdrInsertAscii (&amp;tblCol->hdr, "AUTHOR", "Dervish", "Table creator");
</LISTING>
<!-- *** ******* ******* ******* ******* ******* ******* ******* ** -->

_________________________________________________________________
<P>
<LI>	For each field, perform some work to set up the <SAMP>ARRAY</SAMP>
	for later use.
	Table fields are located by position, rather than by name (as there
	are none yet);  still, the search-by-name arguments to
	<A HREF="shTbl.html#shTblFldLoc"><B>shTblFldLoc</B></A> must be legal
	(so an arbitrary case sensitivity criteria was chosen).

<!-- *** ******* ******* ******* ******* ******* ******* ******* ** -->
<LISTING>
for (fldIdx = 0; shTblFldLoc (tblCol, fldIdx, NULLSTR, 0, SH_CASE_SENSITIVE,
                     &amp;array, &amp;tblFld, ((int *)0) == SH_SUCCESS);
     fldIdx++)
   {
</LISTING>
<!-- *** ******* ******* ******* ******* ******* ******* ******* ** -->

	<OL>
	<LI>	Fill in the dimensions of the <SAMP>ARRAY</SAMP>s.

<!-- *** ******* ******* ******* ******* ******* ******* *** -->
<LISTING>
for (dimIdx = dimCnt[fldIdx]; dimIdx > 0; dimIdx--)
   {
   if (array->dimCnt >= (shArrayDimLim))
      {
      status = SH_NOT_SUPPORTED;       /* Too many dimensions */
      goto rtn_return;
      }
   array->dim[array->dimCnt++] = dim[fldIdx][dimIdx];
   }
</LISTING>
<!-- *** ******* ******* ******* ******* ******* ******* *** -->

	Since <B>shTblColCreate</B> already filled in the array dimension count
	as 1 (<CODE>array->dimCnt</CODE>) and set the first dimension to the
	number of rows in the Table (<CODE>ROWCNT</CODE>), the dimension count
	for each field is bumped up rather than set explicitly.

	<P>
	The loop setting dimensions for a particular field counts down.
	This is done to improve performance, since the iteration comparison
	is done against a constant rather than an array reference.  But, the
	setting of <CODE>array->dim</CODE> uses the more expensive means of
	referencing <CODE>array->dimCnt</CODE> each time;  this protects
	against any changes to <B>shTblColCreate</B> that might fill in more
	than just the first array dimension.

	<BR>___________________________________________________________
	<P>
	<LI>	Allocate space for the data and
		<A HREF="dervish.array.html#Hierarchy of Array Pointers">hierarchy of array pointers</A>.
		These will be linked up by
		<A HREF="shArray.html#shArrayDataAlloc"><B>shArrayDataAlloc</B></A>.

<!-- *** ******* ******* ******* ******* ******* ******* *** -->
<LISTING>
if ((status = shArrayDataAlloc (array, fldSchema[fldIdx]))
           != SH_SUCCESS)
   {
   goto rtn_return;
   }
</LISTING>
<!-- *** ******* ******* ******* ******* ******* ******* *** -->

	___________________________________________________________
	<P>
	<LI>	Handle variable length arrays in <A HREF="#Heap">heap</A>
		storage.
		<A HREF="shTbl.html#shTblFldHeapAlloc"><B>shTblFldHeapAlloc</B></A>
		requires that the <SAMP>ARRAY</SAMP> heap descriptors
		(<A HREF="#TBLHEAPDSC"><SAMP>TBLHEAPDSC</SAMP></A>)
		be initialized.  This example does not show that initialization.
		Space for the <SAMP>TBLFLD</SAMP> will be allocated and linked
		to the <SAMP>ARRAY</SAMP> by <B>shTblFldHeapAlloc</B>.

<!-- *** ******* ******* ******* ******* ******* ******* *** -->
<LISTING>
if (array->data.schemaType == schemaTypeTBLHEAPDSC)
   {
   ... initialize heap descriptors ...

   if ((status = shTblFldHeapAlloc (array, heapSchema[fldIdx], 0,
                          ((unsigned char **)0))) != SH_SUCCESS)
      {
      goto rtn_return;
      }
   }
</LISTING>
<!-- *** ******* ******* ******* ******* ******* ******* *** -->

	<P>
	<B>shTblFldHeapAlloc</B> will allocate a <SAMP>TBLFLD</SAMP> structure
	if the <SAMP>ARRAY</SAMP> does not have one (which it shouldn't, as
	<B>shTblColCreate</B> was instructed not to allocate
	<SAMP>TBLFLD</SAMP>s).

	<BR>___________________________________________________________
	<P>
	<LI>	Fill in any additional information in the optional
		<SAMP>TBLFLD</SAMP> structures.

<!-- *** ******* ******* ******* ******* ******* ******* *** -->
<LISTING>
if (fldTTYPE[fldIdx] != NULLSTR)
   {
   status = shTblTBLFLDsetWithAscii (array, SH_TBL_TTYPE,
               fldTTYPE[fldIdx], ((TBLFLD **)0));
   if ((status != SH_SUCCESS) &amp;&amp; (status != SH_TRUNC))
      {
      goto rtn_return;
      }
   }
</LISTING>
<!-- *** ******* ******* ******* ******* ******* ******* *** -->

		<P>
		<A HREF="shTbl.html#shTblTBLFLDsetWithAscii"><B>shTblTBLFLDsetWithAscii</B></A>
		will allocate a <SAMP>TBLFLD</SAMP> if necessary.
		The above example decided that truncation of the
		<SAMP>TBLFLD</SAMP> <CODE>TTYPE</CODE> member value
		(indicated by a <SAMP>SH_TRUNC</SAMP> return value)
		should not abort the Table creation.
	<BR>___________________________________________________________
	<P>
	<LI>	Insert any per-field information into the
		<A HREF="#Headers">Dervish header</A>.
		Keywords that would be
		<A HREF="#Forbidden Header Keywords">removed</A>
		if the Table were read in from a FITS file <EM>must not</EM> be
		inserted into the Dervish header (as they will only cause
		<A HREF="#Forbidden Header Keywords">confusion</A>
		and are
		<A HREF="shTblWrite.html#Headers">lost when writing the Table</A>
		to a FITS file).

<!-- *** ******* ******* ******* ******* ******* ******* *** -->
<LISTING>
sprintf (hdrKey, "TMINE%d", fldIdx + 1); /* Hdr key's 1-indexed */
shHdrInsertInt (&amp;tblCol->hdr, hdrKey, ..., "User-specific key");
</LISTING>
<!-- *** ******* ******* ******* ******* ******* ******* *** -->

		<A HREF="hdr.html#shHdrInsertInt"><B>shHdrInsertInt</B></A>
		was used to insert a user-specific keyword (non-FITS Standard)
		and its integer value into the Dervish header associated with
		the Table.
		The keyword name, generated with <B>sprintf</B>, is 1-indexed,
		where the
		<A HREF="dervish.fitsio.html#0-indexing vs. 1-indexing">keyword `index' is 1 greater</A>
		than the field position (which is 0-indexed).
		Users must be careful when adding or removing Table fields,
		since indexed keywords in the Dervish header are
		<A HREF="#Unknown Header Keywords"><EM>not</EM> adjusted</A>
		to reflect shifting Table fields.

	</OL>

_________________________________________________________________
<P>
<LI>	Peform any sanity checks.

<!-- *** ******* ******* ******* ******* ******* ******* ******* ** -->
<LISTING>
   }                    /* End of per-field for loop                 */

if (fldIdx != (FLDCNT)) /* Went through every expected Table field?  */
   {
   status = SH_INTERNAL_ERR;
   goto rtn_return;     /* Failed miserably somehow: internal error? */
   }
</LISTING>
<!-- *** ******* ******* ******* ******* ******* ******* ******* ** -->

_________________________________________________________________
<P>
<LI>	Fill in the data.
	There are a multitude of ways of filling in the data.
	Most require knowledge, at compilation time, of the C data type being
	filled (even with compilation-time knowledge, it is useful to double
	check the data type at run time (this is <EM>not</EM> shown in the
	example code below)).
	In the example here, each field is filled through the use of the
	<A HREF="dervish.array.html#Hierarchy of Array Pointers">hierarchy of array pointers</A>.
	The number of dimensions (including the Table row index) are known
	at compilation time.

<!-- *** ******* ******* ******* ******* ******* ******* ******* ** -->
<LISTING>
if (shTblFldLoc (tblCol, 0, NULLSTR, 0, SH_CASE_SENSITIVE,
                &amp;array, &amp;tblFld, ((int *)0)) != SH_SUCCESS)
   {
   goto rtn_return;             /* Field should be there, but ...?   */
   }
fld0 = array->arrayPtr;         /* Fill array using C notation       */
for (rowIdx = 0; rowIdx &lt; (array->dim[0]; rowIdx++)
   {
   for (dimIdx = 0; dimIdx &lt; (array->dim[1]; dimIdx++)  /* Only 2-D  */
      {
      fld0[rowIdx][dimIdx] = ...;
      }
   }
</LISTING>

	The second field, consisting of boolean values in heap, is filled
	with false (0) values explicitly as an example of how heap is accessed.
	Here, it's known that the <SAMP>ARRAY</SAMP> data area consists
	of a 1-dimensional array (indexed by the Table row number) of
	heap descriptors
	(<A HREF="#TBLHEAPDSC"><SAMP>TBLHEAPDSC</SAMP></A>).

<!-- *** ******* ******* ******* ******* ******* ******* ******* ** -->
<LISTING>
if (shTblFldLoc (tblCol, 1, NULLSTR, 0, SH_CASE_SENSITIVE,
                &amp;array, &amp;tblFld, ((int *)0)) != SH_SUCCESS)
   {
   goto rtn_return;             /* Field should be there, but ...?   */
   }
fld1 = array->arrayPtr;         /* Fill array using C notation       */
for (rowIdx = 0; rowIdx &lt; (array->dim[0]; rowIdx++)
   {
   for (dimIdx =  fld1[lcl_rowIdx].cnt; dimIdx > 0; dimIdx--)
      {
      ((LOGICAL *)fld1[lcl_rowIdx].ptr)[dimIdx] = 0;
      }
   }
</LISTING>
<!-- *** ******* ******* ******* ******* ******* ******* ******* ** -->

	The third field, consisting of character strings, is filled as
	elements of a 1-dimensional array of strings, rather than character by
	character in a 2-dimensional array.
	It is important to note that <B>strncpy</B> is limited by the field's
	final dimension (fastest varying index) <EM>less</EM> one (1).  That's
	because Tables
	<A HREF="#Special Data Types:STR">assume</A> that the
	last character of a string (an object schema type,
	<CODE>array->data.schemaType</CODE> of <SAMP>STR</SAMP>) is guaranteed
	space for a null terminator.
	That last character <EM>will</EM> be lost if the Table is
	<A HREF="shTblWrite.html#Writing to FITS">written out</A> to a FITS HDU.

<!-- *** ******* ******* ******* ******* ******* ******* ******* ** -->
<LISTING>
if (shTblFldLoc (tblCol, 2, NULLSTR, 0, SH_CASE_SENSITIVE,
                &amp;array, &amp;tblFld, ((int *)0)) != SH_SUCCESS)
   {
   goto rtn_return;             /* Field should be there, but ...?   */
   }
fld2 = array->arrayPtr;         /* Fill array using C notation       */
for (rowIdx = 0; rowIdx &lt; (array->dim[0]; rowIdx++)
   {
   strncpy (fld2[rowIdx], ..., array->dim[array->dimCnt-1] - 1);
   }
</LISTING>
<!-- *** ******* ******* ******* ******* ******* ******* ******* ** -->

_________________________________________________________________
<P>
<LI>	Use the <SAMP>TBLCOL</SAMP> Table.
	In this sub-example, a FITS Binary Table HDU is written.
	An <A HREF="dervish.dump.html#diskio">object schema</A> handle is first
	created so
	<A HREF="shFits.html#shFitsWrite"><B>shFitsWrite</B></A> can be used.
	<P>
	<B>NOTE:</B> For the sake of simplicity, an <EM>unsanctioned</EM> way
	of creating a handle is shown below.
	The sub-example is self-contained; the header file includes and
	variable declarations are out of place with respect to 	the rest
	of the example.  The sub-example is also incomplete.

<!-- *** ******* ******* ******* ******* ******* ******* ******* ** -->
<LISTING>
#include "shCSchema.h"          /* For shTypeGetFromName ()          */
#include "shTclHandle.h"        /* For HANDLE declaration            */
#include "shCFits.h"            /* For shFitsWrite (), ...           */

HANDLE           hand;          /* Handle to TBLCOL                  */
char            *fitsFile;      /* Init somewhere to a file spec     */

hand->ptr  = ((void *)tblCol);  /* This is not a sanctioned way of   */
hand->type = shTypeGetFromName ("TBLCOL");  /* ... creating a handle.*/

status = shFitsWrite (&amp;hand, fitsFile, DEF_NONE, f_hduBINTABLE,
                       SH_FITS_PDU_MINIMAL, 0, STANDARD);
</LISTING>
<!-- *** ******* ******* ******* ******* ******* ******* ******* ** -->

	To create a sanctioned handle,
	<A HREF="handle.html#shTclHandleNew"><B>shTclHandleNew</B></A> should
	be used. The handle address is obtained with
	<B>shTclHandleExprEval</B>, using the handle name as the search key.
	In case of errors, the private routine <B>p_shTclHandleDel</B> can
	be used to delete the handle, but <EM>not</EM> what the handle points
	to.

_________________________________________________________________
<P>
<LI>	Clean up by destroying the <SAMP>TBLCOL</SAMP> Table (here's where
	the statement label <CODE>rtn_return</CODE> appears).

<!-- *** ******* ******* ******* ******* ******* ******* ******* ** -->
<LISTING>
rtn_return : ;                          /* Error bailout label       */

shTblcolDel (tblCol);
</LISTING>
<!-- *** ******* ******* ******* ******* ******* ******* ******* ** -->

</OL>

<H2><A NAME="Keeping Tables FITS Compliant">Keeping Tables FITS Compliant</A></H2>

<P>
There are very few limitations placed on Tables when used in the Dervish
environment.
But, if a Table is to be written out as a FITS ASCII or Binary Table Header
and Data Unit (HDU), some restrictions need to be adhered to.

<UL>
<LI>	The object schema types of the data in the <SAMP>ARRAY</SAMP>, and
	in heap data (if any), must be those that map to supported
	<A HREF="shTblRead.html#Mapping Binary Data Types">Binary Table</A>
	and
	<A HREF="shTblRead.html#Mapping ASCII Data Types">ASCII Table</A>
	data types, depending on the Table type being written.
	The heap object schema type may not be <SAMP>TBLHEAPDSC</SAMP>, as the
	FITS Standard does not support array descriptors in the heap itself.
	Heap is not supported under ASCII Tables.
<P>
<LI>	For Binary Tables, the <SAMP>TBLHEAPDSC</SAMP> data type cannot be
	part of a multidimensional array.  And, the <SAMP>ARRAY</SAMP> member
	<CODE>nStar</CODE> <EM>must</EM> be zero.
	<P>
	<B>NOTE:</B><I>
	There may be some controversy as to what the FITS keyword
	<SAMP>TDIM</SAMP>n really means for variable length data (it should be
	noted that the FITS Binary Table Standard lists <SAMP>TDIM</SAMP>n
	as a convention for multidimensional arrays, not as part of the
	Standard).
	Under Dervish, the FITS <SAMP>TDIM</SAMP>n keyword is <EM>not</EM>
	supported with a Binary Table <SAMP>TFORM</SAMP>n data type of
	`<SAMP>P</SAMP>'.
	</I>
<P>
<LI>	For Binary Tables, the <SAMP>TBLHEAPDSC</SAMP> count (<CODE>cnt</CODE>)
	must be a positive value (0 or greater).
<P>
<LI>	Character strings (<SAMP>STR</SAMP> object schema type) must be
	null-terminated.
	In addition, when a Table is written to a FITS HDU, the last character
	is discarded, countering the Dervish FITS Table readers'
	<A HREF="shTblRead.html#Beyond the FITS Standard">addition of a
	character</A> used to guarantee null-termination.
	This behaviour is true for character strings contained in both the
	<SAMP>ARRAY</SAMP> data area and heap storage.
	<SAMP>TBLCOL</SAMP> Tables should be constructed with this character
	loss in mind.
<P>
<LI>	<SAMP>LOGICAL</SAMP> fields should only take on the value of zero (0)
	or one (1).  When written out to an ASCII Table, <SAMP>LOGICAL</SAMP>
	values are written out as a 1 digit integer.
	Integers values in a <SAMP>LOGICAL</SAMP> field that require more than
	one character to be represented will cause Table writing to abort.
<P>
<LI>	Do not insert <A HREF="#Headers">header keywords</A>
	that would normally be removed by the FITS Table reader (such as
	<SAMP>NAXIS</SAMP> or <SAMP>TFORM</SAMP>n).
	These keywords will not be used the the FITS Table writer and will
	only serve to confuse users, possibly providing information that is
	inconsistent with what is maintained by the Table structures.
<P>
<LI>	Avoid the use of header keywords that are indexed, where the index is
	meant to indicate a Table field (via a 1-indexed position).
	As mentioned, known indexed keyword, such as <SAMP>TTYPE</SAMP>n, are
	not used by the FITS Table writer;  they only serve to confuse users.
	But unknown keywords, for example <SAMP>TMINE</SAMP>n, will be retained
	by the FITS Table writer for use in the resulting FITS header.  These
	<A HREF="#Unknown Header Keywords">unknown keywords</A>
	can easily get out of step with their intended fields if fields are
	added, moved, or removed from the Table.
</UL>

<!-- *********************************************************************** -->

</BODY>

<HR>
<ADDRESS><A HREF="dervish.authors.html#Nicinski">Tom Nicinski</A></ADDRESS>

</HTML>
