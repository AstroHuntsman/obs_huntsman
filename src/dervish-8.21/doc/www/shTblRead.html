<HTML>
<HEAD>
<!-- *********************************************************************** -->
<!-- *++
<!-- * FACILITY:	Dervish
<!-- *			Documentation
<!-- *
<!-- * ABSTRACT:	FITS I/O.  Documentation for reading FITS Tables.
<!-- *
<!-- * ENVIRONMENT:	HTML (HyperText Markup Language).
<!-- *			shTblRead.html
<!-- *
<!-- * AUTHOR:		Tom Nicinski, Creation date:  22-Nov-1993
<!-- *--
<!-- *********************************************************************** -->

<TITLE>FITS Table Reading Under Dervish</TITLE>

<H1>FITS Table Reading Under Dervish</H1>

<P>
FITS <A HREF="dervish.fitsio.html#tblcol">ASCII and Binary Tables</A> are read into the
<A HREF="#Reading into TBLCOL">columnar</A> (<SAMP>TBLCOL</SAMP>) format.
The following interfaces are provided for reading in FITS files:
<DIR>
<LI>	<A HREF="shFits.html">ANSI C</A>
<LI>	<A HREF="tclFits.html">Tcl</A>
</DIR>

<H2><A NAME="TSCAL/TZERO">Adjustments to Numeric Data</A></H2>

<P>
As data is read from the FITS file, the scaling and zero adjustments
(<SAMP>TSCAL</SAMP>n and <SAMP>TZERO</SAMP>n keywords respectively)
are applied in <EM>particular instances</EM> only; for other cases, it is
<EM>up to the user application</EM> to apply scaling and zeroing, along with
any other adjustments appropriately.

<P>
<SAMP>TSCAL</SAMP>n and <SAMP>TZERO</SAMP>n are applied <EM>only</EM> for
Binary Tables when they are the appropriate value for flipping the
"signedness" of an integer data type.
This data type flipping follows an unwritten FITS <EM>convention</EM>
(it is not part of the FITS Standard).
Sign conversion is done when <SAMP>TSCAL</SAMP>n is 1 and

<UL>
<LI>	<SAMP>B</SAMP> with <SAMP>TZERO</SAMP>n of 128 --> <SAMP>H</SAMP>
<LI>	<SAMP>H</SAMP> with <SAMP>TZERO</SAMP>n of 128 --> <SAMP>B</SAMP>
<LI>	<SAMP>I</SAMP> with <SAMP>TZERO</SAMP>n of 32768 --> <SAMP>U</SAMP>
<LI>	<SAMP>U</SAMP> with <SAMP>TZERO</SAMP>n of 32768 --> <SAMP>I</SAMP>
<LI>	<SAMP>J</SAMP> with <SAMP>TZERO</SAMP>n of 2147483648 --> <SAMP>V</SAMP>
<LI>	<SAMP>V</SAMP> with <SAMP>TZERO</SAMP>n of 2147483648 --> <SAMP>J</SAMP>
</UL>

These <SAMP>TZERO</SAMP>s correspond to

<PRE>
          7-1            16-1                 32-1
   128 = 2      32768 = 2       2147483648 = 2
</PRE>

Note that the <SAMP>`H'</SAMP>, <SAMP>`U'</SAMP>, and <SAMP>`V'</SAMP>
Binary Table data types are
<A HREF="#Extension Binary Table Data Types">extensions</A> to the FITS
Standard.

<P>
For cases where the "signedness" of the data type is not flipped,
the user application must understand how values are read to some internal
format.
Some problems/questions arise if the FITS reader were to apply these
adjustments:

<UL>
<LI>	What should the "internal" representation be?
	Should a <SAMP>TFORM</SAMP>n of <SAMP>`I'</SAMP> be converted
	to a double float (since double will can represent all integeters
	representable by four byte integers), the scaling applied, the zeroing
	applied, and then converted back to a two byte integer?
<P>
<LI>	If converting from an intermediate float representation back to an
	integer, what rounding rules should be applied?
</UL>

<P>
Also, the <SAMP>TNULL</SAMP>n keyword value is read, but not applied to any
data.  No checks are made of incoming data against the values of keyword such as
<SAMP>DATAMAX</SAMP> or <SAMP>DATAMIN</SAMP> (which are, strictly, used only
for the Primary array or Random Groups).
Thus, not applying <SAMP>TNULL</SAMP>n to undefined values in a Binary Table
should not be noticed by the user.
But, this non-application of <SAMP>TNULL</SAMP>n to ASCII Table fields might
be noticed.  There, the character representation of a number may be invalid.
Yet, because the Dervish FITS reader converts ASCII Table numbers to their binary
representation, applying <SAMP>TNULL</SAMP>n does not make sense as it is an
arbitrary character string.

<H3><A NAME="Platform-specific Floating Point Values">Platform-specific Floating Point Values</A></H3>

<P>
The FITS Table reader does <EM>not</EM> convert between the FITS Standard
floating point format (IEEE) and the native machine's floating point number
representation.
This poses no problems when reading ASCII Tables.
But, for Binary Tables, if the platform on which the FITS Table reader runs
does not use the IEEE format, problems will occur.
Currently, the FITS Table reader does <EM>not</EM> convert from the IEEE
format to the native machine format.  It simply copies the IEEE values over
to the in-memory copy.

<H2><A NAME="Supported ASCII Table Data Types">Supported ASCII Table Data Types</A></H2>

<P>
ASCII Tables specify data types for the fields using the <SAMP>TFORM</SAMP>n
keyword.  In general, FORTRAN-77 syntax for <CODE>FORMAT</CODE> statements
is used.  The Dervish FITS reader supports the following data types:

<UL>
<LI>	<SAMP>A</SAMP><VAR>w</VAR> - character string
<LI>	<SAMP>I</SAMP><VAR>w</VAR> - integer (32-bit twos-complement)
<LI>	<SAMP>F</SAMP><VAR>w.d</VAR> - single precision floating point (IEEE 32-bit)
<LI>	<SAMP>E</SAMP><VAR>w.d</VAR> - single precision floating point (IEEE 32-bit)
<LI>	<SAMP>D</SAMP><VAR>w.d</VAR> - double precision floating point (IEEE 64-bit)
</UL>

where <VAR>w</VAR> is the width of the field and <VAR>d</VAR> indicates the
position of the decimal point.

<H3><A NAME="Mapping ASCII Data Types">Mapping ASCII Data Types</A></H3>

<P>
When an ASCII Table is read in, the <SAMP>TFORM</SAMP>n data type is converted
to an
<A HREF="dervish.dump.html#diskio">object schema</A> data type maintained in the
<A HREF="dervish.array.html#ARRAY"><SAMP>ARRAY</SAMP> structure's</A>
<SAMP>data.schemaType</SAMP> field (which describes the data type of the
<EM>in-memory</EM> copy of the data).
The ASCII data type is also implicitly mapped to one of the
<A HREF="#Supported Binary Table Data Types">Binary Table data types</A>.
This mapping allows an ASCII Table to be written out as a Binary Table.
The mapping from ASCII to Binary data types and object schema types is as
follows:

<UL>
<LI>	<SAMP>A  --&GT;  A  --&GT;  <A HREF="dervish.array.html#Data Type Conventions">STR</A></SAMP>
<LI>	<SAMP>I  --&GT;  J  --&GT;  INT</SAMP>
<LI>	<SAMP>F  --&GT;  E  --&GT;  FLOAT</SAMP>
<LI>	<SAMP>E  --&GT;  E  --&GT;  FLOAT</SAMP>
<LI>	<SAMP>D  --&GT;  D  --&GT;  DOUBLE</SAMP>
</UL>

<P>
No <A HREF="#TSCAL/TZERO">scaling or zeroing is applied</A>, nor is any
"signedness" conversion performed (as the <SAMP>`I'</SAMP> data type does not
have any implicit size for which appropriate <SAMP>TSCAL</SAMP>n and
<SAMP>TZERO</SAMP>n can be detected).

<H3>Input Processing of Fields</H3>

<P>
Although the <SAMP>TFORM</SAMP>n keyword uses a restricted FORTRAN-77
<SAMP>FORMAT</SAMP> specification to describe the field, FORTRAN style
input of the field is not necessarily followed.

<UL>
<LI>	<SAMP>A</SAMP> Fields
	<BR>
	All characters are significant, including trailing blanks.
<P>
<LI>	<SAMP>I</SAMP> Fields
	<BR>
	Blank characters in a field are <EM>not</EM> interpreted as zeros;
	all zeros, even trailing zeros, must be explicit
	(this is equivalent to specifying <SAMP>BLANK= 'NULL'</SAMP> in the
	FORTRAN-77 <SAMP>OPEN</SAMP> statement).
<P>
<LI>	<SAMP>F</SAMP>, <SAMP>E</SAMP>, and <SAMP>D</SAMP> Fields
	<BR>
	If an explicit decimal point is in the field, it overrides the
	decimal point position specification (the <VAR>d</VAR> in
	<SAMP>F</SAMP><VAR>w.d</VAR>) in the <SAMP>TFORM</SAMP>n.
	<P>
	If the field contains neither a decimal point nor an exponent, it is
	treated as a real number of <VAR>w</VAR> digits, in which the the
	rightmost <VAR>d</VAR> digits are to the right of the implicit
	decimal point, with leading zeros assumed, if necessary.
	Placement of the implicit decimal point is based on the last non-blank
	character in the field (trailing blanks do <EM>not</EM> count as
	positions to the right of the implicit decimal point).
	<P>
	Blank characters in a field are <EM>not</EM> interpreted as zeros;
	all zeros, even trailing zeros, must be explicit
	(this is equivalent to specifying <SAMP>BLANK= 'NULL'</SAMP> in the
	FORTRAN-77 <SAMP>OPEN</SAMP> statement).
	<P>
	<A HREF="#TABLE Extensions">Text of "NaN"</A>, or some derivative,
	indicates a Not-a-Number.
</UL>

<H3><A NAME="Overlapped Fields">Overlapped Fields</A></H3>

<P>
The FITS Standard allows ASCII Tables to have overlapped fields.
Under Dervish, though, when fields are read in, they are allocated their own
space for data.  Thus, overlapped fields will become disjoint upon being read.
The possibly expected behaviour of modifying one field with the intent of
updating an overlapped field will not occur.
<A HREF="shTblWrite.html#Limitations">Writing</A> of overlapped fields to a
FITS file will also not be handled as expected.

<H3>Things to Sort Out</H3>

<P>
<I>
<UL>
<LI>	What should be done if the decimal point specification, <VAR>d</VAR>,
	is too large relative to the overall field width, <VAR>w</VAR>?
</UL>
</I>

<H2><A NAME="TABLE Extensions">Extensions to the ASCII Table Standard</A></H2>

<P>
The reading of floating-point data recognizes "NaN" as a keyword for a
Not-a-Number (NaN).
Many forms of "NaN" are recognized: leading whitespace is ignored, the check
is case-insensitive, and any text after "NaN" is ignored.
The binary result in the <SAMP>TBLCOL</SAMP> is an IEEE floating-point quiet
(non-signalling) NaN.

<H2><A NAME="Supported Binary Table Data Types">Supported Binary Table Data Types</A></H2>

<P>
Binary Tables specify data types for the fields using the <SAMP>TFORM</SAMP>n
keyword.  The overall format is
<PRE>
     [<VAR>r</VAR>]<B>T</B>[<VAR>ignored</VAR>]
</PRE>
where optional items are surrounded by square brackets (<SAMP>[]</SAMP>).
The <VAR>r</VAR> specifies a element count.  If missing, it defaults to one (1).
It can be zero (0), indicating that the field in the record storage area of
the Binary Table HDU does not contain any data for that field.

<P>
The <B>T</B> specifies the data type.  The Dervish FITS Binary Table reader
supports the following data types:

<UL>
<LI>	<SAMP>L</SAMP> -	logical value (<SAMP>`T'</SAMP> or <SAMP>`F'</SAMP>)
<LI>	<SAMP>B</SAMP> -	unsigned 8-bit integer
<LI>	<SAMP>I</SAMP> -	16-bit twos-complement integer
<LI>	<SAMP>J</SAMP> -	32-bit twos-complement integer
<LI>	<SAMP>A</SAMP> -	character string (can be null-terminated)
<LI>	<SAMP>E</SAMP> -	single precision floating point (IEEE 32-bit)
<LI>	<SAMP>D</SAMP> -	double precision floating point (IEEE 64-bit)
<LI>	<SAMP>P</SAMP> -	variable length array descriptor
</UL>

The <SAMP>`P'</SAMP> data type may have optional information following the
<SAMP>`P'</SAMP> specifier.
<PRE>
     [<VAR>r</VAR>]<CODE>P</CODE>[<B>T</B>[(<VAR>maxElemCnt</VAR>)]]
</PRE>
The following character is taken as the data
type of the heap data.  It may be any of the supported Binary Table data types
except <SAMP>`P'</SAMP> itself. The optional maximum element count, as permitted
by a FITS Standard convention, is not used or checked by the Binary Table
reader.

<P>
<A NAME="Extension Binary Table Data Types">
Dervish
<A HREF="#BINTABLE Extensions">extends the FITS Binary Table Standard</A>
with the following data types:
</A>

<UL>
<LI>	<SAMP>H</SAMP> -	8-bit twos-complement integer
<LI>	<SAMP>U</SAMP> -	unsigned 16-bit integer
<LI>	<SAMP>V</SAMP> -	unsigned 32-bit integer
</UL>

The following data types are currently not supported:
<UL>
<LI>	<SAMP>X</SAMP> -	bit array
<LI>	<SAMP>C</SAMP> -	complex value: pair of IEEE 32-bit precision floating point values
<LI>	<SAMP>M</SAMP> -	complex value: pair of IEEE 64-bit precision floating point values
</UL>

<H3><A NAME="Mapping Binary Data Types">Mapping Binary Data Types</A></H3>

<P>
When a Binary Table is read in, the <SAMP>TFORM</SAMP>n data type is
converted to an
<A HREF="dervish.dump.html#diskio">object schema</A> data type maintained in the
<A HREF="dervish.array.html#ARRAY"><SAMP>ARRAY</SAMP> structure's</A>
<SAMP>data.schemaType</SAMP> field (which describes the data type of the
<EM>in-memory</EM> copy of the data).
There is also an implicit mapping to an
<A HREF="#Supported ASCII Table Data Types">ASCII data type</A>,
allowing a Binary Table to be written out as an ASCII Table.
The mapping from Binary to ASCII data types and object schema types is as
follows:

<UL>
<LI>	<SAMP>L  --&GT;  A  --&GT;  <A HREF="shTblAccess.html#LOGICAL">LOGICAL</A></SAMP>
<LI>	<SAMP>B  --&GT;  I  --&GT;  UCHAR</SAMP>
<LI>	<SAMP>I  --&GT;  I  --&GT;  SHORT</SAMP>
<LI>	<SAMP>J  --&GT;  I  --&GT;  INT</SAMP>
<LI>	<SAMP>A  --&GT;  A  --&GT;  <A HREF="dervish.array.html#Data Type Conventions">STR</A></SAMP>
<LI>	<SAMP>E  --&GT;  E  --&GT;  FLOAT</SAMP>
<LI>	<SAMP>D  --&GT;  D  --&GT;  DOUBLE</SAMP>
<LI>	<SAMP>P  --------&GT;  <A HREF="shTblAccess.html#TBLHEAPDSC">TBLHEAPDSC</A></SAMP>
<P>
<LI>	<SAMP>U  --&GT;  I  --&GT;  USHORT</SAMP>
<LI>	<SAMP>V  --&GT;  I  --&GT;  UINT</SAMP>
<LI>	<SAMP>W  --&GT;  I  --&GT;  SCHAR</SAMP>
</UL>

The following Binary data types are not mapped
<UL>
<LI>	<SAMP>X</SAMP> -	bit array
<LI>	<SAMP>C</SAMP> -	complex value: pair of IEEE 32-bit precision floating point values
<LI>	<SAMP>M</SAMP> -	complex value: pair of IEEE 64-bit precision floating point values
</UL>

<P>
<A HREF="#TSCAL/TZERO">Scaling and zeroing are applied</A> only when changing
the "signedness" of integer data.
When the <SAMP>TSCAL</SAMP>n and <SAMP>TZERO</SAMP>n values are proper, the
following sign conversions are done:

<UL>
<LI>	<SAMP>B  --&GT;  I  --&GT;  SCHAR</SAMP>
<LI>	<SAMP>I  --&GT;  I  --&GT;  USHORT</SAMP>
<LI>	<SAMP>J  --&GT;  I  --&GT;  UINT</SAMP>
<P>
<LI>	<SAMP>U  --&GT;  I  --&GT;  SHORT</SAMP>
<LI>	<SAMP>V  --&GT;  I  --&GT;  INT</SAMP>
<LI>	<SAMP>W  --&GT;  I  --&GT;  UCHAR</SAMP>
</UL>

<H2><A NAME="BINTABLE Extensions">Extensions to the Binary Table Standard</A></H2>

<P>
Additional data types are recognized that are not part of the FITS Binary Table
Standard.  These new data types are recognized even if the Primary HDU specified
<SAMP>SIMPLE=T</SAMP> (indicating that <EM>all</EM> HDUs in the FITS file comply
with the FITS Standard).
These extra data types are needed to address FITS' limitation of integer types
with respect to their signs.  The extension data types,
<A HREF="#Extension Binary Table Data Types"><SAMP>`U'</SAMP>, <SAMP>`V'</SAMP>, and <SAMP>`H'</SAMP></A>,
handle this deficiency.
This extension maintains FITS' rule, "once FITS, always FITS."  Older FITS files
will be read properly and reading new FITS files with any of these types should
fail under older readers.

<P>
Particular
<A HREF="#TSCAL/TZERO"><SAMP>TSCAL</SAMP>n and <SAMP>TZERO</SAMP>n</A> (set by
a FITS community convention) flip the "signedness" of the input data (and
data type).
This convention if also applied to heap data (if the heap data type is
appropriate), even though the FITS Standard indicates that for
<SAMP>`P'</SAMP> data types, <SAMP>TSCAL</SAMP>n and <SAMP>TZERO</SAMP>n are
not defined.

<H3><A NAME="Overlapped Heap Data">Overlapped Heap Data</A></H3>

<P>
The FITS Standard does <EM>not disallow</EM> Binary Table heap data to overlap.
Under Dervish, though, when heap data is read in, each variable length array
is allocated its own space for data.  Thus, overlapped data will become
disjoint upon being read.
The possibly expected behaviour of modifying one datum with the intent of
updating an overlapped datum will not occur.
<A HREF="shTblWrite.html#Limitations">Writing</A> of overlapped heap data to a
FITS file will also not be handled as expected.

<H2><A NAME="Headers">FITS/Dervish Headers</H2>

<P>
When an ASCII or Binary Table is read, the FITS header associated with that
Table is also read and retained.
Although the retained Dervish header appears to be a FITS header, it should not be
treated as such.  The <A HREF="hdr.html">Dervish header</A> will not contain
all the <A HREF="shTblAccess.html#Headers">original FITS header keywords</A>
and information (such as some comments, etc.).

<P>
Although Dervish headers are not FITS headers, Dervish does place restrictions on
the format of Dervish headers as those specified by the FITS header.
For example, the length of character string values is limited.
This allows Dervish headers to be readily converted to FITS headers, without
any information loss, when a Table is written out to a FITS file

<H3><A NAME="Keyword Adjustments">Adjustments to Keyword Values</A></H3>

<P>
Some FITS header keywords are adjusted when they are read:

<UL>
<LI>	<SAMP>TTYPE</SAMP>n, <SAMP>TNULL</SAMP>n (when it is a character string,
	such as in an ASCII Table), <SAMP>TUNIT</SAMP>n, and <SAMP>TDISP</SAMP>n
	have trailing blanks truncated when they are placed into
	<A HREF="shTblAccess.html#TBLFLD"><SAMP>TBLFLD</SAMP>'s</A> fields.
</UL>

<H3>Allocation of Dervish Header Space</H3>

<P>
Dervish header space is allocated automatically for certain object schemas:
<UL>
<LI>	<SAMP>TBLCOL</SAMP>
<LI>	<SAMP>REGION</SAMP>
<LI>	<SAMP>MASK</SAMP>
</UL>
Dervish header space for these object schemas is also automatically freed when the
handles are deleted.
For object schemas other than these, space for the Dervish header is allocated
automatically.
The user is responsible for deleting these Dervish headers when the objects with
which they're associated are deleted.

<H2><A NAME="Reading into TBLCOL">Reading a Table in TBLCOL Format</A></H2>

<P>
Using the columnar (<SAMP>TBLCOL</SAMP>) format allows immediate access to FITS
Tables from Dervish without the need for object schemas and handles to be defined.
The FITS Table reader, <A HREF="tclFits.html#fitsRead"><B>fitsRead</B></A>
/ <A HREF="shFits.html#shFitsRead"><B>shFitsRead</B></A>, will read into a
<SAMP>TBLCOL</SAMP> format when a
<A HREF="tclFits.html#TBLCOL Handles"><SAMP>TBLCOL</SAMP> Dervish handle</A>
is used.

<P>
In the <SAMP>TBLCOL</SAMP> format, the values from all rows for a field in the
Table are read into an <A HREF="dervish.array.html#intro"><SAMP>ARRAY</SAMP></A>.
These values are stored in the same form as described in the FITS Table header
(<SAMP>TFORM</SAMP>n keyword) with any conversions necessary for the machine
type.  For example, <SAMP>`I'</SAMP> data types are signed two byte integers
(for Binary Tables;  for ASCII Tables, <SAMP>`I'</SAMP> data types are the
natural integer size for the particular platform).
When stored into the array, the values are aligned on natural boundaries for
the particular machine type.
Besides describing Table fields,
<A HREF="dervish.array.html#intro"><SAMP>ARRAY</SAMP></A> object schemas also point
to the field's data and optional information
(<A HREF="shTblAccess.html#TBLFLD">TBLFLD</A> object schemas).

<P>
When the FITS Binary Table reader detects an empty field (the
<SAMP>TFORM</SAMP>n element count is zero (0)), the field <EM>is</EM> retained
in the Dervish Table.
Dimension information (in the <SAMP>ARRAY</SAMP>'s
<A HREF="dervish.array.html#ARRAY"><CODE>dimCnt</CODE> and <CODE>dim</CODE> members</A>)
will be present, but may not necessary indicate the absence of data.  Instead,
the <SAMP>ARRAY</SAMP> field's <CODE>arrayPtr</CODE> and
<CODE>data.dataPtr</CODE> will be null pointers.

<H3><A NAME="Beyond the FITS Standard">Beyond the FITS Standard</A></H3>

<P>
For the <SAMP>`A'</SAMP> data type (<SAMP>TFORM</SAMP>n keyword), an additional
character is allocated per character string (in case the field is
multidimensional) to permit all character strings to be null-terminated.
This extra character is
<A HREF="shTblWrite.html#STR Truncation"><EM>not</EM> output</A> when writing
a FITS file.

<P>
For the <SAMP>`L'</SAMP> data type (<SAMP>TFORM</SAMP>n keyword), the FITS
file value, a single character of <SAMP>`T'</SAMP> or <SAMP>`F'</SAMP>, is
converted to an unsigned byte value of 1 or 0 respectively.  This permits a
more `natural' conditional test in languages such as C.

<H3><A Name="Missing Out on FITS Features">Missing Out on FITS Features</A></H3>

<P>
The 
<CITE><A HREF="/edoc/fits/users_guide.ps">
A User's Guide for the Flexible Image Transport System (FITS)</A></CITE>
(Version 3.1, May 2, 1994) describes a feature that is <EM>not</EM>
supported:

<UL>
<LI>	The Binary Table substring array convention (<SAMP>SSTR</SAMP>) for the
	<SAMP>`A'</SAMP> data type (character string) is <EM>not</EM> supported.
	<SAMP>`A'</SAMP> strings are <EM>not</EM> burst into substrings and the
	<SAMP>SSTR</SAMP> information is lost.
	See Section 5.2.1,
	"Required Keywords for Binary Table Extension Headers," (page 59) and
	Section 5.2.6, "Arrays of Strings," (page 68) of the
	<CITE>User's Guide</CITE> for additional information on this convention.
</UL>

<H2>Reading Heap Data</H2>

<P>
Heap data is read from Binary Tables in a similar fashion as data from
the Record Storage Area (RSA) (the data that is read into the
<SAMP>ARRAY</SAMP>s).
There are some differences:

<UL>
<LI>	The heap descriptors read from the RSA are modified.  If the heap
	data contains character strings (<SAMP>`A'</SAMP> data type), the
	count is bumped up by one to provide space for a guaranteed
	null-terminator.  The heap offset is converted to an address in
	memory.  These changes result in the heap descriptor,
	<A HREF="shTblAccess.html#TBLHEAPDSC"><SAMP>TBLHEAPDSC</SAMP></A>,
	contained in the <SAMP>ARRAY</SAMP> data area.  This permits easy
	<A HREF="shTblAccess.html#Accessing Heap Data">access</A> to heap data.
<P>
<LI>	The <A HREF="shTblAccess.html#TBLHEAPDSC and TDIMn"><SAMP>TDIM</SAMP>n
	keyword describes the dimensions of the heap descriptors</A>,
	<EM>not</EM> the heap data.
	Furthurmore, heap descriptors are limited to 1 dimension in the
	<SAMP>ARRAY</SAMP> (the number of Table rows).
	Heap data <I>per se</I> (referenced through the heap descriptors)
	is also considered to be 1-dimensional, where the heap
	descriptor's <CODE>cnt</CODE> (count) member is the dimension of
	the variable length array (for the particular Table row and field).
<P>
<LI>	If the heap data type is unknown, the data is treated as if it were
	unsigned bytes (data type <SAMP>`B'</SAMP>).  But, the alignment
	between rows of heap data is maximized (the largest alignment known
	to Dervish for a primitive data type).
<P>
<LI>	The <SAMP>ARRAY</SAMP> describing a field contains heap descriptors
	(<A HREF="shTblAccess.html#TBLHEAPDSC"><SAMP>TBLHEAPDSC</SAMP></A>).
	The <A HREF="shTblAccess.html#TBLFLD"><SAMP>TBLFLD</SAMP></A> hung
	off the <SAMP>ARRAY</SAMP> is used to describe the heap data contents.
</UL>

<H2>Invalid Conditions and How They are Handled</H2>

<P>
Most conditions that form an invalid FITS file result in aborting the read of
the FITS file.
However, there are some conditions that are handled, since the ASCII and
Binary Table standards do not address them explicitly:

<UL>
<LI>	The row length computed from <SAMP>TFORM</SAMP>n's is longer than
	<SAMP>NAXIS1</SAMP>.
	<P>
	The reading of the Table is aborted.
	<P>
	<B>NOTE:</B><I>
	The FITS Binary Table standard does not mention overlapped fields.
	And, using precedents, the ASCII Tables extension does not permit
	fields to extend beyond <SAMP>NAXIS1</SAMP>
	(see
<CITE><A HREF="/edoc/fits/users_guide_vsn_3_1.ps">
A User's Guide for the Flexible Image Transport System (FITS)</A></CITE>
(Version 3.1, May 2, 1994),
	Section 3.4.3, "Data Records in an ASCII Tables Extension" (page 42)).
	</I>
</UL>

<P>
Some Binary Table specific invalid conditions and resulting actions are:

<UL>
<LI>	<SAMP>THEAP</SAMP> starts the heap area in the record storage area
	(RSA).
	<P>
	Data from the heap area will be read "normally."  
<P>
<LI>	<SAMP>TDIM</SAMP>n cannot be used along with a <SAMP>TFORM</SAMP>n
	data type of <SAMP>`P'</SAMP>.
	<P>
	Data reading is aborted.
	<P>
	<B>NOTE:</B><I>
	There may be some controversy as to what the FITS keyword
	<SAMP>TDIM</SAMP>n really means for variable length data
	(it should be noted that the FITS Binary Table Standard lists
	<SAMP>TDIM</SAMP>n as a convention for multidimensional arrays,
	not as part of the Standard).
	Because of this, Dervish does not support dimensioned variable length
	data.
	</I>
<P>
<LI>	Logical values for the <SAMP>TFORM</SAMP>n <SAMP>`L'</SAMP> data type
	are not <SAMP>`T'</SAMP> or <SAMP>`F'</SAMP> (or their lowercase
	equivalents).
	<P>
	Data reading is aborted.
</UL>

<!-- *********************************************************************** -->

</BODY>

<HR>
<ADDRESS><A HREF="dervish.authors.html#Nicinski">Tom Nicinski</A></ADDRESS>

</HTML>
