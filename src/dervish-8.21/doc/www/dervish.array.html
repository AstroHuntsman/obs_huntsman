<HTML>
<HEAD>

<TITLE>DERVISH Specific Arrays</TITLE>
<BODY>

<H1> DERVISH Specific Arrays </H1>

<H2>TCL API</H2>
<UL>
<LI><A HREF="tclArrays.html">Arrays</A>
</UL>

<H2>C Routine Interface</H2>
<UL>
<LI><A HREF="shArray.html">Arrays</A>
</UL>

<H2><A NAME="intro">Arrays under Dervish</A></H2>

<P>
<SAMP>ARRAY</SAMP>s are defined in the header file
<A HREF="../../include/shCArray.h"><EM>shCArray.h</EM></A>.
<P>
Dervish provides a general <SAMP>ARRAY</SAMP> type
<A HREF="dervish.dump.html#diskio">object schema</A> to permit the creation and
manipulation of <I>n</I>-dimensional arrays.
Besides storing array data, <SAMP>ARRAY</SAMP>s allow data to be accessed with
C array referencing notation <EM>without</EM> knowing array dimensions.
Row indices are in <I>row-major</I> order, where the rightmost (last) index
is the fastest varying index.

<H3><A NAME="ARRAY">ARRAY Structures/Object Schemas</A></H3>

<P>
For all arrays, information about the size of the array and where the data
is located is maintained in the <SAMP>ARRAY</SAMP>structure.
The following interfaces are provided to create and access <SAMP>ARRAY</SAMP>s:
<DIR>
<LI>	<A HREF="shArray.html">ANSI C</A>
<LI>	<A HREF="tclArray.html">Tcl</A>
</DIR>

<H4>ARRAY Fields</H4>

<P>
The <SAMP>ARRAY</SAMP> structure allows access to data in an array.
The data area is considered part of (owned by) an <SAMP>ARRAY</SAMP>,
especially when the <SAMP>ARRAY</SAMP> is deleted
(<A HREF="shArray.html#shArrayDel"><B>shArrayDel</B></A>), as the storage area
containing the data is also deleted.

<P>
The description below is from a C point of view, but its use can be easily
extended to Tcl and <A HREF="dervish.dump.html#diskio">object schemas</A>.
The C header file,
<A HREF="file:../../include/shCArray.h"><B>shCArray.h</B></A>,
contains the <SAMP>ARRAY</SAMP> declaration.

<PRE WIDTH="132">
+-----------+
| dimCnt    |		<I>Number of dimensions in the data.</I>
+-----------+---//---+
| dim       |   ...  |	<I>Array dimensions (in <I>row-major</I> order).</I>
+-----------+---//---+
| <A NAME="ARRAY:subArrCnt">subArrCnt</A> |   ...  |	<I>Element count in subarray based on</I>
+-----------+---//---+	<I><CODE>   </CODE>"depth."</I>
| <A NAME="ARRAY:arrayPtr">arrayPtr</A> o+-->	<I>Access to data.  <CODE>arrayPtr</CODE> is tree root</I>
+-----------+------+	<I>which allows <A HREF="dervish.array.html#Accessing Data">array referencing</A> without</I>
|       <A NAME="ARRAY:dataPtr">dataPtr</A>   o+-->	<I>knowing array bounds. <CODE>dataPtr</CODE> points to</I>
|       -----------+	<I>1st data element (all are contiguous).</I>
|       schemaType |	<I>Data <B>must</B> be <B>shMalloc</B>ed. <CODE>schemaType</CODE> is</I>
|       -----------+	<I><CODE>   </CODE> <B>makeio</B>'s type for the <CODE>data</CODE>.</I>
| data  size       |	<I>Size (bytes) of an object schema in the</I>
|       -----------+	<I><CODE>   </CODE> array.</I>
|       align      |	<I>Alignment factor of 1st object schema</I>
|       -----------+	<I><CODE>   </CODE> in the array.</I>
|       incr       |	<I>Address increment between object schemas</I>
+-----------+------+	<I><CODE>   </CODE> in the array.</I>
| nStar     |		<I>Amount of indirection <B>outside</B> the <SAMP>ARRAY</SAMP>.</I>
+-----------+
| info     o+-->	<I>Optional auxiliary information describing</I>
+-----------+		<I>the array data.  <CODE>infoType</CODE> is <B>makeio</B>'s</I>
| infoType  |		<I>type for the <CODE>info</CODE> structure.</I>
+-----------+
</PRE>

<P>
<SAMP>ARRAY</SAMP>s describe the dimensions of an array with
<CODE>dimCnt</CODE> (number of dimensions) and <CODE>dim</CODE> (the actual
dimensions).
<SAMP>ARRAY</SAMP>s are
<A HREF="dervish.array.html#Dimension Limit">limited to <B>34</B> dimensions</A>
(a Dervish compile-time limitation).  This should handle most needs, including
<A HREF="dervish.fitsio.html#tblcol">FITS Binary Tables</A>.
Dimensions (<CODE>dim</CODE>) are in <I>row-major</I> order, where the last
index varies fastest.  Indices are 0-indexed.

<P>
If available, <CODE>data.schemaType</CODE> describes the
<A HREF="dervish.dump.html#diskio">object schema</A> type of the <CODE>data</CODE>
(if it's not available, <CODE>data.schemaType</CODE> should be set to
the <SAMP>UNKNOWN</SAMP> object schema type).
<SAMP>ARRAY</SAMP>s do not restrict the user to primitive types of data.
Structures (object schemas) can also be stored within an <SAMP>ARRAY</SAMP>.
The <CODE>data</CODE> can also be additionally described with an optional
<CODE>info</CODE>rmation.
If available, the <CODE>infoType</CODE> field describes which object schema type
is pointed to by <CODE>info</CODE>.

<P>
<A NAME="nStar"><CODE>nStar</CODE></A> indicates the amount of indirection
<EM>outside</EM> the <SAMP>ARRAY</SAMP>.
<CODE>nStar</CODE> of zero (0) indicates that the data in the
<SAMP>ARRAY</SAMP> <CODE>data</CODE> area is of <CODE>data.schemaType</CODE>.
If <CODE>nStar</CODE> is one (1), it indicates that the <CODE>data</CODE> area
is an array of pointers to data of type <CODE>data.schemaType</CODE>.
In essence, <CODE>nStar</CODE> is the number of asterisks (<SAMP>*</SAMP>) in
a C declaration for a pointer.
For example, if <CODE>data.schemaType</CODE> is equivalent to
<SAMP>FLOAT</SAMP> and <CODE>nStar</CODE> is two (2), the <CODE>data</CODE>
area contains pointers to pointers to <SAMP>FLOAT</SAMP>s.
The pointers to the <SAMP>FLOAT</SAMP>s and the <SAMP>FLOAT</SAMP>s themselves
are outside the <SAMP>ARRAY</SAMP> and its <CODE>data</CODE> area.

<P>
If no data is available, no
<A HREF="dervish.array.html#Hierarchy of Array Pointers">hierarchy of array pointers</A>
is allocated, nor is any space for data allocated.
Both the <A HREF="dervish.array.html#ARRAY"><SAMP>ARRAY</SAMP></A> structure
members, <CODE>arrayPtr</CODE> and <CODE>data.dataPtr</CODE>, are set to point
to a zero (0) address (null).

<P>
<CODE>subArrCnt</CODE> contains the count of array elements at each "level"
within the array.
The array can be considered to be a tree, where the leaves are the array
elements.
The intermediate nodes form the
<A HREF="dervish.array.html#Hierarchy of Array Pointers">hierarchy of array pointers</A>.
This is where the concept of "levels" within the array comes from.
The sizes of subtrees at different depths within the array can be used
to <A HREF="dervish.array.html#Computing Array Element Locations">compute array element locations</A>.

<!-- *********************************************************************** -->

<!-- *********************************************************************** -->

<H4><A NAME="Data Type Conventions">Data Type Conventions</A></H4>

<P>
In general, object schema types are self explanatory.
But, there is one common data type that may seem to be used in an unconventional
manner, <SAMP>STR</SAMP>, the (null terminated) character string.
Consider an example where <CODE>nStar</CODE> is 0, that is, all data (the
character strings <EM>per se</EM>) are contained in the <SAMP>ARRAY</SAMP>
data area.  In that case, the fastest varying (rightmost) index of the dimension
is the number of characters in the string.

<P>
The intention is to indicate that the <SAMP>ARRAY</SAMP> is an array of
characters, not binary-valued bytes.
The use of the <SAMP>STR</SAMP> object schema type to describe the
<SAMP>ARRAY</SAMP> contents achieves this differentiation between
<SAMP>UCHAR</SAMP> and <SAMP>SCHAR</SAMP>, a numeric data type, and characters
themselves.
Still, because the <SAMP>ARRAY</SAMP> is still an array of characters, the
datum size and increment (<CODE>data.size</CODE> and <CODE>data.incr</CODE>
respectively) reflect the size of a <EM>single</EM> character and the spacing
between single characters, rather than the complete character string.
(The alignment, <CODE>data.align</CODE>, is the same for a single character and
a character string, so the user does not need to make any distinction there.)
<P>
Now consider an example where <CODE>nStar</CODE> is 1 and
<CODE>data.schemaType</CODE> is <SAMP>STR</SAMP>.
In this case, the <SAMP>ARRAY</SAMP> data area contains pointers to
character strings.
The datum size, <CODE>data.size</CODE> reflects the size of a pointer, not
of a character or character string.

<PRE WIDTH="132">
        <I>Realm of the <SAMP>ARRAY</SAMP> proper</I>
.--------------------------------------.
|  object schema            data area  |
     |                          |
     V      .                   V
|           :        |      +-------+  --. <I><CODE>dimCnt</CODE> &amp; <CODE>dim</CODE> control</I>
+-----------+--------+ .--->|       |    | <I>indexing to data area,</I>
| dimCnt    |          |    +-------+    | <I>but <B>not</B> the final data</I>
+-----------+---//---+ |    /   .   /    | <I>(such as a character</I>
| dim       |   ...  | |    /   :   /    | <I>from a string).</I>
+-----------+---//---+ |    +-------+  --'
| arrayPtr o+----------' .->|    o--+-.    <I><SAMP>ARRAY</SAMP> data area has</I>
+-----------+------+     |  +-------+ |    <I>pointers to <CODE>char</CODE>.</I>
|       dataPtr   o+-----'  | null  | |
|       -----------+        +-------+ |   +---+---+---+------+
| STR = schemaType |        /   .   / `-->| a | b | c | \000 |
|       -----------+        /   :   /     +---+---+---+------+
/           .      /        +-------+
/           :      /        |    o--+---.    +---+---+------+
+-----------+------+        +-------+    `-->| y | z | \000 |
| nStar = 1 |                                +---+---+------+
+-----------+                            |                    |
|     .     |                            `--------------------'
      :                          <I>Final data: the strings exist</I>
                                 <I>outside the <SAMP>ARRAY</SAMP> data area.</I>
</PRE>

<H3><A NAME="Accessing Data">Accessing Data</A></H3>

<P>
Data is accessed through the <CODE>arrayPtr</CODE> and <CODE>data</CODE>
fields of the <SAMP>ARRAY</SAMP> structure.
These two fields describe arbitrary <I>n</I>-dimensional arrays and allow
access to them.

<P>
The notation used throughout follows C's <EM>row-major</EM> ordering of array
elements, that is, the last subscript varies most rapidly.
The analogy to C arrays applies only to notation
(<A HREF="dervish.array.html#Notation Limitations">other limitations</A>
with respect to the notation also apply).
Since the <SAMP>ARRAY</SAMP> format is generic where array dimensions are not
known until run-time, arrays are stored in such a manner that regular C syntax
can be used to access these arrays without knowing their dimensions at
compilation-time (thus, they're not stored the same a C arrays).

<H4><A NAME="Hierarchy of Array Pointers">Hierarchy of Array Pointers</A></H4>

<P>
The C concept of an array name representing a pointer to the array is used to
accomplish this type of addressing.  For <I>n</I>-dimensional arrays, <I>n</I>
sets of pointers are used.  These array pointers are arranged in a hierarchical
fashion, with <I>n</I>-1 levels of pointers.  The <I>n</I>th level contains the
array data.
The top level (first set) of pointers are associated with the array name.
For a 1-dimensional array, there is only one pointer to the start of the data
itself.
For an <I>n</I>-dimensional array, the first set of pointers point to the
second set of pointers.  For a 2-dimensional array, this second set of
pointers point to the starts of data for 1-dimensional arrays.  Otherwise,
the second set of pointers (next to top level set) point to the third set
of pointers, and so forth.

<P>
Consider a general example of an an <I>n</I>-dimensional array with dimensions
(in <I>row-major</I> order)

<PRE WIDTH="132">
     (d , d , ..., d   )
       0   1        <I>n</I>-1
</PRE>

The hierarchy of array pointers would be linked as shown below.  The bottom
level contains the actual data.

<LISTING>
                                                                     level
                     +---+---+-//-+----+                             -----
                     |[0]|[1]| ...| d  |
                     |   |   |    |  0 |                               0
                     +-o-+-o-+-//-+-o--+
                       |   |        |
          .------------'            |
          V                         V
         +---+---+-//-+----+       +---+---+-//-+----+
         |[0]|[1]| ...| d  |  ...  |[0]|[1]| ...| d  |
         |   |   |    |  1 |       |   |   |    |  1 |                 1
         +-o-+-o-+-//-+-o--+       +-o-+-o-+-//-+-o--+
           |   |        |            |   |        |
           .                                      .                    .
           :                                      :                    :
    .--...-'                               .--...-'
    V                                      V
    +---+---+-//-+----+                   +---+---+-//-+----+
    |[0]|[1]| ...|d   |        ...        |[0]|[1]| ...|d   |        d
    |   |   |    | n-2|                   |   |   |    | n-2|         n-2
    +-o-+-o-+-//-+-o--+                   +-o-+-o-+-//-+-o--+
      |   |        |                        |   |        |
      |   |                                              |
 .----'   `-----------.                          .-------'
 V                    V                         V
+---+---+-//-+----+  +---+---+-//-+----+       +---+---+-//-+----+
|[0]|[1]| ...|d   |  |[0]|[1]| ...|d   |  ...  |[0]|[1]| ...|d   |   d
+---+---+-//-+-n-1+  +---+---+-//-+-n-1+       +---+---+-//-+-n-1+    n-1
</LISTING>

<H5><A NAME="Bouncing Down">Bouncing Down the Hierarchy of Array Pointers</A></H5>

<P>
It's possible to access array elements by "bouncing" down the
<A HREF="dervish.array.html#Hierarchy of Array Pointers">hierarchy of array pointers</A>.
The C code example below shows how this can be done.
<CODE>array</CODE> is a pointer to the <SAMP>ARRAY</SAMP>.
<CODE>idx</CODE> is an array of <EM>all</EM> indices.

<LISTING>
     /*
      * Bounce down the hierarchy of pointers to find the first element that
      * we're interested in.
      *
      *    o   It's assumed that unspecified (trailing) array indices were set
      *        to zero.
      */

          elemPtr = ((unsigned char *)array->arrayPtr;
     for (dimIdx  = 0; dimIdx &lt; (array->dimCnt - 1); dimIdx++)
        {
          elemPtr = ((unsigned char **)elemPtr)[idx[dimIdx]];
        }

     /*
      *   o   Apply the fastest changing (last) index.
      */

     elemPtr += (array->data.incr * idx[array->dimCnt-1]);
</LISTING>

<P>
Because of the <A HREF="dervish.array.html#Physical Layout">physical layout</A>
of <SAMP>ARRAY</SAMP> data, it's also possible to
<A HREF="dervish.array.html#Computing Array Element Locations">compute</A> the
location of an <SAMP>ARRAY</SAMP> element give a set of indices.

<H4>Describing Scalars and Arrays by Example</H4>

<P>
At a minimum, valid <SAMP>ARRAY</SAMP>s must be 1-dimensional.
The <I>n</I>-dimensional examples in subsequent sections show the user
declaring <CODE>myArray</CODE> in order to reference array data, but never
setting its value (pointing it off to data).
Consider the following example, in C, where <CODE>array</CODE> points to a
<SAMP>ARRAY</SAMP> structure:

<LISTING>
     #include "shCArray.h"

     short int   **myArray;       /* We know a priori this is a 2-D array    */
               .                  /* of shorts.                              */
               :
     myArray = ((short int **)array->arrayPtr);
               .
               :
     ... myArray[y][x] ...
</LISTING>

<CODE>array->arrayPtr</CODE> should be used to initialize
<CODE>myArray</CODE> in <EM>all</EM> cases.
<CODE>array->data.dataPtr</CODE>, the pointer to the first byte of data in the
array, should <EM>not</EM> be used.  If C's array referencing notation is to be
used, <CODE>array->data.dataPtr</CODE> will work properly only if the data is
1-dimensional.
<CODE>array->arrayPtr</CODE> will work for any <I>n</I>-dimensional array.

<H4>1-Dimensional Arrays</H4>

<P>
A 1-dimensional array of <I>i</I> elements is stored as follows:

<LISTING>
         +-------+     +-----+
myArray: |   o---|---->| [0] |
         +-------+     +-----+
                       | [1] |
                       +-----+
                       /  .  /
                       /  :  /
                       +-----+
                       |[i-1]|
                       +-----+
</LISTING>

where the C declaration

<LISTING>
     int     *myArray;		/* Ptr to (array of) int                     */
</LISTING>

will allow element <VAR>x</VAR> to be accessed with a C expression such as

<LISTING>
     ... myArray[x] ...
</LISTING>

<H4>2-Dimensional Arrays</H4>

<P>
A 2-dimensional array of <VAR>j</VAR> by <VAR>i</VAR> elements is stored as
follows:

<LISTING>
         +-------+     +-------+     +-----+-----+--//--+-----+
myArray: |   o---|---->|[0]  o-|---->| [0] | [1] |  ... |[i-1]|
         +-------+     +-------+     +-----+-----+--//--+-----+
                       |[1]  o-|--.
                       +-------+  |  +-----+-----+--//--+-----+
                       |   .   |  `->| [0] | [1] |  ... |[i-1]|
                       /   :   /     +-----+-----+--//--+-----+
                       |       |
                       +-------+     +-----+-----+--//--+-----+
                       |[j-1]o-|---->| [0] | [1] |  ... |[i-1]|
                       +-------+     +-----+-----+--//--+-----+
</LISTING>

where the C declaration
<LISTING>
     int    **myArray;		/* Ptr to ptr to (array of) int              */
</LISTING>

will allow element [<VAR>y</VAR>,<VAR>x</VAR>] to be accessed with a
C expression such as

<LISTING>
     ... myArray[y][x] ...
</LISTING>

If <CODE>myArray</CODE> were declared as <CODE>char **</CODE>, an array of
character strings, the above example will access one character from a
character string.  The whole string is referenced with

<LISTING>
     ... myArray[y] ...
</LISTING>

<H4>3-Dimensional Arrays</H4>

<P>
A 3-dimensional array of <VAR>k</VAR> by <VAR>j</VAR> by <VAR>i</VAR> elements
is stored as follows:

<LISTING>
                                      +-----+ +-----+        +-----+
                                   .->| [0] | | [0] |<-.  .->| [0] |
                                   |  +-----+ +-----+  |  |  +-----+
                                   |  | [1] | | [1] |  |  |  | [1] |
                                   |  +-----+ +-----+  |  |  +-----+
                                   |  /  .  / /  .  /  |  |  /  .  /
                                   |  /  :  / /  :  /  |  |  /  :  /
                                   |  +-----+ +-----+  |  |  +-----+
                                   |  |[i-1]| |[i-1]|  |  |  |[i-1]|
                                   |  +-----+ +-----+  |  |  +-----+
         +-------+     +-------+   `-------.       .---'  `-------.
myArray: |   o---|---->|[0]  o-|---        |       |              |
         +-------+     +-------+     +-----|-+-----|-+--//--+-----|-+
                       |[1]  o-|---->|[0]  o |[1]  o |  ... |[j-1]o |
                       +-------+     +-------+-------+--//--+-------+
                       |   .   |
                       /   :   /     +-------+-------+--//--+-------+
                       |       |  .->|[0]  o |[1]  o |  ... |[j-1]o |
                       +-------+  |  +-----|-+-----|-+--//--+-----|-+
                       |[k-1]o-|--'        |       |              |
                       +-------+           V       V              V
                                      +-----+ +-----+        +-----+
                                      | [0] | | [0] |        | [0] |
                                      +-----+ +-----+        +-----+
                                      | [1] | | [1] |        | [1] |
                                      +-----+ +-----+        +-----+
                                      /  .  / /  .  /        /  .  /
                                      /  :  / /  :  /        /  :  /
                                      +-----+ +-----+        +-----+
                                      |[i-1]| |[i-1]|        |[i-1]|
                                      +-----+ +-----+        +-----+
</LISTING>

where the C declaration
<LISTING>
     int   ***myArray;		/* Ptr to ptr to ptr to (array of) int       */
</LISTING>
will allow element [<VAR>z</VAR>,<VAR>y</VAR>,<VAR>x</VAR>] to be accessed with
a C expression such as
<LISTING>
     ... myArray[z][y][x] ...
</LISTING>

<H4>4-Dimensional Arrays</H4>

<P>
A 4-dimensional array of <VAR>m</VAR> by <VAR>k</VAR> by <VAR>j</VAR> by
<VAR>i</VAR> elements is stored as follows:

<LISTING>
   +-----+--//--+-----+                                    +-----+--//--+-----+
   | [0] |  ... |[i-1]|<-.  +-------+        +-------+  .->| [0] |  ... |[i-1]|
   +-----+--//--+-----+   `-|-o  [0]|<-.  .->|[0]  o-|-'   +-----+--//--+-----+
                            +-------+  |  |  +-------+
   +-----+--//--+-----+   .-|-o  [1]|  |  |  |[1]  o-|-.   +-----+--//--+-----+
   | [0] |  ... |[i-1]|<-'  +-------+  |  |  +-------+  `->| [0] |  ... |[i-1]|
   +-----+--//--+-----+     /   .   /  |  |  /   .   /     +-----+--//--+-----+
                            /   :   /  |  |  /   :   /
   +-----+--//--+-----+     +-------+  |  |  +-------+     +-----+--//--+-----+
   | [0] |  ... |[i-1]|<----|-o[j-1]|  |  |  |[j-1]o-|---->| [0] |  ... |[i-1]|
   +-----+--//--+-----+     +-------+  |  |  +-------+     +-----+--//--+-----+
                                       |  `---------------.
         +-------+     +-------+       `---.              |
myArray: |   o---|---->|[0]  o-|---        |              |
         +-------+     +-------+     +-----|-+--//--+-----|-+
                       |[1]  o-|---->|[0]  o |  ... |[k-1]o |
                       +-------+     +-------+--//--+-------+
                       |   .   |
                       /   :   /     +-------+--//--+-------+
                       |       |  .->|[0]  o |  ... |[k-1]o |
                       +-------+  |  +-----|-+--//--+-----|-+
                       |[m-1]o-|--'        |              |
                       +-------+       .---'              |
                                       |  .---------------'
   +-----+--//--+-----+                |  |                +-----+--//--+-----+
   | [0] |  ... |[i-1]|<-.  +-------+  |  |  +-------+  .->| [0] |  ... |[i-1]|
   +-----+--//--+-----+   `-|-o  [0]|<-'  `->|[0]  o-|-'   +-----+--//--+-----+
                            +-------+        +-------+
   +-----+--//--+-----+   .-|-o  [1]|        |[1]  o-|-.   +-----+--//--+-----+
   | [0] |  ... |[i-1]|<-'  +-------+        +-------+  `->| [0] |  ... |[i-1]|
   +-----+--//--+-----+     /   .   /        /   .   /     +-----+--//--+-----+
                            /   :   /        /   :   /
   +-----+--//--+-----+     +-------+        +-------+     +-----+--//--+-----+
   | [0] |  ... |[i-1]|<----|-o[j-1]|        |[j-1]o-|---->| [0] |  ... |[i-1]|
   +-----+--//--+-----+     +-------+        +-------+     +-----+--//--+-----+
</LISTING>

where the C declaration
<LISTING>
     int  ****myArray;		/* Ptr to ptr to ptr to ptr to (array of) int*/
</LISTING>
will allow element [<VAR>t</VAR>,<VAR>z</VAR>,<VAR>y</VAR>,<VAR>x</VAR>] to be
accessed with a C expression such as
<LISTING>
     ... myArray[t][z][y][x] ...
</LISTING>

<H4><A NAME="Notation Limitations">Limitations in Using the C Array Notation</A></H4>

<P>
As mentioned above, the C notation for accessing arrays used here only reflects
the access of data, not the layout of data in memory.  This notation has some
other restrictions that apply:

<UL>
<LI>	Declaring arrays as pointers to pointers ... to pointers to (an array)
	of a type does not permit any array bounds checking.
<P>
<LI>	The C array reference notation can only be used to access a single
	element with all indices, or to access the innermost array (the one
	whose index changes the fastest).  Consider:

	<LISTING>
     int   ****myArray;             /* 4-D array of size [m][k][j][i] */

     ... myArray[t][z][y][x] ...    /* Access one element             */
     ... myArray[t][z][y]    ...    /* Access an array (1-dimensional)*/
     ... myArray[t][z]       ...    /* Access an array of pointers    */
	</LISTING>

	The first two array references behave as expected.
	But, the last array reference will not properly provide the address of a
	2-dimensional array, as expected in regular C code.  Instead, it will
	return the address of an array of pointers.
<P>
<LI>	Structures are a bit more difficult to reference easily with the C array
	notation.
	These data types consist of two or more datums for each element in the
	array.
	Consider a pair of IEEE 32-bit precision floating point numbers that
	make up a complex complex value.  To access such a value, in a
	4-dimensional array, the C declaration would be

	<LISTING>
     typedef struct
        {
        float           realPart;   /* Real      portion of complex # */
        float           imagPart;   /* Imaginary portion of complex # */
        } COMPLEXVAL;

     COMPLEXVAL ****myArray;        /* 4-D array of size [m][k][j][i] */
	</LISTING>

	This style of declaration will allow element
	[<VAR>t</VAR>,<VAR>z</VAR>,<VAR>y</VAR>,<VAR>x</VAR>] to be accessed
	with a C expression such as

	<LISTING>
     ... myArray[t][z][y][x].realPart ...
	</LISTING>
</UL>

<H4><A NAME="Dimension Limit">Limiting the Number of Dimensions</A></H4>

<P>
The maximum number of <SAMP>ARRAY</SAMP> dimensions is limited to <B>34</B>.
This value should be large enough for most applications.  The value was
chosen based on the practical number of dimensions that a
<A HREF="dervish.fitsio.html#tblcol">FITS Binary Table</A> could support.
Because of the FITS header line size (80 bytes) and the format of the
<SAMP>TDIM</SAMP>n keyword, FITS is practically limited to
<STRONG>33</STRONG> dimensions.  The additional dimension permits the slowest
varying (first) index to reference the Table row.

<H4><A NAME="Physical Layout">Physical Layout of Array Data in Memory</A></H4>

<P>
Now that the <A HREF="dervish.array.html#Notation Limitations">limitations</A>
in using the C array notation have been described, they can be relaxed a bit.
Data is stored in a C fashion (row-major) with the fastest varying indexed
elements being stored adjacent to each other, then the next fastest varying
indexed array is stored, etc.
Consider an example of a 3-dimensional array of <VAR>k</VAR> by <VAR>j</VAR> by
<VAR>i</VAR> elements (addresses increase left to right and top to bottom):

<LISTING>
    k        .-- j-index [0] ---.-- j-index [1] ---.      .-- j-index [j-1] -.
  index       |                  |                  |      |                  |
    |         V                  V                  V      V                  V
    V   .-->  +-----+--//--+-----+-----+--//--+-----+--//--+-----+--//--+-----+
   [0]  |     | [0] |  ... |[i-1]| [0] |  ... |[i-1]|  ... | [0] |  ... |[i-1]|
        +-->  +-----+--//--+-----+-----+--//--+-----+--//--+-----+--//--+-----+
   [1]  |     | [0] |  ... |[i-1]| [0] |  ... |[i-1]|  ... | [0] |  ... |[i-1]|
        +-->  +-----+--//--+-----+-----+--//--+-----+--//--+-----+--//--+-----+
    .         /                                  .                            /
    :         /                                  :                            /
        +-->  +-----+--//--+-----+-----+--//--+-----+--//--+-----+--//--+-----+
  [k-1] |     | [0] |  ... |[i-1]| [0] |  ... |[i-1]|  ... | [0] |  ... |[i-1]|
        `-->  +-----+--//--+-----+-----+--//--+-----+--//--+-----+--//--+-----+
</LISTING>

If the 3-dimensional array size is known at compilation time, for example
consider a function argument formally declared as

<LISTING>
     int  myArray[][j][i];	/* 3-dimensional array w/ unknown dimension  */
</LISTING>

then the normal C array referencing notation can also be used

<LISTING>
     ... myArray[z][y][x] ...
</LISTING>

Notice that the slowest varying dimension does not need to be known at
compilation (as the slowest varying index can be left unspecified in C).
If the source was compiled with array bounds checking, the <VAR>j</VAR> and
<VAR>i</VAR> bounds will be checked, but the unknown dimension index will not be
checked.

<H5><A NAME="Computing Array Element Locations">Computing Array Element Locations</A></H5>

<P>
Rather than <A HREF="dervish.array.html#Bouncing Down">bouncing down</A> the
<A HREF="dervish.array.html#Hierarchy of Array Pointers">hierarchy of array pointers</A>,
it is possible to compute the location of an array element, given its indices
(0-indexed for this description).
<A HREF="dervish.array.html#ARRAY"><SAMP>ARRAY</SAMP>'s</A> <CODE>subArrCnt</CODE>
contains the count of array elements at each "level" within the array.
There are <CODE>dimCnt</CODE> valid elements in <CODE>subArrCnt</CODE> (just
as for <CODE>dim</CODE>).

<P>
The level (0-indexed) refers to the depth within the hierarchy of array
pointers, where level <I>n</I>-1 contains the leaves, namely the array data
itself.
The level also refers to the number of array indices provided, less 1.
Consider a 3-dimensional array with dimensions (2, 3, 2) (in <I>row-major</I>
order):

<PRE WIDTH="132">
     level
     -----
      -1            ___.___
                   /       \
                  /         \
       0        _0_         _1_  <-----+- <I>slowest varying indices</I>
               /   \       /   \       |
              /     \     /     \      |  <I>hierarchy of array</I>
       1     0---1---2   0---1---2     |  <I>pointers (</I><A HREF="dervish.array.html#ARRAY:arrayPtr">arrayPtr</A><I>)</I>
            /_\ /_\ /_\ /_\ /_\ /_\    |
            0 1 0 1 0 1 0 1 0 1 0 1  <-+- <I>fastest varying indices</I>
           +-+-+-+-+-+-+-+-+-+-+-+-+ --.
       2   | | | | | | | | | | | | |   |  <I>data (</I><A HREF="dervish.array.html#ARRAY:dataPtr"><CODE>data.dataPtr</CODE></A><I>)</I>
           +-+-+-+-+-+-+-+-+-+-+-+-+ --'
</PRE>

At level <VAR>l</VAR> (0 &lt;= <VAR>l</VAR> &lt; <CODE>dimCnt</CODE>),
there are <CODE>dim[<VAR>i</VAR>]</CODE> subarrays.
In the above example, at level 0, there are two subarrays.
If one index is provided, it explicitly refers to only one subarray at level 0
(as the index references only the slowest varying index).
Passing two indices references only one of six subarrays at level 1.
Passing three indices references only one of 12 array elements at level 2.
Level -1 does not exist in <SAMP>ARRAY</SAMP>'s <CODE>subArrCnt</CODE>.
But, providing no indices to reference an entire array is equivalent to
accessing a subarray at level -1.

<P>
For an <I>n</I>-dimensional array with dimensions (in <I>row-major</I> order)

<PRE WIDTH="132">
     (d , d , ..., d   )
       0   1        <I>n</I>-1
</PRE>

each subarray size as an array element count, <VAR>a</VAR>,
at level <VAR>l</VAR> (0 &lt;= <VAR>l</VAR> &lt; <I>n</I>-1) is

<PRE WIDTH="132">
          ____<I>n</I>-1
           ||
     a  =  ||    d
      <VAR>l </VAR>    ||     <VAR>j</VAR>
              <VAR>j</VAR>=<VAR>l</VAR>+1
</PRE>

By definition,

<PRE WIDTH="132">
     a  =  1
      <I>n</I>-1
</PRE>

<P>
Because array elements are
<A HREF="dervish.array.html#Physical Layout">layed out</A> sequentially, the array
may be treated 1-dimensionally.
Given a set of <I>n</I> indices, <VAR>x</VAR>, into the <I>n</I>-dimensional
array

<PRE WIDTH="132">
     (x , x , ..., x   )
       0   1        <I>n</I>-1
</PRE>

a 1-dimensional index, <VAR>i</VAR>, can be computed

<PRE WIDTH="132">
                <I>n</I>-2
            .---.
      x   +  \     a * x
       <I>n</I>-1   /      <VAR>k</VAR>   <VAR>k</VAR>
            '---'
                <VAR>k</VAR>=0
</PRE>

If fewer than <I>n</I> indices were passed for <VAR>x</VAR>, the remaining
indices should be treated as zeros (as it's 0-indexed) to locate the starting
array element of a subarray.  The above expression degenerates by changing
the upper bound on the sum to the number of passed indices, <VAR>j</VAR>,
less 1 and dropping the initial addend:

<PRE WIDTH="132">
                <I>j</I>-1
            .---.
             \     a * x
             /      <VAR>k</VAR>   <VAR>k</VAR>
            '---'
                <VAR>k</VAR>=0
</PRE>

In either case, multiplying <VAR>i</VAR> by <CODE>data.incr</CODE> results with
the array offset (from <CODE>data.dataPtr</CODE>) for the element or subarray
(respectively) indexed by <VAR>x</VAR>.

<P>
These computations can be done using
<A HREF="dervish.array.html#ARRAY:subArrCnt"><CODE>subArrCnt</CODE></A>.
For example, the following C code returns <CODE>elemOff</CODE>, the 0-indexed
offset (expressed in array element units) to the start of the referenced
subarray.
<CODE>idxCnt</CODE> is the number of indices (in array <CODE>idx</CODE>) passed
by the caller (which <EM>must</EM> be less than the number of array dimensions)
and <CODE>array</CODE> points to the desired <SAMP>ARRAY</SAMP>:

<LISTING>
     if (idxCnt == array->dimCnt) { elemOff = idx[idxCnt-1]; dimIdx = idxCnt - 2; }
                            else  { elemOff =            0;  dimIdx = idxCnt - 1; }
     for ( ; dimIdx >= 0; dimIdx--)
        {
        elemOff += (array->subArrCnt[dimIdx] * idx[dimIdx]);
        }
</LISTING>

<P>
The number of elements within a subarray, <CODE>subArrSize</CODE>, referenced
by <CODE>idxCnt</CODE> indices can be gotten with:

<LISTING>
     subArrSize = (idxCnt > 0) ? array->subArrCnt[idxCnt-1]
                               : array->subArrCnt[0] * array->dim[0];
</LISTING>

Specific handling for the case where no indices are passed is needed, as
level -1 does not exist.

<P>
Given a 0-indexed 1-dimensional offset, <CODE>elemOff</CODE>, into an
<I>n</I>-dimensional array, the corresponding <I>n</I> <VAR>indices</VAR> can
be computed.
Using <CODE>subArrCnt</CODE>, the following C code illustrates how this can
be accomplished:

<LISTING>
     elemIdx = elemOff;
     for (dimIdx = 0; dimIdx &lt; (array->dimCnt - 1); dimIdx++)
        {
        indices[dimIdx] = elemIdx /  array->subArrCnt[dimIdx];
                          elemIdx %= array->subArrCnt[dimIdx];
        }
        indices[dimIdx] = elemIdx;      /* Use final remainder       */
</LISTING>

All variables are signed integers.

<P>
As mentioned <A HREF="dervish.array.html#Data Type Conventions">before</A>,
<SAMP>STR</SAMP> object schema types are handled somewhat unusually.
For <SAMP>STR</SAMP>s, the subarray count represents the total number
of characters (including null terminators) in the subarray rather than the
number of character strings.

<!-- *********************************************************************** -->

<!-- *********************************************************************** -->

<H4><A NAME="Memory Use">Memory Use</A></H4>

<P>
For an <I>n</I>-dimensional array with dimensions (in <I>row-major</I> order)

<PRE WIDTH="132">
     (d , d , ..., d   )
       0   1        <I>n</I>-1
</PRE>

the number of pointers used in the
<A HREF="dervish.array.html#Hierarchy of Array Pointers">hierarchy of array pointers</A>
is

<PRE WIDTH="132">
         <I>n</I>-2
     .---.  ____ <VAR>j</VAR>
      \      ||    d
      /      ||     <VAR>i</VAR>
     '---'      <VAR>i</VAR>=0
         <VAR>j</VAR>=0
</PRE>

The number of data elements is

<PRE WIDTH="132">
            ____<I>n</I>-1
             ||
             ||    d
             ||     <VAR>i</VAR>
                <VAR>i</VAR>=0
</PRE>

<P>
As mentioned <A HREF="dervish.array.html#Data Type Conventions">before</A>,
<SAMP>STR</SAMP> object schema types are handled somewhat unusually.
For <SAMP>STR</SAMP>s, the data element count represents the total number
of characters (including null terminators) in the array rather than the
number of character strings.

<!-- *********************************************************************** -->

</BODY>

<HR>
<ADDRESS><A HREF="dervish.authors.html#Nicinski">Tom Nicinski</A></ADDRESS>

</HTML>
