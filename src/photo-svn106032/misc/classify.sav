Dump, Mon Jun 10 12:23:37 1996

Variables:

UNK	0
CR	1
DEFECT	2
GALAXY	3
GHOST	4
KNOWNOBJ	5
STAR	6
TRAIL	7
SKY	8
delta	1
file_type	fits
history_file	.smhist~
id	40
k	0.5959560691
m	10.3341405
nlab	40
noclobber	1
overload	1
prompt2	+
rhl_val	1.05
s	0.01441486216
save_file	sm.sav
save_read_ptr	1
t	10.11887936
table_type	bintable
temp_dir	/tmp/
traceback	1
var	0.3287514114
x_col	.
y_col	.
Vectors:

types : dimension = 10.s
help = Names of numerical object types
unknown
star
deV
exp
exp+deV
galaxy
fuzz
blend
sky
knownobj
ctypes : dimension = 10.s
help = colors for types
default
green
red
blue
magenta
magenta
default
default
default
default

Macros:

asinh10    1	# like asinh, but ~ lg for large I
		set $0 = ($1 >= 0) ? \
		  lg(($1 + sqrt(4 + $1**2))/2) : -lg((-$1 + sqrt(4 + $1**2))/2)
		#
asinh	11	set $0 = ($1 >= 0) ? \
		    ln($1 + sqrt(1 + $1**2)) : -ln(-$1 + sqrt(1 + $1**2))
delta      02	# Usage: delta [UQ] [condition]
		if(!$?1) { define 1 0 }
		
		set _l local
		if($?2) {
		   set _l = ($2)          # before we make star_L$3 etc. local
		} else {
		   define 2 _l set _l=1+0*exp_L$3
		}

		define v local  define i local
		define y_gutter local define y_gutter 0.8
		define ptype local define ptype |
		set pt local  set pt=(type == 'exp') ? 41 : 60   ptype pt
		set vecs local
		set vecs = $1 ? {re I U Q} : {re I arat phi}
		foreach v vecs {
		   set d$v = $v - $v""0
		}

		foreach v vecs {
		   set_window 2 2
		   lim ind (0 concat d$v) box
		   ptype pt poi ind d$v if(_l)
		   rel -1000 0 draw 1000 0
		   yla \Delta $(HELP($v))
		   xla \2$(HELP(ind))
		}
		window 1 1 1 1 
		ptype $ptype
		#
dlabel    	# label a delta plot
		toplabel \raise-1000\
		\phi_0 = $(sprintf('%.1f',phi0)) \
		re_0 = $(sprintf('%.2f',re0))  \
		arat_0 = $(sprintf('%.2f',arat0))  \
		I_0 = $(sprintf('%.2f',I0))  \
		S/N = $(SN>1e5?'\\2\\infty':sprintf('%.1f',SN))
		#
type_string 1	# convert a numerical type to a string
		set dimen($0) = $(dimen($1)).s
		set $0 = types[$1]
		#
type_int 1	# convert a string type to an int
		set dimen($0) = $(dimen($1))
		define i local
		do i=0,dimen(types) - 1 {
		   set $0 = ($1 == types[$i]) ? $i+0*$0 : $0
		}
		#
get_mds_type	1	# read type info from the MDS classification
		local set true_type = $1
		set $0 = (true_type == 1) ? 'obj' : \
		         (true_type == 2) ? 'galaxy' :  \
		         (true_type == 3) ? 'star' : \
		         (true_type == 4) ? 'exp' : \
		         (true_type == 5) ? 'deV' : \
		         (true_type == 6) ? 'exp+deV' : 'unknown'
get_type 	# read type info from the output of classify_groth (file $1)
		set type = (true_type == 1) ? 'star' : \
		           (true_type == 2) ? 'deV' :  \
		           (true_type == 3) ? 'exp' : \
		           (true_type == 4) ? 'galaxy' : \
		           (true_type == 5) ? 'galaxy' : \
		           (true_type == 6) ? 'fuzz' : \
		           (true_type == 7) ? 'blend' : 'unknown'
		define t local
		foreach t {exp deV} {
		   set type = (type == '$t' && r_$t""0 < 0.5/0.28) ? 'fuzz' : type
		}

		return
		
		set groth_flux20 = {12.705 283.427 320.991 228.664 80.9705}
		set groth_flux20 = {320.991}

		set groth_flux20 = groth_flux20*47.8 # exposure time
		define i local
		do i=0,dimen(groth_flux20)-1 {
		   set psfMag$i = 20 - 2.5*lg(psfCounts$i/groth_flux20[$i])
		   set petroMag$i = 20 - 2.5*lg(petroCounts$i/groth_flux20[$i])
		   set modelMag$i = 20 - 2.5*lg(model_counts$i/groth_flux20[$i])
		}
goo		#
		lim cell (mod0 concat mod1 concat mod2 concat mod3)
		box con cell data 
		do i=0,3{
		   if($i < 2) { ctype cyan } else { ctype blue }
		   con cell mod$i rel $(cell[9]) $(mod$i[9]) putl 5 $i
		}
		ctype magenta con cell mod ctype 0 error_y cell mod sig
read_errors 02	if(!$?1) { define 1 errors.out }
		if('$1' == '') { define 1 errors.out }
		define v local
		da $1 read {type 1.s star_L$3 2 deV_L$3 3 exp_L$3 4 re0 5 re 6 counts0 7 counts 8 arat0 9 arat 10 phi0 11 phi 12 sigma1 13 sigma2 14 b 15 SN 16}
		foreach v (b sigma1 sigma2) {
		   #set $v = int(1000*$v + 0.5)/1000
		}
		if($?2) {
		   set l local set l = (0*re + ($2))
		   foreach v {type star_L$3 deV_L$3 exp_L$3 re0 re counts0 counts arat0 arat phi0 phi sigma1 sigma2 b SN} {
		      set $v = $v if(l)
		   }
		}
		set L = type == 'deV' ? deV_L$3 : exp_L$3
		#
		# assume that 14th mag => flux of 1e6
		#
		set mag=14-2.5*lg(counts/1e6) 

		set x local set y local
		foreach v (phi phi0) {  # reduce phi/phi0 to -90, 90
		   set $v=pi*$v/180
		   set x=cos($v) set y=sin($v)
		   set $v = 180*atan2(y,x)/pi
		   set $v=(x < 0) ? (y < 0 ? $v + 180 : $v - 180) : $v
		}
		set phi = arat0 == 1 ? phi0 : phi

		set inten local set inten = (1 - arat0)/(1 + arat0)
		set U0=inten*sin(2*phi0*pi/180) set Q0=inten*cos(2*phi0*pi/180)
		set inten = (1 - arat)/(1 + arat)
		set U=inten*sin(2*phi*pi/180) set Q=inten*cos(2*phi*pi/180)
		set QErr0 = 0*Q0 set UErr0 = 0*U0
		set QErr = 0*Q set UErr = 0*U

		set HELP L {\sc L}
		set HELP re r_e
		set HELP counts total flux
		set HELP arat b/a
		set HELP phi \phi
		set HELP Q {\sc Q}
		set HELP U {\sc U}
		
		foreach v (re counts arat phi Q U) {
		   set HELP $v""0 $(HELP($v))
		}
		
		define ind unknown
		if(sum(phi0-phi0[0]) != 0) {
		   set ind=phi0  set HELP ind $(HELP(phi))
		} else { if(sum(arat0-arat0[0]) != 0) {
		   set ind=arat0 set HELP ind $(HELP(arat))
		} else {
		   set ind=1,dimen(re) set HELP ind Unknown
		}}
hoo
		window 1 -2 1 1
		lim ind (re0 concat re) BOX
		ctype red poi ind re ctype default
		ctype green poi ind re if(L > sum(L)/dimen(L))
		ctype default

		set re0 local set re0=re0  sort { re0 } set re0=uniq(re0)
		ctype cyan
		define re0 local
		foreach re re0 {
		   rel -100 $re draw 900 $re
		}
		ctype default

		yla \2\rm r_e
		xla \2$(HELP(ind))
		window 1 -2 1 2
		lim ind (0 concat L)  box
		poi ind L 
		yla \2{\sc L}
		window 1 1 1 1
		ctype magenta
		define i local
		do i=0,dimen(phi0)-1 {
		   if(abs(int(phi0[$i]/15)*15 - phi0[$i]) < 1e-2) { 
		      rel phi0[$i] -100 draw phi0[$i] 100
		   }
		}
		ctype default
sinh10     1	# like sinh, but ~ 10**x for large x
		set $0=10**$1 - 10**-$1
show_cellfit 12	# show a fit by cell; if $1 == 1, take asinh10 first;
		# don't reset limits if $2
		if($1) {
		   set mod local set data local set sig local
		   set foo local set goo local
		   set foo=data+sig  set goo=data-sig
		   set sig = 0.5*(asinh10(foo) - asinh10(goo))
		   set mod=asinh10(mod)  set data=asinh10(data)
		}
		if(!$?2) { define 2 0 }
		lim cell 0 0
		if(!$2) {
		   lim 0 0 (mod concat data) 
		   #lim cell (mod concat data concat 1500) 
		   #lim cell (-.1 concat 3.2)
		}
		box
		ptype 4 0 poi cell mod\n lt 1 con cell mod\n lt 0 ptype 4 1
		ctype cyan 
		angle 45 poi cell data angle 0
		con cell data
		ctype default
		error_y cell data sig
		ltype 1 pairs cell mod cell data ltype 0
		#xla Cell Number
		if($1) {
		   yla asinh_{10}({\rm I})
		} else {
		   yla \rm I
		}
		relocate $(($fx1 + $fx2)/2) $($fy1 + 0.9*($fy2-$fy1))
		label Data ({\2\apoint 45 4 1}) and Model ({\2\apoint 0 4 0})
		#
jpgtest_show_re_ab 12	# Show data for $1 (deV or exp) from jpgtest output
		# if $?2 && $2 == 1, use asinh10(re), if $2 == 2 use asinh(re)
		if(!$?2) { define 2 0 }

		define v local  define tmp local
		set lrat local  set lrat_star local

		foreach v (re re0 arat arat0) {
		   define tmp (HELP($v))
		   set $v local
		   if($?tmp) {
		      set HELP $v $tmp
		   }
		}

		if($2) {
		   if($2 == 1) { define v asinh10 } else { define v asinh }
		   set re=$v(re)
		   set re0=$v(re0)
		   set HELP re $v(r_e)
		   lim (re0 concat re > -2.9 ? re0 concat re : 0) 0 0
		} else {
		   lim (re0 concat re > -999 ? re0 concat re : 0) 0 0
		}
		lim 0 0 (0 concat 1)

		foreach v (_iy _ny) {
		   if(!$?$v) { 
		      define $v local 
		      define $v 1 
		   }
		}
		if($2 == 1 && $_iy == abs($_ny)) {
		   if($_ny == 1) {
		      box 1 2 3 0
		   } else {
		      box 0 2 3 0
		   }
		   set xx local set xs local
		   set xx={0 1 2 3 5 7 10 15 20 50 70 100}
		   set xs=string(xx) set xx=asinh10(xx)
		   AXIS $fx1 $fx2 xx xx xs $gx1 $gy2 $($gx2-$gx1) 1 1
		} else {
		   box
		}

		foreach v (re re0 arat arat0) {
		   define tmp (HELP($v))
		   set $v = $v if(type == '$1')
		   if($?tmp) {
		      set HELP $v $tmp
		   }
		}
		if(dimen(re0) == 0) {
		   echo "No objects of type $!1 have been measured"
		   return
		}

		set lrat=(('$1' == 'exp') ? deV_L$3/exp_L$3 : exp_L$3/deV_L$3) \
		    if(type == '$1')
		set lrat_star = star_L$3/L$1 if(type == '$1')
		#
		# Draw the grid of input values
		#
		set x local
		ctype cyan lt 2
		set x = re0 sort {x} set x=uniq(x)
		foreach v x {
		   rel $v -100 draw $v 100
		}
		set x = arat0 sort {x} set x=uniq(x)
		foreach v x {
		   rel -100 $v draw 100 $v
		}
		ctype default lt 0
		#
		define xla local
		if(!$?_ny) {
		   define xla 1
		} else {
		   if($_iy == 1) {
		      define xla 1
		   }
		}
		if($?xla) { xla \2$(HELP(re)) }
		yla \2b/a
		rel $fx1+0.9*($fx2-$fx1)  $fy1+0.9*($fy2-$fy1)
		label $1

		#
		# Show the parameter error vectors
		#
		pairs re0 arat0 re arat
		#
		# And the classification errors
		#
		poi re arat if(lrat <= 1 && lrat_star <= 1)
		ctype magenta
		poi re arat if(lrat > 1 && lrat_star <= 1)
		ctype 0
		#
		# Show objects classified as stars
		#
		ptype 6 1
		ctype red poi re arat if(lrat_star > 1)
		ctype default ptype 4 1
		#
re_ab 24	# plot an re against ab diagram for type $1 (deV, exp, or model)
		# using band $2. Only plot points for which $3 is true.
		# If $4 == "id" use IDs as ptype; if $4 == "error", plot
		# error bars. If $4 == "SG", plot stars and galaxies in colour;
		# if it is "star" or "galaxy" just plot that type
		photoL $2

		if('$1' == 'model') {
		   local set r_model$2 = \
		        (exp_L$2 < deV_L$2) ? r_exp$2 : r_deV$2
		   local set ab_model$2 = \
		        (exp_L$2 < deV_L$2) ? ab_exp$2 : ab_deV$2
		}
		
		if($?3) {
		   local set l = $3
		} else {
		   local set l = 1
		}

		if(!$?4) {
		   define 4 none
		}
		if('$4' == 'error' && !is_vector(r_$1Err$2)) {
		   define 4 none
		}

		set l = l && (r_$1$2 > 0)
		local define vecs <x y ee>
		set ee local  local define ex <$expand>
		local define verb $verbose  VERBOSE 0
		local set x = l ? lg(r_$1$2) : 0
		VERBOSE $verb
		local set y = ab_$1$2

		if(!is_vector(ee)) {
		   local set ee = 1 + 0*x
		}

		if('$4' == 'star' || \
		    '$4' == 'galaxy' || '$4' == 'deV' || '$4' == 'exp') {
		   set l = l && type=='$4'
		   define 4 SG
		}

		if('$4' == 'error') {
		   user abort "SORRY"
		   define vecs <$vecs xErr yErr>
		} else { if('$4' == 'id') {
		   local define pt <$ptype>
		   local set pt = string(id)
		   define vecs <$vecs pt>
		} else { if('$4' == 'SG') {
		   define vecs <$vecs type>
		   set type local
		} else {
		   user abort "Illegal value for \$4: $!4"
		   return
		}}}

		if(sum(l) == 0) {
		   return
		}

		if(dimen(l) > 1) {
		   define v local

		   foreach v ($vecs) {
		      set $v = $v if(l)
		   }
		}

		#range 2 2
		lim ({-1 2}) ({0 1})
		#lim ({-0.25 2.0}) ({-0.25 2})
		#lim ({-0.25 2.0} - 0.5) ({-0.25 2}-1)
		#lim ({-1.25 4.0}) ({-1.25 4.0})
		range 0 0
		bo

		if(is_vector(pt)) {
		   ptype pt
		}

		if(!is_vector(xErr)) {
		   if('$4' == 'SG') {
		      set _ee local
		      local define ptype |
		      foreach v {galaxy deV exp star} {
		         ctype_from_type $v
		         #ptype_from_type $v
 		         set _ee = ee if(type == '$v')
		         if(dimen(_ee) > 0) {
		            expand _ee
		            poi x y if(type == '$v')
		         }
		      }
		      ct 0 pt $ptype
		   } else {
		      poi x y
		   }
		} else {                # errorbars. Clip to points within box
		   if(sum(l) > 0) {
		      set l = l if(l)
		      set l=l && x >= $fx1 && x <= $fx2 && y >= $fy1 && y <= $fy2
		      foreach v ($vecs) {
		         set $v = $v if(l)
		      }
		      
		      error_x x y xErr
		      error_y x y yErr
		   }
		}
		
		if($?pt) {
		   ptype $pt
		}
		expand $ex

		local define xla 1
		if($?_iy) {
		   if($_iy > 1) {
		      define xla 0
		   }
		}
		if($xla) {
		   xla \2lg(r_e/pixel) ($(filter_name($2))) ({\-1$1})
		}
		yla \2a/b ($(filter_name($2))) ({\-1$1})
		
		RELOCATE ( 3000 32000 )
		label Frame: $frames ($rhl_val)
		if(dimen(l) > 1) {
		   label   if \-1$3
		}		
		
re_ab_type 23	# run re_ab for the various object types for type $1
		# (deV, exp, or model) using band $2. Only plot points for
		# which $3 is true.
		if(!$?3) { define 3 1 }

		local set pt=40
		local set ee = (sum($3) > 5000 ? 0.1 : 0.25) + 0*psfMag0

		set_window 1 -3\n 
		re_ab $1 $2 $3 SG
		
		set_window 1 -3\n 
		re_ab $1 $2 $3 star
		
		set_window 1 -3\n 
		re_ab $1 $2 $3 galaxy
		re_ab $1 $2 $3 deV
		re_ab $1 $2 $3 exp

		set_window
		label   ($(sum($3)) points))
		
residuals 02	# Plot residuals for a cellfit; use (e.g.) data$1 if $?1,
		# take asinh10 first if $2 & 0x1; don't set limits if $2 & 0x2
		local define gx2 |
		location $gx1 30000 $gy1 $gy2
		overload data 1         # there is a vector called data
		if($?1) {
		   local set data = data$1
		   local set fvec = fvec$1
		   local set sig = sig$1
		   local set mod = mod$1
		   local set cell = cell$1
		}
		if(!$?2) { define 2 0 }
		local define asinh ($2 & 0x1)
		local define nolim ($2 & 0x2)

		if(!$?Imax) { define Imax 0 }
		if($Imax == 0) { 
		   define chimax 0
		   define fvecmax 0
		}

		if(!$nolim || $Imax == 0) {
		   local define nolimI 0
		} else {
		   local define nolimI 1
		   lim 0 0 $Imin $Imax
		}
		
		window 1 -3 1 1:2
		show_cellfit $asinh $nolimI
		define Imin $fy1  define Imax $fy2
		
		window 1 -3 1 3
		set tmp local set tmp=fvec**2
		set i=1,dimen(tmp)
		local set nu=i-3        # total number of degrees of freedom
		local set nu_t=nu[dimen(nu)-1]
		set tmp=nu_t + cumulate(tmp) - nu
		
		if(!$nolim || $chimax == 0) {
		   lim 0 0 (0 concat tmp/nu_t)
		   #lim 0 0 (0 concat 10)
		   define chimax $fy2
		}
		lim 0 0 0 $chimax

		box 3 3 3 1
		con cell (tmp/nu_t)
		ltype 1
		con cell ((tmp+sqrt(2*nu))/nu_t)
		con cell ((tmp-sqrt(2*nu))/nu_t)		
		ltype 0

		rel $fx1 0 draw $fx2 0

		if(0) {
		ctype green ltype 2
		define i local
		do i=0,$fy2,nu[dimen(nu)-1] {
		   rel $fx1 $i  draw $fx2 $i
		}
		ctype 0 ltype 0
		}
		
		if(!$nolim || $fvecmax == 0) {
		   lim 0 0 fvec
		   define fvecmin $fy1
		   define fvecmax $fy2
		}
		lim 0 0 $fvecmin $fvecmax

		box 0 2 0 3
		ctype magenta poi cell fvec ctype 0
		yla Residuals
		rel $($fx1+int(1.05*($fx2-$fx1))) $(int(0.5*($fy1+$fy2)))
		angle 90
		putl 2 "\-1{}1 + Cumulative (\chi^2 - \nu)/\nu_\infty"
		angle 0
		window 1 1 1 1
		lt 1
		set X local  set xx local  set yy local  set i local
		set X=1+6*do(0,14) - 0.5
		set dimen(xx)=$(2*dimen(X))
		set i=0,dimen(X)-1
		set xx[2*i] = X
		set xx[2*i + 1] = X
		set yy=xx
		set yy[2*i] = (modulo(i,2)) ? $fy2 : $fy1
		set yy[2*i+1] = (!modulo(i,2)) ? $fy2 : $fy1
		con xx yy
		lt 0 
		box 1 3 3 3
		xla Cell
		if($?1) {
		   RELOCATE $(($fx1+$fx2)/2) $fy2
		   putlabel 8 $1
		}
		location $gx1 $gx2 $gy1 $gy2
		#
param_grid
		ctype cyan lt 1
		foreach v (149.875 120.311 96.5786 77.5276 62.2346 49.9583 40.1036\
		    32.1929 25.8425 20.7449 16.6528 13.3679 10.731 8.61418\
		    6.91496 5.55093 4.45596 3.57698 2.87139 2.30499 1.85031\
		    1.48532 1.19233 0.957131 0.768329 0.61677 0.495107 \
		    0.397443 0.319044 0.25611) {
		   rel $v -100 draw $v 100
		}
		foreach v (1 0.759836 0.57735 0.438691 0.333333 0.253279 0.19245 \
		  0.14623 0.111111) {
		   rel -100 $v draw 100 $v
		}
		ctype default lt 0
3d	44	# Usage: 3d theta phi zmin zmax
		# draw a surface from 2 slightly (delta) different viewpoints
		define d local define d 10
		define delta local define delta 1.5
		window -2 1 1 1 box 3 3 3 3
		Viewpoint $1 $2 $d
		ctype cyan Surface 2 $3 $4 x y ctype 0
		Surface 1 $3 $4 x y 
		window -2 1 2 1 box 3 3 3 3
		Viewpoint $1 $($2-$delta) $d
		ctype cyan Surface 2 $3 $4 x y ctype 0
		Surface 1 $3 $4 x y
		window 1 1 1 1
3d_movie 66	# Usage: 3d phi theta0 theta1 zmin zmax timestep
		define i local
		define d local define d 10
		define delta local define delta 1.5
		do i=$2,$3,$6 {
		   window -2 1 1 1 box 3 3 3 3
		   Viewpoint $1 $($i-$6) $d
		   ctype black Surface 3 $4 $5 x y ctype 0
		   Viewpoint $1 $i $d
		   ctype cyan Surface 2 $4 $5 x y ctype 0
		   Surface 1 $4 $5 x y 
		   window -2 1 2 1 box 3 3 3 3
		   Viewpoint $1 $($i-$delta-$6) $d
		   ctype black Surface 3 $4 $5 x y ctype 0
		   Viewpoint $1 $($i-$delta) $d
		   ctype cyan Surface 2 $4 $5 x y ctype 0
		   Surface 1 $4 $5 x y
		   window 1 1 1 1
		}
qoo		#
		lim 13 27 0.2 0.7
		set l=0,200,10
		set ang local  define i local
		set ang={0 5 30 40 45 49 50 51 55}
		do i=0,dimen(ang)-1 {
		   set_window -3 -3 $i
		   box
		   image chisq.$(ang[$i]).fts 1 80 0.01 1
		   levels l
		   contour
		   ctype cyan
		   levels {100}
		   contour
		   ctype magenta
		   rel 16.6528 0.438691 putl 5 \5\apoint45 4 1
		   ctype 0
		   rel $fx1+0.8*($fx2-$fx1)  $fy1+0.9*($fy2-$fy1)
		   putl 5 \phi_0 = $(ang[$i])
		}
SNcontour 12	# Contour SN on top of a show_re_ab plot for $1 (deV or exp)
		# if $?2 && $2 == 1, use asinh10(re), if $2 == 2 use asinh(re)
		if(!$?2) { define 2 0 }

		if(!is_macro(trigrid)) {
		   load irregular
		}

		define v local
		foreach v (SN re0 arat0) {
		   set $v local
		   set $v = $v if(type == '$1')
		}
		if($2) {
		   set re0=($2==1) ? asinh10(re0) : asinh(re0)
		}

		irregular_image re0 arat0 SN 20
		set l local 
		set l = 0,1000,25 levels l 
		ltype 1 ctype green contour ltype 0 ctype 0
		set l=0,1000,100 levels l
		contour
show_re_ab_all 12 #Runs "show_re_ab type $1" for exp and dev; calls SNcontour
		# if $?2
		if(!$?2) { define 2 0 }
		window 1 -2 1 1 
		show_re_ab deV $1
		if($2 && SN < 1e9) { SNcontour deV $1 }
		window 1 -2 1 2
		show_re_ab exp $1
		if($2 && SN < 1e9) { SNcontour exp $1 }
		window 1 1 1 1
		#
show_L	01	# show the likelihood distributions
		# if $?1, only consider objects rounder than b/a == $1
		if(!$?1) { define 1 1 }
		local set s={star deV exp}
		local set x=-0.1,1.1,0.05
		define v local
		foreach v s {
		   local set l$v=L$v if(type == '$v' && ($1))
		   set l$v=histogram(l$v:x) 
		}
		if(sum(type == 'deV' || type == 'exp') == 0) {
		   set lexp = (deV_L$3 > exp_L$3 ? deV_L$3 : exp_L$3) \
		    if(type == 'galaxy' && ($1))
		   set lexp=histogram(lexp:x) 
		}
		lim x (lexp concat ldeV concat lstar)
		foreach v s {
		   set_window 1 -$(dimen(s))
		   box
		   hi x l$v
		   rel $fx1+0.75*($fx2-$fx1)  $fy1+0.9*($fy2-$fy1)
		   putl 5 $v
		}
		set_window 1 1
show_L_mag 23	# plot $1 magnitude against likelihood for band $2. Don't set
		# x-limits. if $?3, only plot those points for which #3 is true
		if($?3) {
		   local set l = $3
		} else {
		   local set l = 1 + 0*$1""Mag$2
		} 
		lim 0 0 ({0 1})
		define type local
		foreach type {star exp deV} {
		   set_window 1 -3
		   box
		   ctype_from_type $type
		   poi $1""Mag$2 $type""_L$2 if(type == '$type' && l)
		   ct 0
		   rel $($fx1+0.9*($fx2-$fx1)) 0.1 putl 5 $type
		}
		set_window
		xla $(bands[$2])
		yla \1{\sc L}
		#
triangleBox 3	# Draw a box for a triangle plot
		lim -.6 .6 -.4 0.8
		ctype cyan lt 1
		rel -.5 $(-sqrt(1/12)) draw .5 $(-sqrt(1/12))
		draw 0 $(2/3*sqrt(0.75)) draw -.5 $(-sqrt(1/12)) 
		ctype 0 lt 0
		rel -.5 $(-sqrt(1/12)) putl 1 $1
		rel .5 $(-sqrt(1/12)) putl 3 $2
		rel 0 $(2/3*sqrt(0.75)) putl 8 $3
		rel 0 -.05 draw 0 0.05
		rel -.05 0 draw 0.05 0
		if(0) {
		   rel $fx1 0 draw $($fx1+0.05) 0
		   rel $fx2 0 draw $($fx2-0.05) 0
		   rel 0 $fy1 draw 0 $($fy1+0.05)
		   rel 0 $fy2 draw 0 $($fy2-0.05)
		}
		#
trianglePoi 01	# Draw points for which $1 is true into a triangle 
		set _l local
		if($?1) {
		   set _l = $1          # before we make star_L$3 etc. local
		} else {
		   define 1 _l set _l=1+0*exp_L$3 
		}
		set _s local set _s=exp_L$3+deV_L$3+star_L$3
		set random 0
		foreach 0 {star exp deV} {
		   set L$0 local
		   set L$0 = L$0/_s + 2e-2*(random(dimen(L$0)) - 0.5)
		}
		set x local set y local
		set x= (exp_L$3-deV_L$3)/2 set y=(star_L$3 - 1/3)*sqrt(0.75)
		set _s=.05+0.7*_s expand _s
		if('$ptype' == '4 1') {
		   ptype 4 0
		   poi x y if($1)
		   ptype 4 1
		} else {
		   poi x y if($1)
		}
		expand 1
		#
prismBox 56	# Draw a box for a triangular prism plot
		# Usage: prismBox theta phi L1 L2 L3 [nolimits]
		if(!$?6) { define 6 0 }
		if(!$6) {
		   lim -0.7 0.7 -0.7 0.7
		}
		#ctype cyan

		local set x=<-0.5           0.5            0>
		local set y=<$(-1/3*sqrt(3/4)) $(-1/3*sqrt(3/4)) $(2/3*sqrt(0.75))>
		set x = x concat x[0]
		set y = y concat y[0]
		local set z=(0*x concat 1+0*x) - 0.5
		set x=x concat x
		set y=y concat y

		set x_p local set y_p local set z_p local
		rotate x y z  x_p y_p z_p  $1 $2
		
		do i=0,2 {
		   rel x_p[$i] z_p[$i]
		   putlabel 2 $$($i+3)
		}

		set s=0,dimen(y_p)-1 set y=y_p if(s < 3) set s=0,2
		sort { y s }

		con x_p z_p
		define i local
		do i=1,2 {
		   rel x_p[$i] z_p[$i]
		   draw $(x_p[$i+4]) $(z_p[$i+4])
		}
		
		ctype 0 
		#
prismPoi 34	# Draw points for which $4 is true into a triangular prism;
		# the viewpoint is (theta, phi) = ($1, $2), band $3
		define v local
		overload exp 1
		set _l local
		if($?4) {
		   set _l = $4          # before we make star_L$3 etc. local
		} else {
		   set _l=1+0*exp_L$3
		}
		if(sum(_l) == 0) {      # nothing to plot
		   return
		}

		local set zrange = -100 # plot zrange < lnL < 0
		if(1 && zrange != 0) {
		   local set lnL_min = (exp_lnL$3 < deV_lnL$3) ? \
		    ((exp_lnL$3 < star_lnL$3) ? exp_lnL$3 : star_lnL$3) : \
		    ((deV_lnL$3 < star_lnL$3) ? deV_lnL$3 : star_lnL$3)
		   set lnL_min = (lnL_min < -30) ? -30 : lnL_min
		   foreach v (exp deV star) {
		      local set $v""_L = EXP($v""_lnL$3 - lnL_min)
		   }
		   overload exp 0

		   local set tot=exp_L+deV_L+star_L
		   
		   local set x=(exp_L-deV_L)/(2*tot)
		   local set y=(star_L/tot - 1/3)*sqrt(3/4)
		   local set z=max3(exp_lnL$3, deV_lnL$3, star_lnL$3)
		   set z = 1 - ((z < zrange) ? zrange : z)/zrange
		} else {
		   local set tot=exp_L$3+deV_L$3+star_L$3
		   
		   local set x=(exp_L$3-deV_L$3)/(2*tot)
		   local set y=(star_L$3/tot - 1/3)*sqrt(3/4)
		   local set z=max3(exp_L$3, deV_L$3, star_L$3)
		}
		set z = (1 - z) - 0.5

		if(1) {                 # dither points a little
		   set random 0
		   foreach v {x y z} {
		      set $v = $v + 1e-2*(random(dimen($v))-0.5)
		   }
		}

		set x_p local set z_p local
		project x y z  x_p z_p   $1 $2

		local define ptype |
		if(is_vector(pt)) {     # XXX hack hack
		   define ptype pt
		}
		if(dimen(<$ptype>) == 1) { # a vector
		   local set _pt = $ptype if(_l)  ptype _pt
		}
		   
		if(dimen(<$ptype>) == 2 && '$ptype' != '1 1') {
		   ptype 4 0
		}
		poi x_p z_p if(_l)

		ptype $ptype
		#
prismConn 56	# Connect points ($3 $4 $5) for which $6 is true into a 
		# triangular prism; the viewpoint is (theta, phi) = ($1, $2)
		local set deV_L$3 = $3 != 0 ? $3 : 1e-10
		local set exp_L$3 = $4 != 0 ? $4 : 1e-10
		local set star_L$3 = $5 != 0 ? $5 : 1e-10

		define v local
		set _l local
		if($?6) {
		   set _l = $6          # before we make star_L$3 etc. local
		} else {
		   define 6 _l set _l=1+0*exp_L$3 
		}
		local set tot=exp_L$3+deV_L$3+star_L$3

		local set x=(exp_L$3-deV_L$3)/(2*tot)
		local set y=(star_L$3/tot - 1/3)*sqrt(3/4)
		local set z=exp_L$3 > deV_L$3 ? (exp_L$3 > star_L$3 ? exp_L$3 : star_L$3) : \
		    (deV_L$3 > star_L$3 ? deV_L$3 : star_L$3)
		set z = (1 - z) - 0.5

		set x_p local set z_p local
		project x y z  x_p z_p   $1 $2

		connect x_p z_p if($6)
		#
prismConn3d 56	# Connect points L_i = ($3 $4 $5) for which $6 is true into a 
		# triangular prism; the viewpoint is (theta, phi) = ($1, $2)
		if(!$?6) {
		   set _l local set _l=1 + 0*$3 define 6 _l
		}
		window -2 1 1 1
		prismConn $1 $($2-1) $3 $4 $5 $6
		window -2 1 2 1
		prismConn $1 $($2+1) $3 $4 $5 $6
		window 1 1 1 1
		#
prismLines 2	# divide the base of a L prism by lines of L == L
		local set x={1 1 0} local set y={0 1 0} local set z={0 1 1}
		ct yellow lt 1
		prismConn $1 $2 x y z
		set x=1e-5*x set y=1e-5*y set z=1e-5*z
		prismConn $1 $2 x y z
		set x={1 1} concat 1e-5*{1 1}
		set y={0 1} concat 1e-5*{1 0}
		set z={0 1} concat 1e-5*{1 0}
		prismConn $1 $2 z x y
		ct 0 lt 0
		#
prismLines3d 2	# divide the base of a L prism by lines of L == L
		local set x={1 1 0} local set y={0 1 0} local set z={0 1 1}
		ct yellow lt 1
		prismConn3d $1 $2 x y z
		set x=1e-5*x set y=1e-5*y set z=1e-5*z
		prismConn3d $1 $2 x y z
		set x={1 1} concat 1e-5*{1 1}
		set y={0 1} concat 1e-5*{1 0}
		set z={0 1} concat 1e-5*{1 0}
		prismConn3d $1 $2 z x y
		ct 0 lt 0
		#
Ltriangle 01	# Draw points into a triangle
		triangleBox deV exp star
		if(!$?1) {
		   trianglePoi
		} else {
		   trianglePoi $1
		}
LtriangleType 01	# draw a triangle diagram colour coded by type
		set _l local
		if($?1) {
		   set _l = $1          # before we make star_L$3 etc. local
		} else {
		   define 1 _l set _l=1+0*exp_L$3
		}

		triangleBox deV exp star
		define expand local  define expand |
		expand $($expand*2)
		ctype cyan trianglePoi type=='exp'&&_l
		ctype magenta trianglePoi type=='galaxy'&&_l
		ctype red trianglePoi type=='deV'&&_l
		ctype green trianglePoi type=='star'&&_l
		ctype default trianglePoi type=='fuzz'&&_l
		ctype 0
		expand $expand
Lprism 35	# draw a triangular prism diagram
		# Lprism theta phi band [logical] [nolimits]
		if(!$?5) { define 5 0 }
		set _l local
		if($?4) {
		   set _l = $4          # before we make star_L$3 etc. local
		} else {
		   define 4 _l set _l=1+0*exp_L$3
		}

		prismBox $1 $2 deV exp star $5
		prismPoi $1 $2 $3 _l
		#
LprismType 35	# draw a triangular prism diagram colour coded by type in band $3
		# (theta,phi) = ($1,$2) [optionally, if $4 is true]
		# Usage: LprismType theta phi [logical] [nolimits]
		photoL $3
		set _l local
		if($?4) {
		   set _l = $4          # before we make star_L$3 etc. local
		} else {
		   set _l=1+0*exp_L$3
		}
		prismBox $1 $2 deV exp star $?5

		local define expand |
		if(dimen(<$ptype>) == 2) { # not a vector
		   #expand $($expand/(sum(_l) < 50 ? 1.5 : 3))
		}
		if(dimen(psfMag1) > 10000) {
		   expand 0.4
		} else {
		}
		
		if(0) {
		   echo Concentration Index
		   local set type = (type == 'star') ? 'star' : \
		       (petroR502/petroR902 > 0.43) ? 'exp' : 'deV'
		} else {
		   echo u' - r'
		   local set type = (type == 'star') ? 'star' : \
		       (modelMag0 - modelMag2 < 2.2) ? 'exp' : 'deV'
		}

		define j local  set __l local
		local define nmod 20
		local set rand = $nmod*random(dimen(type))
		do j=0,$nmod - 1 {
		   set __l = _l && (rand%$nmod == $j)
		   ctype green prismPoi $1 $2 $3 type=='star'&&__l
		   ctype red prismPoi $1 $2 $3 type=='deV'&&__l
		   ctype cyan prismPoi $1 $2 $3 type=='exp'&&__l
		   ctype magenta prismPoi $1 $2 $3 type=='galaxy'&&__l
		   ctype default prismPoi $1 $2 $3 (type=='fuzz'||type=='unknown')&&__l
		}
		ctype 0
		expand $expand
		#
LprismType3d 34	# draw a triangular prism diagram colour coded by type in 3d
		# for band $3
		# Seen from (theta,phi) = ($1,$2) [optionally, if $4 is true]
		if(!$?4) {
		   set _l local set _l=1 + 0*star_L$3 define 4 _l
		}
		window -2 1 1 1
		LprismType $1 $($2-1) $4
		window -2 1 2 1
		LprismType $1 $($2+1) $3 $4
		window 1 1 1 1
		if(!is_vector(I0)) {
		   set dimen(I0) = 0
		}
		if(dimen(I0) > 0) {
		   if(sum(I0) == I0[0]*dimen(I0)) {
		      RELOCATE ( 17600 $gy2 )
		      putl 5 I_0 = $(I0)
		   }
		}
		#
LprismTypeAll 01 # call LprismType for all angles in 0..360 (10)
		define a local
		do a=0,359,10 {
		   set_window -6 -6
		   if($?1) {
		      LprismType 15 $a $1
		   } else {
		      LprismType 15 $a
		   }
		   relocate $($fx1 + 0.9*($fx2-$fx1)) $($fy1 + 0.9*($fy2-$fy1))
		   putl 5 \-2$a^\circ
		}
		window 1 1 1 1
LprismTypePsf 23 # Draw Lprism plots for all PSF inputs
		if(!$?3) { define 3 "0*b+1" }
		set bb local set bb=b if($3) sort{bb} set bb=uniq(bb)
		set s1 local set s1=sigma1 if($3) sort{s1} set s1=uniq(s1)
		set s2 local set s2=sigma2 if($3) sort{s2} set s2=uniq(s2)

		set_window 1 1
		define y_gutter local define y_gutter 0.5

		if(dimen(s2) == 1) {
		   foreach s1 s1 {
		      foreach b bb {
		         set_window -$(dimen(bb)) $(dimen(s1))
		         LprismType $1 $2  ($3)&&abs(b-$b)<1e-3&&sigma1==$s1
		         lim 0 1 0 1
		         rel 0 -0.05
		         putl 3 \-2\sigma_1 = $(sprintf('%.1f',$s1)), \sigma_2 = $(sprintf('%.1f',s2))
		         rel 0 -0.05 RELOCATE ($xp $($yp-800))
		         putl 3 \-2b = $(sprintf('%.3f',$b))
		      }
		   }
		} else { if(dimen(s1) == 1) {
		   foreach s2 s2 {
		      foreach b bb {
		         set_window -$(dimen(bb)) $(dimen(s2))
		         LprismType $1 $2  ($3)&&abs(b-$b)<1e-3&&sigma2==$s2
		         lim 0 1 0 1
		         rel 0 -0.05
		         putl 3 \-2\sigma_1 = $(sprintf('%.1f',s1)), \sigma_2 = $(sprintf('%.1f',$s2))
		         rel 0 -0.05 RELOCATE ($xp $($yp-800))
		         putl 3 \-2b = $(sprintf('%.3f',$b))
		      }
		   }
		} else { if(dimen(bb) == 1) {
		   foreach s1 s1 {
		      foreach s2 s2 {
		         set_window -$(dimen(s2)) $(dimen(s1))
		         if(sum(($3)&&sigma1==$s1&&sigma2==$s2) > 0) {
		            LprismType $1 $2  ($3)&&sigma1==$s1&&sigma2==$s2
		             lim 0 1 0 1
		             rel 0 -0.05
		             putl 3 \-2\sigma_1 = $(sprintf('%.1f',$s1)), \sigma_2 = $(sprintf('%.1f',$s2))
		             rel 0 -0.05 RELOCATE ($xp $($yp-800))
		             putl 3 \-2b = $(sprintf('%.3f',bb))
		          }
		      }
		   }
		} else {
		   set foo local set foo=sprintf('%7.5f',b) + ':' + sprintf('%7.5f',sigma1) + ':' + sprintf('%7.5f',sigma2) if($3)
		   set foo = '0' concat foo
		   sort{foo} set foo=uniq(foo)
		   set foo = foo if(foo != '0')
		   set bb=atof(substr(foo,0,7))
		   set s1=atof(substr(foo,8,7))
		   set s2=atof(substr(foo,16,7))

		   define nwx local define nwy local
		   define nwx ( int(sqrt(dimen(s1))) )
		   define nwy ( int(sqrt(dimen(s1))/$nwx) )
		   while {$nwx*$nwy < dimen(s1)} { define nwy ( $nwy+1) }

		   set l local
		   do i=0,dimen(foo) - 1 {
		      set_window -$nwx $nwy
		      define s1 (s1[$i])  define s2 (s2[$i])  define b (bb[$i])
		      set l = ($3) && sigma1==$s1 && sigma2==$s2 && abs(b-$b)<1e-3
		      LprismType $1 $2 l
		      
		      lim 0 1 0 1
		      rel 0 -0.05
		      putl 3 \-2\sigma_1 = $(sprintf('%.1f',$s1)), \sigma_2 = $(sprintf('%.1f',$s2))
		      rel 0 -0.05 RELOCATE ($xp $($yp-800))
		      putl 3 \-2b = $(sprintf('%.3f',$b))
		   }
		}}}
		set_window 1 1
		#
starGalaxy 12	# Plot a simple star/galaxy separator in band $1
		if($?2) {
		   local set Lcrit = $2
		} else {
		   local set Lcrit = 0.2
		}
		set Lrat local
		set Lrat=star_L$1/(exp_L$1 > deV_L$1 ? (exp_L$1 > star_L$1 ? exp_L$1 : star_L$1) : \
		    (deV_L$1 > star_L$1 ? deV_L$1 : star_L$1))
		#set Lrat=star_L$1/(exp_L$1+deV_L$1+star_L$1)
		#set Lrat=star_L$1/(exp_L$1 > deV_L$1 ? exp_L$1 : deV_L$1)

		set type = (Lrat > Lcrit) ? 'star' : 'galaxy'
plot_starGalaxy 12	# Plot a simple star/galaxy separator in band $1 (if $2 is true)
		if(!$?2) {
		   set _l local set _l=1 + 0*star_L$1 define 1 _l
		}
		set x local  set Lrat local
		set x=lg(cts) set HELP x lg(counts)
		set x=lg(SN)  set HELP x lg(S/N)
		set x=mag set HELP x Mag

		set Lrat=star_L$1/(exp_L$1 > deV_L$1 ? (exp_L$1 > star_L$1 ? exp_L$1 : star_L$1) : \
		    (deV_L$1 > star_L$1 ? deV_L$1 : star_L$1))
		#set Lrat=star_L$1/(exp_L$1+deV_L$1+star_L$1)
		#set Lrat=star_L$1/(exp_L$1 > deV_L$1 ? exp_L$1 : deV_L$1)

		define v local
		foreach v (x Lrat) {
		   define tmp (HELP($v))
		   set $v = $v + 2e-2*random(dimen(Lrat))
		   if($?tmp) {
		      set HELP $v $tmp
		   }
		}
		lim (0 concat x) (0 concat 1)
		if(HELP(x) == 'Mag') {
		   set x = x + 0.1*random(dimen(x))
		   lim x 0 0
		   set HELP x Mag
		}
		box
		ctype green poi x Lrat if(type=='star' && ($1))
		ctype red poi x Lrat if(type=='deV' && ($1))
		ctype magenta poi x Lrat if(type=='galaxy'  && ($1))
		ctype blue poi x Lrat if(type=='exp' && ($1))
		ctype default poi x Lrat if(type=='fuzz' && ($1))
		ctype 0
		xla $(HELP(x))
		#
max3	3	# return maximum of three vectors	
		set $0 = ($1 > $2) ? (($3 > $1) ? $3 : $1) : \
                                  (($3 > $2) ? $3 : $2)
		#
photoL_callback 1 # Callback from photoL
		#
photoL	1	# convert photo's output for colour $1 to match that from
		# tst_cellfit.tst.  Calls photoL_callback if defined
		define iband $1
		if($?FILTERS) {
		   local set filters = <$FILTERS>
		   define band ( filters[$iband] + '\'')
		} else {
		   define band $iband
		}
		
		#set saturated = is_set(objc_flags2,$OBJ2_SATUR_CENTER)
		set saturated = is_set(objc_flags,$OBJ1_SATUR)
		set detected = (is_set(flags$1,$OBJ1_BINNED1) ? 1 : 0) + \
		               (is_set(flags$1,$OBJ1_BINNED2) ? 2 : 0) + \
		               (is_set(flags$1,$OBJ1_BINNED4) ? 4 : 0)
		set blended = is_set(objc_flags,$OBJ1_BLENDED) \
		                   && !is_set(objc_flags,$OBJ1_NODEBLEND)
		set bright = is_set(objc_flags,$OBJ1_BRIGHT)
		set edge = is_set(objc_flags,$OBJ1_EDGE)
		set nopetro = is_set(flags$1,$OBJ1_NOPETRO)

		#echo Ignoring status field\n local define ignore_status 1
		if(!$?ignore_status) {
		   local define ignore_status 0
		}
		set good=($ignore_status || psp_status == $PSP_FIELD_OK) && \
		    detected&&!edge&&!saturated&&!bright
		#set type = objc_type
		#set type = maki(0.109)
		if(1) {
		   set type = classify_galaxies(objc_type, $rhl_val)
		} else {
		   local set type_1 = classify_galaxies(type1, $rhl_val)
		   local set type_2 = classify_galaxies(type2, $rhl_val)
		   local set type_3 = classify_galaxies(type3, $rhl_val)
		   set type = (type_1 == type_2) ? type_1 : \
		       (type_1 == type_3) ? type_1 : type_2
		}
		if(is_macro(photoL_callback)) {
		   photoL_callback $iband
		}
Lconcat_set_run 15 # Here's a do-nothing implementation of Lconcat_set_run
		if('$1' == '-1') {
		   set $0 = 1.0
		   return
		}
		
		define data_root "$!1"
		define run $2
		define col $3
		if(!$?4) { define 4 0 }
		if(!$?5) { define 5 -1 }
		local define tsObj $4
		define rerun $5

		set_run $data_root $run $col $tsObj $rerun
		#
Lconcat	189	# concatenate the likelihoods from a number of photo frames
		# root $1, run $2, columns $3,$4, frames $5,$6; colours $7,$8.
		# (the `run' may specify a rerun number, e.g. 745:3)
		# Any other arguments are either:
		#   "+" to simply append the specified columns/fields to the 
		# results of a previous Lconcat command (must be first)
		#
		#   a number to read every n'th field
		#
		#   fields to ignore, of the form <col>c<field> (e.g. 3c110),
		# or entire columns (<col>c, e.g. 4c)
		#
		local define tsObj 0
		define rerun -1
		define run "$!2"
		if(index('$run', ':') >= 0) {
		   define rerun   ( substr('$run', index('$run', ':') + 1, 0) )
		   define run ( substr('$run', 0, index('$run', ':')) )
		   if(index('$rerun', ':') >= 0) {
		      define tsObj ( substr('$rerun', index('$rerun', ':') + 1, 0))
		      if('$tsObj' == 'tsObj' || '$tsObj' == 'ts') {
		         define tsObj 1
		      }
		      define rerun ( substr('$rerun', 0, index('$rerun', ':')) )
		   }
		}

		echo Run $run Rerun $rerun

		if($?quick_Lconcat) {
		   local define quick $quick_Lconcat
		} else {
		   local define quick 1
		}

		set vecs0 local  set vecs local
		set vecs0 = {psp_status objc_type objc_rowc objc_colc field objc_flags objc_flags2 ndetect rerun}
		set vecs = {exp_L star_L deV_L flags flags2 aperMag psfMag petroMag modelMag expMag deVMag fiberMag fiber2Mag type exp_lnL star_lnL deV_lnL petroRad petroR50 fracPSF}
		set vecs = vecs concat {cmodelMag}

		if(!$quick) {
		   set vecs = vecs concat {sky skyErr}
		   set vecs = vecs concat {rowc rowcErr colc colcErr}
		   set vecs = vecs concat {r_exp r_deV r_expErr r_deVErr \
		          ab_exp ab_deV phi_exp phi_deV psfMagErr modelMagErr \
		       petroR50Err petroR90 petroR90Err}
		   if(!$tsObj) {
		      set vecs = vecs concat {petroCounts expCounts deVCounts modelCounts}
		   }
		   set vecs0 = vecs0 concat {rowv colv rowvErr colvErr}
		}
		if(1) {
		   #set vecs0 = vecs0 concat {nchild}
		   set vecs = vecs concat {M_rr_cc_psf M_rr_cc}
		}
		if(0 && !$quick) {
		   set vecs = vecs concat {M_e1 M_e2 M_rr_ccErr \
		       M_e1e1Err M_e1e2Err M_e2e2Err }
		}
		if(0 && !$quick) {
		   set vecs = vecs concat {texture}
		}

		if(0 && !$quick) {           # XXX From TST file
		   set vecs = vecs concat { \
		       row_bias col_bias }
		}

		define c local define f local define v local
		#
		# is there a modifier to the column, to specify a different
		# directory?
		#
		local define mod ( substr('$3', 1, 0) ) # modifer to column
		if(!$?mod) { define mod " " }
		define 3 ( substr('$3', 0, 1) )
		define 4 ( substr('$4', 0, 1) )
		#
		# Deal with requests to append or skip fields
		#
		if(!$?9) { define 9 0c1 }
		# trim trailing spaces
		while { substr('$9', -1, 0) == ' '} {
		   if('$9' == ' ') {
		      define 9 delete
		      break
		   }
		   define 9 ( substr('$9', 0, strlen('$9') - 1) )
		}

		if(substr('$9',0,1) == '+') {       # append
		   define 9 ( substr('$9', 1, 0) )
		   local define append 1

		   if(0) {
		      local set id_s = id
		      foreach v vecs0 {
		         local set $v""_s = $v
		      }
		      do c = $7,$8 {
		         foreach v vecs {
		            local set $v""$c""_s = $v""$c
		         }
		      }
		   }
		} else {
		   local define append 0
		}

		if(!$?9) {
		   define 9 0c1         # don't skip anything
		}

		if(whatis($9) == 0) {   # a number
		   local define dfield $9
		   define 9 0c1         # don't skip anything
		} else {
		   local define dfield 1
		}

		set ignore local
		local set ignore_field = <$9>
		if(is_set(whatis(ignore_field),5)) { # not a string vector
		   set ignore_field = string(ignore_field)
		}
		local set ignore_col = ignore_field

		local set i=index(ignore_field, 'c')
		if(sum(i) >= 0) {
		   set ignore_col = atof(substr(ignore_col, 0, i))
		   set ignore_field = atof(substr(ignore_field, i+1, 0))
		   #
		   # expand a simply "3c" to all fields in column 3
		   #
		   local set foo = ignore_col if(ignore_field == 0)
		   if(dimen(foo) > 0) {
		      set ignore_col = ignore_col if(ignore_field > 0)
		      set ignore_field = ignore_field if(ignore_field > 0)
		      
		      foreach v foo {
		         set ignore_field = ignore_field concat do($5,$6)
		         set ignore_col = ignore_col concat ($v + 0*do($5,$6))
		      }
		   }
		} else {
		   set ignore_col = $3
		}
		#
		# Create vectors for all data requested. We assume that
		# we need nguess elements, and we'll read the first one
		# into index $i0
		#
		local define nguess 1000
		if(is_macro(Lconcat_set_run)) { # guess at fraction kept
		   define nguess ( $nguess*Lconcat_set_run(-1, 0,0,0,0) )
		}
		define nguess ( $nguess*int(($4-$3+1)*($6-$5+1)/$dfield) )

		if($append) {
		   local set i0 = dimen(field)
		   define nguess ( i0 + $nguess )
		} else {
		   local set i0 = 0
		}
		local set i0_0 = i0
		set i1 local

		set id_A local
		set dimen(id_A) = $nguess.s
		if($append) {
		   set id_A[0, i0-1] = id
		}
		foreach v vecs0 {
		   set $v""_a local

		   if(index('$v', 'type') >= 0) {
		      set dimen($v""_a) = $nguess.s
		   } else { if(index('$v', 'flag') >= 0) {
		      set dimen($v""_a) = $nguess.i
		   } else {
		      set dimen($v""_a) = $nguess
		   }}
		   if($append) {
		      set $v""_a[0, i0-1] = $v
		   }
		}

		foreach v vecs {
		   do c=$7,$8 {
		      set $v""$c""_a local
		      if(index('$v', 'type') >= 0) {
		         set dimen($v""$c""_a) = $nguess.s
		      } else { if(index('$v', 'flag') >= 0) {
		         set dimen($v""$c""_a) = $nguess.i
		      } else {
		         set dimen($v""$c""_a) = $nguess
		      }}
		      if($append) {
		         set $v""$c""_a[0, i0-1] = $v""$c
		      }
		   }
		}

		#
		# Actually read data from files
		#
		local define warned_Lconcat_trim 0
		define frac local

		do c=$3,$4 {
		   if(is_macro(Lconcat_set_run)) {
		      Lconcat_set_run $1 $run $c""$mod $tsObj $rerun
		   } else {
		      set_run $1 $run $c""$mod $tsObj $rerun
		   }
		   define col $c        # remove $mod again

		   do f=$5,$6,$dfield {
		      if(sum(ignore_col == $col && ignore_field == $f) == 0) {
		         echo Reading $col:$f
		         gett $f $quick

		         if($8 >= $NFILTER) {
		            echo "There are only $!NFILTER bands in the files, not $!($!8+1)" 
		            define 8 ($NFILTER - 1)
		         }

		         set field = int($f + 0*flags0)
		         set psp_status = psp_status + 0*flags0
		         set rerun = $rerun + 0*flags0

		         if(is_macro(Lconcat_trim)) {
		            if(!$warned_Lconcat_trim) {
		               define warned_Lconcat_trim 1
		               bell
		               echo Running Lconcat_trim
		            }
		            if(Lconcat_trim($run, $col, $f, $7, $8) == 0) {
		               #echo Lconcat_trim $run, $col, $f, $7, $8: No objects
		            }
		         }

		         set i1 = i0 + dimen(flags0) - 1
		         foreach v vecs0 {
		            set $v""_a[i0, i1] = $v
		         }
		         
		         do c = $7,$8 {
		            foreach v vecs {
		               set $v""$c""_a[i0, i1] = $v""$c
		            }
		         }
		         
		         set id_A[i0, i1] = \
		             '$col-' + sprintf('%03d',field) + '.' + string(id)
		      }
		      set i0 = i1 + 1
		   }
		}

		local set was_read = 1 + 0*objc_flags_a
		if(i1+1 < dimen(was_read) - 1) {
		   set was_read[i1+1, dimen(was_read) - 1] = 0
		}
		set id = id_A if(was_read)
		
		foreach v vecs0 {
		   set $v = $v""_a if(was_read)
		}
		do c = $7,$8 {
		   foreach v vecs {
		      set $v""$c = $v""$c""_a if(was_read)
		   }
		}

		foreach c (c1 c2 f1 f2 df) {
		   define $c local
		}

		if($append) {
		   split_frame $frames

		   if($4 > $c2) {
		      define c2 $4
		   }
		   if($6 > $f2) {
		      define f2 $6
		   }
		} else {
		   define c1 $3  define c2 $4
		   define f1 $5  define f2 $6
		}
		define frames "$!c1..$!c2:$!f1..$!f2"
		if($dfield > 1) {
		   define frames "$!frames,$!dfield"
		}

		set objc_rowc = objc_rowc + (do(0,dimen(field)-1) < i0_0 ? 0 : 1361*(field - $f1))
		#
save_Lconcat 12	# Save a set of vectors read by Lconcat by prepending $1; if
		# $?2 && $2, restore the vectors prepended by $1
		if(!$?2) { define 2 0 }

		local define pre $1
		local define rest $2

		set vecs0 local  set vecs local
		set vecs0 = {psp_status objc_type objc_rowc objc_colc field objc_flags objc_flags2}
		if(is_vector(objc_field)) {
		   set vecs0 = vecs0 concat objc_field
		}
		set vecs = {exp_L star_L deV_L flags flags2 aperMag psfMag petroMag modelMag fiberMag fiber2Mag type exp_lnL star_lnL deV_lnL}
		if(0) {
		   set vecs = vecs concat {sky skyErr}
		   set vecs = vecs concat {rowcErr colcErr}
		   set vecs = vecs concat {r_exp r_deV r_expErr r_deVErr ab_exp ab_deV psfMagErr modelMagErr expMag deVMag petroRad petroR50 petroR50Err petroR90 petroR90Err iso_ab}
		   set vecs0 = vecs0 concat {rowv colv rowvErr colvErr}
		}
		if(0) {
		   set vecs = vecs concat {M_rr_cc_psf M_rr_cc}
		   if(0) {
		      set vecs = vecs concat {M_e1 M_e2 M_rr_ccErr \
		          M_e1e1Err M_e1e2Err M_e2e2Err }
		   }
		}

		local define v $pre""$(vecs0[0])
		if($rest) { if(!is_vector($v)) {
		   user abort You don't seem to have saved anything as \"$pre\"
		}}

		foreach v vecs0 {
		   if($rest) {
		      set $v = $pre""$v
		   } else {
		      set $pre""$v = $v
		   }
		}
		define c local
		do c = 0,$NFILTER-1 {
		   foreach v vecs {
		      if($rest) {
		         set $v""$c = $pre""$v""$c""
		      } else {
		         set $pre""$v""$c = $v""$c""
		      }
		   }
		}

split_frame 111	# Split $1 (typically $frames) into c1, c2, f1, f2 [,df]
		define i local
		local define rest "$!1"

		define i ( index('$rest', ' ') )
		if ($i >= 0) {
		   define rest (substr('$rest', 0, $i))
		}

		define i ( index('$rest', '.') )
		define c1 (substr('$rest', 0, $i))
		define rest (substr('$rest', $i + 2, 0))
		
		define i ( index('$rest', ':') )
		define c2 (substr('$rest', 0, $i))
		define rest (substr('$rest', $i + 1, 0))

		define i ( index('$rest', '.') )
		define f1 (substr('$rest', 0, $i))
		define rest (substr('$rest', $i + 2, 0))
		
		define i ( index('$rest', ',') )
		if($i < 0) {
		   define f2 (substr('$rest', 0, 0))
		} else {
		   define f2 (substr('$rest', 0, $i))
		   define rest (substr('$rest', $i + 1, 0))
		   define df (substr('$rest', 0, 0))
		}
psf_model_color 25 # Plot psf-model colour versus rowc for band $1-$2 if $3;
		# magnitude types $4 and $5 (default: psf and model)
		#
		photoL $1
		if(!$?3) {
		   local set l = 1 + 0*psfMag$1  
		} else {
		   local set l = $3
		}
		if(!$?4) { define 4 psf }
		if(!$?5) { define 5 model }
		overload exp 1
		local define t1 $4
		local define t2 $5
		overload exp 0		

		local set x = objc_rowc if(l)
		local set y = \
		    ($t1""Mag$1 - $t1""Mag$2) - ($t2""Mag$1 - $t2""Mag$2) if(l)
		stats y mean sig k
		echo Mean = $(sprintf('%.3f',$mean)) +- $(sprintf('%.3f', $sig))
		    
		notation -100 -100 0 0
		lim x (0.1*{-1 1}) bo
		notation 0 0 0 0
		lt 1 ct yellow rel $fx1 0 draw $fx2 0 lt 0 ct 0

		local define bdy 0
		lt 1 ctype green
		while {$bdy < $fx2} {
		   rel $bdy $fy1  draw $bdy $fy2
		   define bdy ($bdy + 5*1361)
		}
		lt 0 ct 0

		#set pt = id if(l) ptype pt
		poi x y
		ptype 4 1
		xla rowc
		yla ($(filter_name($1)) - $(filter_name($2)))_{$t1"" - $t2""}
ctype_from_type 12 # set a colour given a type; if $?2 return name instead
		local set types={
		   unknown star deV exp exp+deV galaxy fuzz blend sky knownobj
		}
		local set ctypes={
		   default green red cyan magenta magenta default default default default
		}
		set $0 = ctypes if('$1' == types)
		if(dimen($0) == 0) { set $0 = {default} }
		if(!$?2) {
		   ctype $($0)
		}
ptype_from_type 11 # set a ptype given a type
		local set types={\
		   unknown star  deV   exp   exp+deV galaxy fuzz blend sky knownobj
		}
		local set ptypes={\
		   41   41 40 60 50 50 0 0 0 0
		}
		set $0 = ptypes if('$1' == types)
		if(dimen($0) == 0) { set $0 = 41 }
		local define n1 (int($0/10)) local define n2 ($0%10)
		ptype $n1 $n2
points_by_type 34 # Plot something $1 against $2,
		# colour coding using type names $3. Only plot points for
		# which $4 is true.
		if($?4) {
		   local set _l = ($4)
		} else {
		   local set _l = 1 + 0*$1
		}
		local set comp_type = $3 if(_l)
		local set types_vanilla = types

		local set $1=$1 if(_l)

		if(index('$2','type') == -1) { # not a type
		   local set $2=$2 if(_l)
		   lim $1 $2
		   box
		} else {
		   local set types=$2 if(_l) 
		   sort { types } set types=uniq(types)

		   set random 0
		   local set $2=type_int($2) + 0.6*(random(dimen($2))-0.5)

		   lim $1 $2
		   box 1 0
		}

		do i=0,dimen(types_vanilla)-1 {
		   ctype_from_type $(types_vanilla[$i])
		   poi $1 $2 if(comp_type == types_vanilla[$i])
		}
		ctype default
		
		if(index('$2','type') >= 0) {
		   set s local set dimen(s)=0
		   local set labs='\\0' + types
		   local set b=0,dimen(labs)-1
		   angle 90
		   AXIS $fy1 $fy2 s b labs $gx1 $gy1 $($gy2-$gy1) 2 1
		   angle 0
		}
		xla $1
		yla $(quote_TeX('$2'))
		#
histo_by_type 45 # Plot $1 as histograms, one for each value of $2
		# colour coding using type names $3. The bins are given by
		# $4; Only plot points for which $5 is true.
		#
		# e.g. histo_by_type texture1 objc_type type do(0,1,.1) psfMag1>18
		if($?5) {
		   local set _l = ($5)
		} else {
		   local set _l = 1 + 0*$1
		}
		local set comp_type = $3
		local set types_vanilla = types
		
		local set types=$2 if(_l) sort { types } set types=uniq(types)
		local set type=type_int($2)

		set h local set foo local set ct local
		local set bins=$4

		set_window
		define t local
		foreach t types {
		   set_window 1 -$(dimen(types))

		   set foo=$1 if(_l && type==type_int('$t'))
		   set ct=comp_type if(_l && type == type_int('$t'))

		   set h=histogram(foo:bins)
		   lim bins h box
		   lt 1 hi bins h lt 0

		   do i=0,dimen(types_vanilla)-1 {
		      ctype_from_type $(types_vanilla[$i])
		      set h=foo if(ct == types_vanilla[$i])
		      hi (bins+($i/(dimen(types_vanilla)-1)-0.5)*(bins[1]-bins[0])/5) (histogram(h:bins))
		   }
		   ctype default

		   lim 0 1 0 1  rel .9 .9 putl 5 $t
		}
		set_window
		xla $(quote_TeX('$1'))
		yla N
		#
LprismMags 56	#Show the Lprism diagrams for magnitudes $1..$2 in band $5;
		# viewpoint $3 $4 (if $6 is true, if provided)
		photoL $5
		set l local if($?6) { set l = $6 } else { set l = 1 }
		define l local  define nx local define ny local
		define nx (int(sqrt($2-$1+1) + 0.999))
		define ny (int(($2-$1+1)/$nx))
		while {$nx*$ny < $2 - $1 + 1} { define ny ($ny + 1) }
		do l=$1,$2 {
		   set_window -$nx -$ny
		   LprismType $3 $4 $5 abs(modelMag$5-$l)<0.5&&l
		   lim 0 1 0 1 rel .9 .9
		   putl 5 $l\pm0.5
		}
		set_window
		RELOCATE ( $gx1 $(int(0.5*($gy2 + 32767))) )
		label Frame: $frames  Colour: $5
		if(dimen(l) > 1) {
		   label   if $6
		}
		#
classification 2 # Show the classification fraction as a function of
		# magnitude for colour $1, binned according to vector $2
		define t local
		foreach t (star galaxy) {
		   set y$t local
		   set y$t=mag$1 if(type == '$t')
		   set y$t = histogram(y$t:$2)
		}
		if(0) {
		   lim ($2) ({0 1})
		   box
		   hi ($2) (ystar/(ystar + ygalaxy)) if(ystar+ygalaxy > 0)
		   yla Fraction of Galaxies
		} else {
		   lim ($2) (ystar concat ygalaxy concat ystar + ygalaxy)
		   box
		   hi ($2) (ystar + ygalaxy)		   
		   ctype cyan lt 1
		   hi ($2) ystar
		   ctype magenta lt 2
		   hi ($2) ygalaxy
		   ctype 0 lt 0
		}
		#
plots	01	#
		if(!$?1) { define 1 0 }
		echo $(sum(l)) objects

		if(is_vector(re)) {
		   set pt=re<0.5/0.28?41:40  ptype pt
		}
		DEVICE x11 -dev 0
		if(!$1) { ERASE }
		LprismType3d 10 100 l
		prismLines3d 10 100
		DEVICE x11 -dev 1
		if(!$1) { ERASE }
		prismLines 90 0
		LprismType 90 0 l
		ptype 4 1
		#
classify_params 035	# Usage: $0 param1 param2 colour [set-limits] [logical]
		if(!$?4) { define 4 0 }
		if($4) {
		   lim psfMag2 ($1$3-$2$3)
		}

		set ll local
		if($?5) {
		   set ll=($5)
		} else {
		   set ll=1 + 0*psfMag$3
		}
		box
		poi psfMag$3 ($1$3-$2$3) if(ll)
		#xla psf magnitude
		yla $1$3 - $2$3
		#
goo		# Plot the result of a gdb "mods 1" command
		#
		lim cell (mod0 concat mod1 concat mod2 concat mod3)
		box con cell data 
		do i=0,3{
		   if($i < 2) { ctype cyan } else { ctype blue }
		   con cell mod$i rel $(cell[9]) $(mod$i[9]) putl 5 $i
		}
		ctype magenta con cell mod ctype 0 error_y cell mod sig
project	7	# Project the points($1,$2,$3) onto the x-z plane, from the
		# position (t,p) == ($6,$7), resulting in the points($4,$5)
		# (see viewpoint for definition of theta and phi)
		set _y_p local
		rotate $1 $2 $3  $4 _y_p $5  $6 $7
		#
rotate	8	# Rotate the points($1,$2,$3) through (theta,phi) == ($7,$8),
		# resulting in the points($4,$5,$6)
		# (see viewpoint for definition of theta and phi)
		set cxx local  set cxx = cosd($8)
		set cxy local  set cxy = -sind($8)
		set cyx local  set cyx = sind($8)*cosd($7)
		set cyy local  set cyy = cosd($8)*cosd($7)
		set cyz local  set cyz = -sind($7)
		set czx local  set czx = sind($8)*sind($7)
		set czy local  set czy = cosd($8)*sind($7)
		set czz local  set czz = cosd($7)

		set $4 = cxx*$1 + cxy*$2
		set $5 = cyx*$1 + cyy*$2 + cyz*$3
		set $6 = czx*$1 + czy*$2 + czz*$3
		#
maki 12		# Calculate the Maki classifier for all objects, threshold $1
		# plot if $?2
		define i local
		local set fiber_sum = 0
		local set psf_sum = 0
		do i=0,$NFILTER-1 {
		   set fiber_sum = fiber_sum + fiberCounts$i
		   set psf_sum = psf_sum + psfCounts$i
		}
		if($?2) {
		   lim (asinh(fiber_sum)) (asinh(psf_sum) - asinh(fiber_sum))
		   lim 5 15 -0.5 0.5
		   box
		   poi (asinh(fiber_sum)) (asinh(psf_sum) - asinh(fiber_sum))
		   lt 1 rel $fx1 $1 draw $fx2 $1 lt 0
		}

		set $0 = (asinh(psf_sum) - asinh(fiber_sum) > $1) ? \
		    'star' : 'galaxy'
classify_galaxies 2	# Calculate the RHL galaxy classifier, 
		# based on type vector $1, using a threshold $2
		define i local  local set exp_L=0 local set deV_L = 0
		do i=0,$NFILTER-1 {
		   set exp_L = exp_L + exp_L$i
		   set deV_L = deV_L + deV_L$i
		}
		set exp_L = exp_L/$NFILTER
		set deV_L = deV_L/$NFILTER
		#
		# Reconsider star/galaxy
		#
		if(0) {
		   echo $(modelMag2) $(-2.5*lg(0.875)) $(psfMag2)
		   local set $1 = (modelMag2 - 2.5*lg(0.875) < psfMag2) \
		    ? 'galaxy' : 'star'
		} else {if(0) {
		   set x local  set dx local
		   local set alpha=0.10
		   local set cg = -10 + 0*modelMag$i
		   do i=0,$NFILTER-1 {
		      set x =  psfMag$i - modelMag$i
		      if(0) {
		         set dx = sqrt(psfMagErr$i**2 + modelMagErr$i**2 + 1e-10)
		      } else {
		         set dx = psfMagErr$i + 1e-5
		      }
		      local set cg$i = (x - alpha)/dx
		      set cg = (cg$i > cg) ? cg$i : cg
		   }
		   #VERBOSE 4
		   local set $1 = ($1 != 'star' && $1 != 'galaxy') ? $1 :\
		       (cg > 2) ? 'galaxy' : 'star'
		   VERBOSE 0
		   #print { type psfMag2 cg0 cg1 cg2 cg3 cg4 }
		} else { if(0) {
		   local set alpha=0.5
		   local define band 2
		   local set re = \
		        (exp_L$band < deV_L$band) ? r_exp$band : r_deV$band
		   #VERBOSE 4
		   local set $1 = ($1 != 'star' && $1 != 'galaxy') ? $1 :\
		       (re > alpha/0.400) ? 'galaxy' : 'star'
		   VERBOSE 0
		}}}
		#
		# classify galaxies
		#
		set $0 = ($1 == 'galaxy') ? \
		    (deV_L > $2*exp_L ? 'deV' : \
		    (exp_L > $2*deV_L ? 'exp' : 'galaxy')) : $1
classify_R50 12	# plot classification for band $1; only if $2 if $?2
		local define b $1
		if($?2) {
		   local set l = $2
		} else {
		   local set l = 1
		}
		photoL $b
		lim 13.5 24 ({1 6}) box
		foreach t {star galaxy deV exp} {	
		   ctype_from_type $t
		   poi petroMag$b petroR50$b if(l && type=='$t')
		}
		ct 0
		xla petro$b
		yla petro_{R50}$b
		RELOCATE ( 3000 32000 )
		label Frame: $frames ($rhl_val)
		if(dimen(l) > 1) {
		   label "  "$2
		}
		
colours_3d 69	# Usage: colours theta phi type1 type2 band1 band2 [logical] [plot_type]
		# plot a CM diagram
		# If $8 == "id" use IDs as ptype; If $8 == "SG", plot stars
		# and galaxies in colour;
		# if it's "star", "galaxy", "deV", or "exp" only plot that type
		# if $?9, it's the name of an expansion vector
		photoL $5
		if($?7) {
		   local set l = $7
		} else {
		   local set l = 1
		}
		if(dimen(l) == 1) {
		   set l = l + 0*$3Mag$5
		}

		if(!$?8) {
		   define 8 SG
		}
		if('$8' == 'star' || \
		    '$8' == 'galaxy' || '$8' == 'deV' || '$8' == 'exp') {
		   set l = l && type=='$8'
		   define 8 SG
		}
		#
		# set 3-d positions of objects
		#
		local set x = $3Mag$4 - $3Mag$5
		local set y = $3Mag$5 - $3Mag$6
		local set z = $3Mag$5
		local define xlab <$3$4 - $3$5>
		local define ylab <$3$5 - $3$6>
		local define zlab $3$5
		#
		# Choose limits
		#
		set x_p local set y_p local set z_p local

		local set xl=x sort {xl} 
		local define x0 ( xl[int(dimen(xl)/2)] )
		local set yl=y sort {yl} 
		local define y0 ( yl[int(dimen(yl)/2)] )

		set xl = $x0 + 3*{ 1  1 -1 -1  1  1  1 -1 -1  1}/2
		set yl = $y0 + 3*{-1  1  1 -1 -1 -1  1  1 -1 -1}/2
		local set zl = (24+13)/2 + (24-13)*{-1 -1 -1 -1 -1  1  1  1  1  1}/2
		rotate xl yl zl  x_p y_p z_p  $1 $2

		lim x_p z_p
		lim 0 0 $fy2 $fy1

		lt 1
		con x_p z_p
		rel $(x_p[1]) $(z_p[1])  draw $(x_p[6]) $(z_p[6])
		rel $(x_p[2]) $(z_p[2])  draw $(x_p[7]) $(z_p[7])
		rel $(x_p[3]) $(z_p[3])  draw $(x_p[8]) $(z_p[8])
		lt 0

		rel $((x_p[0]+x_p[3])/2)  $((z_p[5]+z_p[8])/2)
		putl 5 $xlab
		rel $((x_p[2]+x_p[3])/2)  $((z_p[7]+z_p[8])/2)
		putl 5 $ylab
		rel $((x_p[3]+x_p[8])/2)  $((z_p[3]+z_p[8])/2)
		putl 5 $zlab
		#
		# Project onto the x-z plane
		#
		project x y z  x_p z_p   $1 $2

		local define expand |
		if($?9) {
		   local set ee = $9
		} else {
		   local set ee = 1
		}
		if(dimen(ee) == 1) {
		   set ee = ee + 0*x
		}

		if('$8' == 'SG') {
		   set _ee local
		   foreach v {star galaxy deV exp} {
		      ctype_from_type $v
		      set _ee = ee if(l && type == '$v')
		      if(dimen(_ee) > 0) {
		         expand _ee
		         poi x_p z_p if(l && type == '$v')
		      }
		   }
		   ct 0
		} else {
		   if('$8' == 'id') {
		      local set pt = id if(l) 
		      ptype pt
		   }
		   set ee = ee if(l)  expand ee
		   poi x_p z_p if(l)
		   pt 4 1
		}

		set ee = <$expand>
		expand $(ee)

		RELOCATE ( 3000 31500 )
		label \-1Run:Column:Frame: $run:$frames
		if(dimen(l) > 1) {
		   label   if \-1$7
		}
		
