Dump, Fri May 12 17:35:39 1995

Variables:

coeffs        Ucoeffs
NFILTER         5
OBJ1_CANONICAL_CENTER	0
OBJ1_BRIGHT	1
OBJ1_EDGE	2
OBJ1_BLENDED	3
OBJ1_CHILD	4
OBJ1_PEAKCENTER	5
OBJ1_NODEBLEND	6
OBJ1_NOPROFILE	7
OBJ1_NOPETRO	8
OBJ1_MANYPETRO	9
OBJ1_NOPETRO_BIG	10
OBJ1_DEBLEND_TOO_MANY_PEAKS	11
OBJ1_CR	12
OBJ1_MANYR50	13
OBJ1_MANYR90	14
OBJ1_BAD_RADIAL	15
OBJ1_INCOMPLETE_PROFILE	16
OBJ1_INTERP	17
OBJ1_SATUR	18
OBJ1_NOTCHECKED	19
OBJ1_SUBTRACTED	20
OBJ1_NOSTOKES	21
OBJ1_BADSKY     22
OBJ1_PETROFAINT 23
OBJ1_TOO_LARGE  24
OBJ1_DEBLENDED_AS_PSF 25
OBJ1_DEBLEND_PRUNED 26
OBJ1_ELLIPFAINT	27
OBJ1_BINNED1	28
OBJ1_BINNED2	29
OBJ1_BINNED4	30
OBJ1_MOVED      31
OBJ2_DEBLENDED_AS_MOVING 0
OBJ2_NODEBLEND_MOVING    1
OBJ2_TOO_FEW_DETECTIONS  2
OBJ2_BAD_MOVING_FIT      3
OBJ2_STATIONARY          4
OBJ2_PEAKS_TOO_CLOSE     5
OBJ2_BINNED_CENTER       6
OBJ2_LOCAL_EDGE          7
OBJ2_BAD_COUNTS_ERROR    8
OBJ2_BAD_MOVING_FIT_CHILD 9
OBJ2_DEBLEND_UNASSIGNED_FLUX 10
OBJ2_SATUR_CENTER        11
OBJ2_INTERP_CENTER       12
OBJ2_DEBLENDED_AT_EDGE   13
OBJ2_DEBLEND_NOPEAK      14
OBJ2_PSF_FLUX_INTERP	 15
OBJ2_TOO_FEW_GOOD_DETECTIONS 16
OBJ2_CENTER_OFF_AIMAGE 17
OBJ2_DEBLEND_DEGENERATE 18
OBJ2_BRIGHTEST_GALAXY_CHILD 19
OBJ2_CANONICAL_BAND 20
OBJ2_AMOMENT_UNWEIGHTED 21
OBJ2_AMOMENT_SHIFT 22
OBJ2_AMOMENT_MAXITER 23
OBJ2_MAYBE_CR 24
OBJ2_MAYBE_EGHOST 25
OBJ2_NOTCHECKED_CENTER 26
OBJ2_HAS_SATUR_DN 27
OBJ2_DEBLEND_PEEPHOLE 28
OBJ2_NOT_DEBLENDED_AS_PSF 29
PSP_FIELD_UNKNOWN	-1
PSP_FIELD_OK		0
PSP_FIELD_ABORTED	1
PSP_FIELD_MISSING	2
PSP_FIELD_NOPSF		3
PSP_FIELD_PSF11		4
PSP_FIELD_PSF22		5
UNK	      0
CR	      1
DEFECT	      2
GALAXY	      3
GHOST	      4
KNOWNOBJ      5
STAR	      6
TRAIL	      7
SKY	      8
asinh_b       31

Vectors:

bands : dimension = 5.s
help = Names of bands
u
g
r
i
z

Macros:

asinh	1	# return the inverse sinh of $1
		set $0 = ($1 >= 0) ? \
		ln($1 + sqrt(1 + $1**2)) : -ln(-$1 + sqrt(1 + $1**2))
		#
gett	13	# read a photo output table for field $1; if $?2 read
		# only a subset of usual vectors; if $?3 read catids
		define field $1  define frame $field
		define file local
		define i local
		do i=2, 3 {
		   if(!$?$i) { define $i 0 }
		}
		local define quick $2

		if('$fpObjc' == 'tsObj') {
		   if(0) {
		      local define field0 11
		      local define hdu ($1 - $field0 + 1)
		      define i 0
		      while {$i < 5} {
		         define file "$!photodata/$!fpObjc-$!run-$!col-$!i-$(sprintf('%04d',$field0)).fit"
		         echo $file
		         !ls $file > /dev/null 2>&1 ; test -f $file
		         if ($exit_status == 0) {
		            break
		         }
		         define i ($i + 1)
		      }
		   } else {
		      define file "$!photodata/$!fpObjc-$!run-$!col-$!rerun-$!(sprintf('%04d',$!1)).fit"
		      define hdu 1
		   }
		} else {		
		   define file "$!photodata/$!fpObjc-$!run-$!col-$(sprintf('%04d',$1)).fit"
		   !ls $file > /dev/null 2>&1 # give automounter a chance
		   local define hdu 1
		}

		local define keep_aper_counts 0 # don't convert aperCounts to mags

		get $file $hdu $quick
		set i=0,dimen(id)-1

		define f local
 		if('$fpObjc' != 'tsObj') {
		   #set flux20 local
		   gett_calib $1
		   set flux20 = readFlux20($1)

		   define file "$!photodata/$!fpObjc-$!run-$!col-$!(sprintf('%04d',$!1))-TST.fit"
		   !ls $file > /dev/null 2>&1 ; test -f $file
		   if ($exit_status == 0) {
		      table "$!file"
		      #read table { obj1_id[0-4] npeak[0-4] true_type }
		      #read table { fracDeVBand[0-4] fracDeVBandErr[0-4] fracDeV[0-4] fracDeVErr[0-4] }
		      #read table { cmodelCounts[0-4] cmodelCountsErr[0-4] }
		      read table { row_bias[0-4] col_bias[0-4] }
		   }
		   set frac local
		   do i = 0, $NFILTER - 1 {
		      set frac = (fracPSF$i < 0) ? 0 : (fracPSF$i > 1) ? 1 : fracPSF$i
		      set cmodelCounts$i = frac*deVCounts$i + (1 - frac)*expCounts$i
		      set cmodelCountsErr$i = \
		          sqrt((frac*deVCountsErr$i)**2 + \
		          ((1 - frac)*expCountsErr$i)**2)
		   }
		}
		#
		# calculate/set magnitudes
		#
		#set frac local
		do i = 0, $NFILTER - 1 {
		   set frac = (fracPSF$i < 0) ? 0 : (fracPSF$i > 1) ? 1 : fracPSF$i
		   set cmodelCounts$i = frac*deVCounts$i + (1 - frac)*expCounts$i
		   set cmodelCountsErr$i = \
		       sqrt((frac*deVCountsErr$i)**2 + \
		       ((1 - frac)*expCountsErr$i)**2)
		}

		define mag_types {fiber fiber2 petro psf model cmodel aper exp deV}

		if('$fpObjc' == 'tsObj') {
		   overload exp 1
		   foreach v <$mag_types> {
		      do i=0,$NFILTER-1 {
		         set $v""Mag$i = $v""Counts$i
		         DELETE $v""Counts$i

		         if('$v' == 'psf' || '$v' == 'model') {
		            set $v""MagErr$i = $v""CountsErr$i
		            DELETE $v""CountsErr$i
		         }
		      }
		   }
		   overload exp 0

		   set psp_status = 0   # should read from tsField file

		   return
		}

		if($run >= 100000 && flux20[0] <= 1000 || \
		    sum(flux20) == 1000*dimen(flux20)) {
		   if(1) {
		      do i=0,$NFILTER-1 {
		         local define f$i ( sprintf('%.0f', flux20[$i]) )
		      }
		      echo RHL IS FAKING FLUX20: \
		      Old flux20 ==  $f0 $f1 $f2 $f3 $f4
		   }
		   #
		   # Run 756
		   #
		   if(1 && $run >= 100000) {
		      set flux20 = 1e4 + 0*flux20
		   } else {
		      if($col == 1) {
		         set flux20 = { 1357.25 3300.25 2190.35 1505.28 319.559 }
		      } else { if($col == 2) {
		         set flux20 = { 1309.22 2773.16 2161.56 1286.26 312.701 }
		      } else { if($col == 3) {
		         set flux20 = { 1353.19 2888.34 2271.66 1607.31 277.037 }
		      } else { if($col == 4) {
		         set flux20 = { 1336.89 2865.81 2139.08 1568.84 269.3 }
		      } else { if($col == 5) {
		         set flux20 = { 1453.39 2631.91 2159.19 1500.22 436.774 }
		      } else {
		         set flux20 = { 897.046 2755.53 2053.8 1469.94 293.597 }
		      }}}}}
		   }
		}

		if(0) {
		   local set cmax = -SORT(-objc_colc)
		   if(cmax < 1024) {
		      echo Binned scan; scaling flux20
		      set flux20 = flux20/2.8
		   }
		}

		if(flux20[0] < 20) {
		   echo RHL XXX Coadds flux20 = $(flux20[0])
		   set flux20 = flux20*1000
		   local define asinh_b 10
		}

		#echo RHL XXX Coadds\n set flux20 = flux20*1000

		local set mu0 = 20 + 2.5*lg(flux20) - 2.5*lg($asinh_b)

		do i=0,$NFILTER-1 {
		   overload exp 1
		   foreach f <$mag_types> {
		      set $f""Mag$i = \
		          mu0[$i] - 2.5/ln(10)*asinh($f""Counts$i/(2*$asinh_b))
		   }
		   foreach f (sky skyErr) {
		      set $f""$i = $f""$i*1000/flux20[$i]
		   }
		   overload exp 0
		   if(!$quick) {
		      set psfMagErr$i = sqrt((2.5/ln(10)*psfCountsErr$i)**2/\
		       (4*$asinh_b**2 + psfCounts$i**2))
		      set modelMagErr$i = sqrt((2.5/ln(10)*modelCountsErr$i)**2/\
		           (4*$asinh_b**2 + psfCounts$i**2))
		    }

		    if($keep_aper_counts) {
		       if($i == 0) {
		          echo Changing aperMag back to aperCounts
		       }
		       set aperMag$i = aperCounts$i # RHL
		    }
		}

		if(0) {                 # apply/remove model ap correction?
		   define file "$!photodata/fpFieldStat-$!run-$!col-$!(sprintf('%04d',$field)).fit"
		   table "$!file"
		   do i=0,4 { set model_ap_correction$i local }
		   read table {model_ap_correction[0-4]}
		   if(0) {
		      echo Applying model aperture correction from $file
		      local define op "+ "
		   } else {
		      echo Removing model aperture correction from $file
		      local define op "- "
		   }

		   do i=0,$NFILTER-1 {
		      echo set modelMag$i = modelMag$i $op""$(2.5*lg(model_ap_correction$i))
		      set modelMag$i = modelMag$i $op 2.5*lg(model_ap_correction$i)
		   }
		}
		
		if($3) {
		   gett_catid $1
		}
		#
get	13	# read data from a table $1, HDU $2 (default: 1). If $?3&&$3,
		# only read a subset of the usual vectors
		if(1 || '$1' != '$data_file') {
		   table "$!1"
		}
		if($?2) {
		   table $2
		}
		if(!$?3) {
		   define 3 0
		}
		local define quick $3
		
		define FILTERS IMAGE
		set filters local set filters=<$FILTERS>
		define NFILTER (dimen(filters))

		define i local  define j local
		do i=0,4 { 
		   set counts_model$i local 
		   set counts_modelErr$i local 
		   set counts_exp$i local 
		   set counts_deV$i local 
		}
		#
		# Prepare to calculate aperture magnitudes
		#
		if(!$?naper) {
		   local define naper 7 # number of apertures to use
		} else {
		   if($naper < 0) {
		      local define _naper $naper
		      local define naper $_naper  define naper (-$naper)
		      define keep_aper_counts 1
		   }
		}
		local set radii = profileRadii()
		local set area0 = pi*radii[0]**2
		do i=1,$naper-1 {
		   local set area$i = pi*(radii[$i]**2 - radii[$i-1]**2)
		}

		do i = 0, $NFILTER-1 {
		   set nprof$i local
		   do j=0, 14 {
		      set profMean$(15*$i + $j) local
		   }
		}

		#read table { nchild }
		if($quick) {
		   read table { id objc_type objc_rowc objc_colc type[0-4] \
		       objc_flags objc_flags2 flags[0-4] flags2[0-4] \
		       fiberCounts[0-4] fiber2Counts[0-4] petroCounts[0-4] psfCounts[0-4] \
		       nprof[0-4] profMean[0-74] \
		    }
		    read table { \
		           exp_lnL[0-4] deV_lnL[0-4] star_lnL[0-4] \
		        counts_model[0-4] counts_deV[0-4] counts_exp[0-4] fracPSF[0-4] \
		        petroRad[0-4] petroR50[0-4] \
		    }
		    read table { \
		           M_rr_cc_psf[0-4] M_rr_cc[0-4] \
		    }
		} else {
		   read table { id parent objc_type objc_rowc objc_colc type[0-4] objc_flags objc_flags2 flags[0-4] flags2[0-4] \
		       rowc[0-4] rowcErr[0-4] colc[0-4] colcErr[0-4] \
		       petroRad[0-4] petroRadErr[0-4] petroR50[0-4] petroR90[0-4] \
		       fiberCounts[0-4] fiber2Counts[0-4] petroCounts[0-4] psfCounts[0-4] \
		       petroCountsErr[0-4] psfCountsErr[0-4] \
		       petroR50Err[0-4] petroR90Err[0-4] \
		    }
		    if(1) {
		       read table { \
		           M_rr_cc_psf[0-4] M_rr_cc[0-4] M_rr_ccErr[0-4] \
		           M_e1[0-4] M_e2[0-4] M_e1e1Err[0-4] M_e1e2Err[0-4] M_e2e2Err[0-4] \
		       }
		    }
		    read table { texture[0-4] }

		    read table { fracPSF[0-4] rowv colv rowvErr colvErr nprof[0-4] profMean[0-74] }
		    read table { sky[0-4] skyErr[0-4] }
		    read table { \
		           exp_lnL[0-4] deV_lnL[0-4] star_lnL[0-4] \
		        counts_model[0-4] counts_modelErr[0-4] \
		           counts_exp[0-4] ab_exp[0-4] r_exp[0-4] phi_exp[0-4] \
		           counts_deV[0-4] ab_deV[0-4] r_deV[0-4] phi_deV[0-4] \
		           ab_expErr[0-4] r_expErr[0-4] ab_deVErr[0-4] r_deVErr[0-4] \
		           counts_expErr[0-4] counts_deVErr[0-4] M_rr_cc_psf[0-4] M_rr_cc[0-4]\
		           iso_a[0-4] iso_b[0-4] fracPSF[0-4] \
		        }
		}
		do i=0,$NFILTER-1 {
		   set modelCounts$i = counts_model$i
		   set aperCounts$i = 0
		   do j=0,$naper-1 {
		      set aperCounts$i = aperCounts$i + \
		       (($j >= nprof$i) ? 0 : area$j*profMean$(15*$i + $j))
		   }
		   set deVCounts$i = counts_deV$i 
		   set expCounts$i = counts_exp$i
		   if(!$quick) {
		      set deVCountsErr$i = counts_deVErr$i 
		      set expCountsErr$i = counts_expErr$i
		      set modelCountsErr$i = counts_modelErr$i 
		      set iso_ab$i = iso_b$i/iso_a$i
		   }

		   overload exp 0
		   set deV_L$i = exp((deV_lnL$i > -80) ? deV_lnL$i : -80)
		   set exp_L$i = exp((exp_lnL$i > -80) ? exp_lnL$i : -80)
		   set star_L$i = exp((star_lnL$i > -80) ? star_lnL$i : -80)
		}
		set bands={u g r i z}
		set objc_type=type_to_name(objc_type)
		do i=0,$NFILTER-1 {
		   set type$i=type_to_name(type$i)
		}
		set saturated = is_set(objc_flags,$OBJ1_SATUR)
		set detected = 0
		do i=0,$NFILTER-1 {
		   set ndetect = \
		       ((flags$i & (2**$OBJ1_BINNED1 | 2**$OBJ1_BINNED2 | 2**$OBJ1_BINNED4)) ? 1 : 0)
		   set detected = detected + ndetect
		   #echo RHL $i $(sum(ndetect)) $(sum(detected)/dimen(detected))
		}
		set ndetect = detected
		set detected = (ndetect > 0) ? 1 : 0
		set blended = is_set(objc_flags,$OBJ1_BLENDED)		       
		set cr = is_set(flags2,$OBJ1_CR) || \
		    (detected == 1 && is_set(flags2, $OBJ2_MAYBE_CR))
		set edge = is_set(objc_flags,$OBJ1_EDGE)
		set nopetro = is_set(flags2,$OBJ1_NOPETRO)
		set good=!is_set(objc_flags,$OBJ1_BRIGHT)&&detected&&!edge&&!saturated
		if(!$quick) {
		   define v local
		   define vi local
		   foreach v {deV exp} {
		      do i=0,$NFILTER-1 {
		         define vi $v""$i
		         set U_$vi = (1 - ab_$vi)/(1 + ab_$vi)*sin(2*pi*phi_$vi/180)
		         set Q_$vi = (1 - ab_$vi)/(1 + ab_$vi)*cos(2*pi*phi_$vi/180)
		         set U_$v""Err""$i = 0*good
		         set Q_$v""Err""$i = 0*good
		      }
		   }
		}
gett_calib 1	# read the calibration for field $1
		define i local
		do i=0,4 {
		   set flux20$i local
		}

		local define file "$!calibdata/$!col/psField-$!run-$!col-$(sprintf('%04d', $!1)).fit"
		get_calib $file

get_calib 12	# read the calibration tables from file $1 for field $1
		!ls $1 > /dev/null 2>&1

		table "$!1"
		if(!$?2) {              # a psField file
		   local define FILTERS IMAGE
		   table $(dimen(<$FILTERS>) + 1)
		   set dimen(psp_status) = 0
		   read table { psp_status  }

		   if(dimen(psp_status) == 0) {
		      echo "Reading field `status' instead"
		      set status local
		      read table { status  }
		      set psp_status = status
		   }
		   table $(dimen(<$FILTERS>) + 2)
		   read table { flux20 }
		} else {
		   define i local
		   do i=0,4 {
		      set flux20$i local
		   }
		   set field local
		   
		   read table { field psp_status flux20[0-4] }

		   set flux20=0*do(0,4) - 1e10
		   set tmp local
		   do i=0,4 {
		      set tmp = flux20$i if(field == $2)
		      set flux20[$i,$i] = tmp
		   }
		   set psp_status = psp_status if(field == $2)
		}
readFlux20 1    # Return a flux20 vector from calibPhotom for the specified field (assumes you ran set_run)
		# Usage: readFlux20 field
		local define field $1

		local define tablefile "$!photodata/../../nfcalib/calibPhotom-$!run-$!col.fits"
		!test -f $tablefile
		if ($exit_status != 0) {
		   set $0 = flux20
		} else {
		   if (1) {
		      echo "Not using $!tablefile"
		      set $0 = flux20
		      return
		   }

		   table "$!tablefile"
		   define i local
		   do i=1,4 {
		      set nMgyPerCount$i local
		   }
		   set field local
		   read table { field nMgyPerCount[0-4] }

		   set dimen($0) = 5
		   do i=0, 4 {
		      set nMgyPerCount$i = nMgyPerCount$i if(field == $field)
		      set $0[$i] = 10/nMgyPerCount$i
		   }
		}
get_catid 2	# read a catalogue cross-id file $1 for frame $2
		table "$!1"
		set field local set id local set keymag local
		read table {field id keytype keymag}
		set tid=id if(field==$2)
		set keytype=keytype if(field==$2)
		set keymag=keymag if(field==$2)
		set type = (keymag == 0 && keytype == 0) ? 'unknown' : \
		    keytype == 0 ? 'star' : keytype < 4 ? 'deV' : 'exp'
		#
gett_catid 1	# read a catalogue cross-id file for frame $1
		get_catid tsCOBJC-$run-$!col.fit $1
		#
get_profs 1	# read profile data from a table $1. Note that you'll
		# need to use the obj_profile macro to get the profiles
		# for a given object
		table "$!1"
		read table { nprof[0-4] profMean[0-74] profErr[0-74] }
		#
get_psFang 1	# Read a set of positions from a psFang file
		# Usage: get_psFang_band filename
		define v local
		overload row 1
		foreach v (row col) {
		   set $v""Centroid local  set $v""CentroidErr local
		   set mid$v local
		}
		set sscStatus local  set statusFit local  set peak local

		local set hdu = {4 6 2 3 5} # HDUs for u...z
		table "$!1"
		define i local
		do i=0,4 {
		   table $(hdu[$i])

		   read table { midrow midcol peak sscStatus statusFit \
		         rowCentroid rowCentroidErr colCentroid colCentroidErr}
		   #
		   # Jeff Munn says:
		   #
		   set astromGood$i = statusFit == 0 \
		       && (sscStatus == 0 || sscStatus == 4)
		   foreach v (row col) {
		      set ps_$v""c$i = $v""Centroid
		      set ps_$v""cErr$i = $v""CentroidErr
		   }
		   set ps_id$i = string(midrow) + '-' + string(midcol) + \
		       '-' + sprintf('%.0f', peak)
		}
read_psFang 4	# Read a set of positions from a psFang file
		# Usage: get_psFang_band root run column field
		# (the `run' may specify a rerun number, e.g. 745:3)

		local define root "$!1"
		define run "$!2"
		define camCol $3
		define field $4

		define rerun -1
		if(index('$run', ':') >= 0) {
		   define rerun   ( substr('$run', index('$run', ':') + 1, 0) )
		   define run ( substr('$run', 0, index('$run', ':')) )
		}

		set_run $root $run $camCol 0 $rerun

		local define file "$!psFangdata/psFang-$!run-$!col-$!(sprintf('%04d', $!field)).fit"

		get_psFang $file
		#
profileRadii	# Return photo's profile radii
		set $0 = \
		{0.564190 1.692569 2.585442 4.406462 7.506054 \
		11.576202 18.584032 28.551561 45.503910 70.510155 \
		110.530769 172.493530 269.519104 420.510529 652.500061}
		#
gett_profs 01	# read a photo output profiles table for frame $1 (just
		# set profileRadii if !$?1)
		set profileRadii=profileRadii()

		if(!$?1) {
		   return
		}
		define frame $1
		get_profs $!photodata/$!fpObjc-$!run-$!col-$(sprintf('%04d',$1)).fit
		#
get_fieldstat 1	# read the fieldstat file from file $1
		table "$!1"
		define FILTERS IMAGE set filters local set filters=<$FILTERS>
		define NFILTER (dimen(filters))
		read table { nobjects nchild nstars ngals ncr[0-4] \
		       rowOffset[0-4] colOffset[0-4] \
		       U[0-4] Q[0-4] median_psfColor[0-4] }
		#
gett_fieldstat 2 # read the fieldstat files from frames $1..$2
		define i local  define j local  define f local
		local set field = $1,$2
		local set vecs0 = {nobjects nchild nstars ngals}
		local set vecs = {rowOffset colOffset ncr U Q median_psfColor}
		foreach f vecs0 {
		   local set _$f = field
		}
		foreach f vecs {
		   do j=0,4 {
		      local set _$f""$j = field
		   }
		}
		#
		# read data from files
		#
		do i=$1, $2 {
		   get_fieldstat \
		    $!photodata/fpFieldStat-$!run-$!col-$(sprintf('%04d',$i)).fit

		   foreach f vecs0 {
		      set _$f[$i-$1] = $f
		   }
		   foreach f vecs {
		      do j=0,4 {
		         set _$f""$j[$i-$1] = $f""$j
		      }
		   }
		}
		#
		# repack e.g. _rowOffset into rowOffset
		#
		foreach f vecs0 {
		   set $f = _$f
		}
		foreach f vecs {
		   do j=0,4 {
		      set $f""$j = _$f""$j
		   }
		}
		#
fieldstatConcat #
		define rerun -1
		define run "$!2"
		if(index('$run', ':') >= 0) {
		   define rerun   ( substr('$run', index('$run', ':') + 1, 0) )
		   define run ( substr('$run', 0, index('$run', ':')) )
		   if(index('$rerun', ':') >= 0) {
		      define tsObj ( substr('$rerun', index('$rerun', ':') + 1, 0))
		      if('$tsObj' == 'tsObj' || '$tsObj' == 'ts') {
		         define tsObj 1
		      }
		      define rerun ( substr('$rerun', 0, index('$rerun', ':')) )
		   }
		}

		echo Run $run Rerun $rerun

colour_offsets 47 # Usage: colour_offsets band magtype1 magtype2 logical [lim] [map] [err]
		# If lim is specified, y limits are in +- $lim
		# If map is specified, plot x as map[field] not field
		# if err is specified, use it as a per-field y-error 
		local define f $1

		photoL $f

		overload exp 1
		local define t1 $2
		local define t2 $3
		local set l = $4
		if(!$?5) { define 5 0 }
		local define lim $5
		if(!$?6) { define 6 field }
		local define map $6
		if(!$?7) { define 7 none }
		local define err $7

 		local set fields = field  sort {fields} set fields=uniq(fields)

		local set dm = fields  set _dm local
		define i local
		do i = 0, dimen(fields) - 1 {
		   set _dm = $t1""Mag$f - $t2""Mag$f if(field==fields[$i] && l)
		   
		   if(dimen(_dm) == 0) {
		      set dm[$i] = -10000
		   } else {
		      sort {_dm}
		      set dm[$i] = _dm[int(dimen(_dm)/2)]
		   }
		}

		if('$map' != 'field') {
		   local set x = $map[fields]
		} else {
		   local set x = fields
		}

		if($lim >= 0) {
		   if($lim > 0) {
		      lim 0 0 (<-$lim $lim>)
		   } else {
		      lim 0 0 (dm < -1000 ? 0 : dm)
		   }
		   lim x 0 0
		   box
		   xla $(quote_TeX('$6'))
		   yla $t1""Mag$f - $t2""Mag$f
		   toplabel $4
		}

		if('$err' != 'none') {
		   local set ddm = $err[fields]
		   error_y x dm ddm
		   pt 4 3
		}
		poi x dm
		ptype 4 1

		set _dm = $t1""Mag$f - $t2""Mag$f if(l)
		sort {_dm} set _dm = _dm[int(dimen(_dm)/2)]
		lt 1 rel $fx1 $(_dm) draw $fx2 $(_dm) lt 0

		#echo $t1""Mag$f - $t2""Mag$f : $4\n print { fields dm }

obj_profile 4	#set $3 and $4 to be profMean and profErr for object $1, band $2
		set dimen($3)=$(nprof$2[$1]) set $4=$3
		define i local
		do i=0,dimen($3)-1 {
		   set $3[$i] = profMean$(15*$2 + $i)[$1]
		   set $4[$i] = profErr$(15*$2 + $i)[$1]
		}
		set radii = profileRadii() if(do(1,15) <= dimen($3))
		#
type_to_name 1	# convert a numerical type to a string
		set $0 = ($1 == $STAR ? 'star' : \
		($1 == $GALAXY ? 'galaxy' : \
		($1 == $SKY ? 'sky' : \
		($1 == $CR ? 'cr' : \
		($1 == $KNOWNOBJ ? 'knownobj' : 'unknown')))))

reject_cr 1	# classify cosmic rays based on single band detection and MAYBE_CR
		local set ndetect = 0
		define i local
		do i=0,$NFILTER-1 {
		   set ndetect = ndetect + \
		    (flags$i & (2**$OBJ1_BINNED1 | 2**$OBJ1_BINNED2 | 2**$OBJ1_BINNED4)) 
		}
		set $0 = (ndetect == 1 && (objc_flags2 & 2**$OBJ2_MAYBE_CR)) ? \
		    'cr' : $1
name_to_type 1	# convert a string type to numerical
		set $0 = ($1 == 'star' ? $STAR : \
		($1 == 'galaxy' ? $GALAXY : \
		($1 == 'sky' ? $SKY : \
		($1 == 'cr' ? $CR : \
		($1 == 'knownobj' ? $KNOWNOBJ : $UNK)))))
get_fields 133	# concat $3...vectors for all fields $1..$2
		# e.g. get_fields 102 110 rowc colc psfCounts
		# in addition, id is automatically set
		if(!$?photodata) {
		   echo "Please set $photodata, $run, and $col (e.g. with set_run)"
		   return
		}

		define j local  define i local  define v local  
		#
		# See how many objects we'll have to read
		#		
		local set naxis2 = do($1,$2)
		define NAXIS2 local define file local
		do i=$1, $2 {
		   define file "$!photodata/$!fpObjc-$!run-$!col-$!(sprintf('%04d',$!i)).fit"
 		   !test -f $file
		   if ($exit_status == 0) {
		      table "$!file"
		      define NAXIS2 IMAGE
		   } else {
		      define NAXIS2 0
		   }
		   set naxis2[$i-$1] = $NAXIS2

		}
		local define FILTERS IMAGE  
		define NFILTER (dimen(<$FILTERS>))

		local set nobj = sum(naxis2)

		local define vecs "id"
		foreach v ($3) {
		   if(index('$v', 'objc_') == 0) {
		      set _$v local  set dimen(_$v) = $(nobj)
		   } else {
		      do j=0,4 {
		         set _$v""$j local  set dimen(_$v""$j) = $(nobj)
		      }
		   }

		   if(index('$v', 'Mag') >= 0) {
		      define type ( substr('$v', 0, index('$v', 'Mag')) )
		      define v $type""Counts

		      do j=0,4 {
		         set $v""$j local
		      }
		   }

		   if(index('$v', '$vecs') < 0) { # not already on list
		      if(index('$v', 'objc_') == 0) {
		         define vecs "$!vecs $!v"
		      } else {
		         define vecs "$!vecs $!v[0-4]"
		      }
		   }		   
		}
		#
		# Read the flux20 values
		#
		set field local
		do i=0,4 {
		   set flux20$i local
		}
		table "$!photodata/psCB-$!run-$!col.fit"
		read table { field flux20[0-4] }
		set f20 local  set mu0 local

		local define read_table "read table { $!vecs }" # i.e. eval it
		
		set ID local set dimen(ID) = $(nobj).s
		local define base 0
		define magtype local       # type of magnitude desired
		set i local
		do i=$1, $2 {
		   if(naxis2[$i-$1] > 0) {
		      table "$!photodata/$!fpObjc-$!run-$!col-$!(sprintf('%04d',$!i)).fit"
		      $read_table

		      set i = $base,$base + dimen(id) - 1
		      define base ($base + dimen(id))
		      
		      set ID[i] = sprintf('%03d:',$i) + string(id)
		      foreach v ($3) {
		         if(index('$v', 'Mag') < 0) {
		            define magtype DELETE
		         } else {
		            define magtype ( substr('$v', 0, index('$v', 'Mag')) )
		         }
		         do j=0,4 {
		            if($?magtype) {
		               set f20 = flux20$j if(field == $i)
		               set mu0 = 20 + 2.5*lg(f20) - 2.5*lg($asinh_b)
		               set $magtype""Mag$j = \
		                   mu0 - 2.5/ln(10)*asinh($magtype""Counts$j/(2*$asinh_b))
 		               
		            }
		            
		            if(!is_vector(_$v""$j)) {
		               if($j == 0) {
		                  set _$v[i] = $v
		               }
		            } else {
		               set _$v""$j[i] = $v""$j
		            }
		         }
		      }
		   }
		}

		foreach v ($3) {
		   if(is_vector(_$v)) {
		      if(index('$v', 'type') >= 0) {
		         set $v = type_to_name(_$v)
		      } else {
		         set $v = _$v
		      }
		   } else {
		      do j=0,4 {
		         if(index('$v', 'type') >= 0) {
		            set $v""$j = type_to_name(_$v""$j)
		         } else {
		            set $v""$j = _$v""$j
		         }
		      }
		   }
		}
		set id = ID
		#
print_vals 012	# print $1 and flags for all bands; $2 is a logical expression
		# (note that $1 may be "vec1 vec2 ...")
		define fmt local define vecs local
		if($?2) {
		   set logical local set logical = $2
		}
		define fmt "%-3d"
		define vecs "id"
		if($?2) {
		   set id local set id = id if(logical)
		}
		define i local define j local
		foreach j ($('$1')) {
		   do i=0,$NFILTER-1 {
		      if($?2) {
		         set $j""$i local set $j""$i = $j""$i if(logical)
		      }
		      define fmt <$fmt %7.2f>
		      define vecs <$vecs $j""$i>
		   }
		}
		do i=0,$NFILTER-1 {
		   if($?2) {
		      set flags$i local set flags$i = flags$i if(logical)
		   }
		   define fmt <$fmt 0x%03x>
		   define vecs <$vecs flags$i>
		}
		echo print '$fmt\\n' < $vecs >
		print '$fmt\\n' < $vecs >
read_offsets 1  # read the file $1 produced by photo's calc_canonical_positions
		# command
		DATA "$!1"
		local define ncol read 4 3
		read { id 1 objc_flags 2 objc_flags2 3 type 4 }
		define i local
		do i=0,$ncol-1 {
		   read < objc_flags$i $(8*$i+5) objc_flags2$i $(8*$i+6) \
		    psfMag$i $(8*$i+7) modelMag$i $(8*$i+8) \
		    rowc$i $(8*$i+9) rowcErr$i $(8*$i+10) \
		    colc$i $(8*$i+11) colcErr$i $(8*$i+12) >
		 }

photo_offsets 23 # show offsets between bands. $1: colc, rowc, mu, or nu
		# $2: max offset to show. If ($?3 && $3 < 0), display as histogram
		# Only objects detected in the band are shown; the small cyan
		# points are not detected in the canonical (r) band
		if(!$?3) {
		   define 3 0
		}
		if($3 < 0) {
		   set x local set h1 local set h2 local
		   set x=-$2,$2,$2/20
		} else {
		   lim id -$2 $2
		}
		define i local
		set dr local
		if($3 > 0) {
		   set ddr local set ii local  set err local
		}
		do i=0,dimen(bands)-1 {
		   set dr = $1$i - $12
		   window 1 -$(dimen(bands)) 1 $($i+1) 
		   if($3 < 0) {
		      set h1=dr if(is_set(flags$i,$OBJ1_BINNED1) && \
		                   is_set(flags2,$OBJ1_BINNED1))
		      set h1=histogram(h1:x)
		      set h2=dr if(is_set(flags$i,$OBJ1_BINNED1) && \
		                   !is_set(flags2,$OBJ1_BINNED1))
		      set h2=histogram(h2:x)
		      lim x (h1 concat h2)
		      ctype cyan
		      histogram x h2
		      ctype default
		      histogram x h1
		   } else {
		      if($3 == 0) {
		         poi id dr if(is_set(flags$i,$OBJ1_BINNED1) && \
		                      is_set(flags2,$OBJ1_BINNED1))
		      } else {
		         set ddr=dr if(is_set(flags$i,$OBJ1_BINNED1) && \
		                       is_set(flags2,$OBJ1_BINNED1))
		         set ii=id if(is_set(flags$i,$OBJ1_BINNED1) && \
		                      is_set(flags2,$OBJ1_BINNED1))
		         set err=sqrt($1Err$i**2 + $1Err$2**2)\
		                       if(is_set(flags$i,$OBJ1_BINNED1) && \
		                          is_set(flags2,$OBJ1_BINNED1))
		         error_y ii ddr err
		      }
		      ctype cyan ptype 1 1
		      poi id dr if(is_set(flags$i,$OBJ1_BINNED1) && \
		                   !is_set(flags2,$OBJ1_BINNED1))
		      ctype default ptype 4 1
		   }
		   box $($i==0 ? 1 : 0) 2
		   RELOCATE ( $($gx2-500) $($gy2-500) )
		   putl 1 $(bands[$i])
		}
		window 1 1 1 1
		if($3 < 0) {
		   xla $1 - $1_{r'}
		} else {
		   xla ID
		   toplabel Offsets of $1 from r' values
		}
		#
ids	1	# print the OBJECT1s ids associated with an OBJC_IO id
		set ii local
		set ii=0,dimen(id) - 1
		set ii=ii if(id == $1)
		define str local  define str "$!1: "
		do 1=0,$NFILTER - 1 {
		   define str <$str $(obj1_id$1[ii])>
		}
		echo $str
		#
rids	1	# print the id for the OBJC_IO containing OBJECT1 id $1
		set ii local
		define i local
		do i=0,$NFILTER - 1 {
		   set ii=id if(obj1_id$i == $1)
		   if(dimen(ii) != 0) {
		      echo $1 is the $(bands[$i]) object1 in objc_io $(ii)
		      return
		   }
		}
		echo object1 $1 is not present in any object
		#
read_profs 12	# read radial profiles from file $1, as written with
		# photo's p_profs command.  If $2 is present, it's the name
		# of a vector with sky corrections in the NFILTER bands
		da $1
		if($?2) {
		   local define dsky "$!2"
		} else {
		   local define dsky "none"
		}
		

		define id read 1 2
		define NFILTER read 1 4
		define i local  define v local

		do i=0,$NFILTER - 1 {
		   read <r$i 2 mean$i $(3+2*$i) sig$i $(3+2*$i+1)>
		   set r$i = r$i if(mean$i < 1e30)
		   foreach v (mean sig) {
		      set $v""$i = $v""$i if($v""$i < 1e30)
		   }
		   if('$dsky' != 'none') {
		      set mean$i = mean$i + $dsky[$i]
		   }
		}
sinh10	11	# like sinh, but ~ 10**x for large x
		set $0=10**$1 - 10**-$1
asinh10	11	# like asinh, but ~ lg for large I
		set $0 = ($1 >= 0) ? \
		  lg(($1 + sqrt(4 + $1**2))/2) : -lg((-$1 + sqrt(4 + $1**2))/2)
		#
profs	13	# plot profiles in all colours. 
		# If $1&0x1,  don't reset x-limits
		# if $1&0x2   normalise profiles
		# if $1&0x4   overplot radial profiles
		# if $1&0x8   Cumulate profile before plotting
		# if $1&0x10  Don't change y-limits
		# if $?2, take the asinh first; if $2 == 2, use log_10,
		#         if $2 == 3, take sinh first
		# if $?3, use ltype $3
		# (see read_profs for reading the data from a file produced
		# by photo's p_profs command)
		if(!$?1) {
		   local define flags 0
		} else { 
		   local define flags ($1)
		}
		if(!$?NFILTER) { define NFILTER 1 }

		local define nolim_x     ( $flags & 0x1 )
		local define normalise   ( $flags & 0x2 )
		local define overplot    ( $flags & 0x4 )
		local define cumulate    ( $flags & 0x8 )
		local define nolim_y     ( $flags & 0x10 )

		if(!$?2) { define 2 0 }
		define i local
		local define x_gutter 0.4  local define y_gutter 0.4
		set r local set p local set em local set ep local

		define v local
		foreach v (r mean sig) {
		   do i=0, $NFILTER - 1 {
		      local set $v""$i = $v""$i
		   }
		}

		if($NFILTER == 1 && !is_vector(mean0)) {
		   foreach i (r mean sig) {
		      set $i""0 = $i
		   }
		}

		if($cumulate) {
		   set area local
		   do i=0, $NFILTER - 1 {
		      set area = pi*r$i**2
		      set area = (area concat 0) - (0 concat area) \
		          if(do(0,dimen(area)) < dimen(area))

		      set mean$i = cumulate(area*mean$i)
		      set sig$i = sqrt(mean$i)
		   }
		}

		if(!$nolim_x) {
		   set dimen(r) = 0
		   do i=0,$NFILTER - 1 {
		      if($2) {
		         if($2 == 1) {
		            set r = r concat asinh10(r$i)
		         } else {
		            set r = r concat lg(r$i)
		         }
		      } else {
		         set r = r concat r$i
		      }
		   }
		   lim r 0 0
		}

		define norm local
		if($normalise && !$nolim_y) {
		   if(!$2) {
		      lim 0 0 (0 concat 1)
		   } else {
		      if($cumulate) {
		         lim 0 0 \
		          (lg(mean$($NFILTER>2?2:$NFILTER-1)[0]) concat -0.1)
		      } else {
		         lim 0 0 \
		          (-lg(mean$($NFILTER>2?2:$NFILTER-1)[0]) concat 1)
		      }
		   }
		}

		do i=0,$NFILTER - 1 {
		   if(!$overplot && $NFILTER > 1) {
		      if($NFILTER < 3) {
		         set_window $NFILTER 1 $i
		      } else { if($NFILTER == 4) {
		         set_window 2 2 $i
		      } else {
		         set_window 3 2 $i
		      }}
		   }

		   if($2) {
		      if($2 == 1) {
		         set r = asinh10(r$i)
		         set p = asinh10(mean$i)
		      } else { if($2 == 2) {
		         set r = lg(r$i)
		         set p = lg(mean$i)
		      } else {
		         set p = sinh10(mean$i)
		      }}
		      if($2 < 3) {
		         set em = mean$i - sig$i
		         set em = asinh10(mean$i) - asinh10(em)
		         set ep = mean$i + sig$i
		         set ep = asinh10(ep) - asinh10(mean$i)
		      }

		      if(!$normalise && !$nolim_y) {
		         if($2 > 1) {
		            lim 0 0 (lg(mean$i >0 ? mean$i : 10))
		         } else {
		            lim 0 0 (0 concat asinh10(mean$i))
		         }
		      }
		   } else {
		      set r = r$i
		      set p = mean$i
		      set em = sig$i
		      set ep = sig$i

		      if(!$normalise && !$nolim_y) {
		         lim 0 0 mean$i
		      }
		   }
		   box

		   if($normalise) {
		      if($cumulate) {
		         define norm (p[5])
		         set p = 2 + p - $norm
		      } else {
		         if($2 == 0) {
		            define norm (1/p[0])
		            set p = p*$norm
		            set em=em*$norm
		            set ep=ep*$norm
		         } else {
		            define norm (p[1])
		            set p = 0.9 + p - $norm
		         }
		      }
		   }
		   
		   if($?3) {
		      ltype $3
		      #ctype $($3==1?'cyan':$3==2?'magenta':'default')
		      ctype_band $i
		   } else {
		      ctype_band $i
		   }
		   con r p
		   angle 45 poi r p angle 0
		   errorbar r p ep 2
		   errorbar r p em 4
		   ltype 0 ctype default
		   if($NFILTER > 1) {
		      rel $fx2 $fy2 putl 1 \move-1500-1500{\2$(bands[$i])'}
		   }
		}
		if($NFILTER > 1) {
		   window 1 1 1 1

		   if($2) {
		      if($2 > 1) {
		         xla \2lg(r)
		         yla \2lg(Mean Profile) (Object ID $id)
		      } else {
		         xla \2sinh{\-110}^{-1}(r)
		         yla \2sinh{\-110}^{-1}(Mean Profile) (Object ID $id)
		      }
		   } else {
		      xla r
		      yla Mean profile (Object ID $id)
		   }
		}
		set_window
		#
cprofs	13	# plot colour profiles in all colours. 
		# If $1&10,  don't reset x-limits
		# if $1&1000 overplot radial profiles
		# if $?2, take the asinh first; if $2 > 1, use log_10
		# if $?3, use ltype $3
		# (see read_profs for reading the data from a file produced
		# by photo's p_profs command)
		if(!$?NFILTER) { define NFILTER 1 }

		local define nolimits ( $1%10 )
		local define normalise ( int($1/10)%10 )
		local define overplot ( int($1/100)%10 )

		if(!$?2) { define 2 0 }
		define i local
		local define x_gutter 0.6  local define y_gutter 0.4
		set em local set ep local

		if($NFILTER == 1) {
		   echo You need at least 2 bands to plot colours
		   return
		}
		if($NFILTER == 1 && !is_vector(mean0)) {
		   foreach i (r mean sig) {
		      local set $i""0 = $i
		   }
		}

		local define d 0   set r local
		do i=0,$NFILTER - 1 {
		   if(dimen(mean$i) > $d) {
		      define d ( dimen(mean$i) )
		      set r = r$i
		   }
		}

		do i=0,$NFILTER - 1 {
		   local set mean$i = mean$i
		   set mean$i[dimen(mean$i),$d-1] = mean$i[dimen(mean$i)-1]
		}
		if($2) {
		   if($2 > 1) {
		      set r = lg(r)
		   } else {
		      set r = asinh10(r)
		   }
		}

		define norm local
		do i=0,$NFILTER - 2 {
		   set p$i = mean$i/mean$($i+1)
		   if($2) {
		      if($2 > 1) {
		         set p$i = 2.5*lg(p$i)
		      } else {
		         set p$i = 2.5*asinh10(p$i)
		      }
		   }
		   
		   if($normalise) {
		      define norm (1/p$i[0])
		      set p$i = p$i*$norm
		   }

		   local set l$i = \
		       do(1,dimen(p$i)) <= dimen(r$i) && mean$i > 0 && mean$($i+1) > 0

		}

		if($overplot) {
		   set tmp local  set dimen(tmp) = 0
		   do i=0,$NFILTER - 2 {
		      set tmp = tmp concat (l$i ? p$i : p$i[0])
		   }
		   lim 0 0 tmp
		   bo
		}

		do i=0,$NFILTER - 2 {
		   if(!$overplot && $NFILTER > 4) {
		      if($NFILTER == 5) {
		         set_window 2 2 $i
		      } else {
		         set_window 3 1 $i
		      }
		   }

		   if(!$overplot) {
		      lim r (l$i ? p$i : p$i[0])
		      bo
		   }
		   
		   if($?3) {
		      ltype $3
		      ctype $($3==1?'cyan':$3==2?'magenta':'default')
		   } else {
		      ctype_band $i
		   }
		   hi r p$i if(l$i)
		   angle 45 poi r p$i if(l$i) angle 0
		   ltype 0 ctype default
		   if($NFILTER > 1) {
		      rel $fx1 $fy2
		      putl 2 \move300-1500{\0$(bands[$i])' - $(bands[$i+1])'}
		   }
		}
		if($NFILTER > 1) {
		   window 1 1 1 1

		   if($2) {
		      if($2 > 1) {
		         xla \2sinh{\-110}^{-1}(r)
		         yla \2sinh{\-110}^{-1}(colour) (Object ID $id)
		      } else {
		         xla \2lg(r)
		         yla \2lg(colour) (Object ID $id)
		      }
		   } else {
		      xla r
		      yla $1 (Object ID $id)
		   }
		}
		#
stokes	23	# plot the Stokes parameters for band $1 in += $2; only
		# plot objects for which $3 is true. If $2 is < 0, draw
		# error bars.
		local define band ( substr('$1', -1, 1) )
		photoL $band

		if($2 > 0) {
		   local define no_errors 1
		} else {
		   local define no_errors 0
		   define 2 ( -$2 )
		}
		if(!$?3) { define 3 1 }
		lim (<-$2 $2>) (<-$2 $2>)
		set x local set y local set dx local set dy local
		if(!$?1) {
		   set x=Q set y=U
		   if(!$no_errors) {
		      set dx=QErr set dy=UErr
		   }
		} else {
		   set x=Q$1 set y=U$1
		   if(!$no_errors) {
		      set dx=QErr$1 set dy=UErr$1
		   }
		}
		local set l=($3) && good && !blended
		local define ex $expand
		local set ee=0*l + (dimen(l) > 1000 ? 0.5 : 1)
		expand ee

		define i local
		foreach i ( x y ) {
		   set $i = $i if(l)
		   if(!$no_errors) {
		      set d$i = d$i if(l)
		   }
		}
		#
		if($?no_errors) {
		   poi x y
		} else {
		   error_x x y dx
		   error_y x y dy
		}
		ct 0
		#
		if($fx2 > sqrt(0.5)) {
		   circle 0 0 1
		} else {
		}

		expand $ex

		if(1) {
		   if(0) {
		      relocate 0 0
		      ctype red
		      local define expand | expand 5
		      dot
		      expand $expand
		      ctype 0
		   } else {
		      ltype 1
		      rel -1 0 draw 1 0
		      rel 0 -1 draw 0 1
		      ltype 0
		   }
		}
		if(!$?_ix) {
		   local define _ix 1
		}
		if(!$?_iy) {
		   local define _iy 1
		}

		box
 		if($_iy == 1) { xla \1\rm Q }
		if($_ix == 1) { yla \1\rm U }
		if($?_nx) {
		   if($_nx == 1 && $_ny == 1) {
		      rel $(-0.9*$2) (0.9*$2) label $(sum(l)) Objects
		   }
		}
		#
stokesType 23	# plot the Stokes parameters for band $1 in += $2; only
		# plot objects for which $3 is true. If $2 is < 0, draw
		# error bars.
		#
		# Colour code object types
		#
		if(!$?3) { define 3 1 }
		
		set_window -2 -2
		stokes $1 $2 $3
		
		set_window -2 -2
		foreach t {exp galaxy deV star} {
		   ctype_from_type $t
		   stokes $1 $2 type=='$t'&&$3
		}
		
		set_window -2 -2
		ctype_from_type star
		stokes $1 $2 type=='star'&&$3
		
		set_window -2 -2
		foreach t {exp galaxy deV} {
		   ctype_from_type $t
		   stokes $1 $2 type=='$t'&&$3
		}
		set_window
		ctype 0
magsType 45	# plot the difference between $1 and $2 magnitudes
		# for band $3 in 0 += $4; only plot objects for which $5 is true.
		# If $5 is omitted, it's taken to be true
		#
		# Colour code object types
		#
		if(!$?5) { define 5 1 }
		photoL $3

		local set diff = $1""Mag$3 - $2""Mag$3
		lim ({14 24}) -$4 $4 box
		ctype blue poi $1""Mag$3 diff  if(type=='exp'&&$5)
		ctype magenta poi $1""Mag$3 diff  if(type=='galaxy'&&$5)
		ctype red poi $1""Mag$3 diff  if(type=='deV'&&$5)
		ctype green poi $1""Mag$3 diff  if(type=='star'&&$5)
		ctype yellow poi $1""Mag$3 diff  if(type=='tiny'&&$5)
		ctype 0
		rel $fx1 0 draw $fx2 0

		xla $1 Magnitude 
		yla ($1 - $2) Magnitude
		toplabel Band $3
		#
stokes_image 1	# convert a set of stokes parameters to an image, binsize $1
		define ds $1
		local define n (int(1.1/$ds + 0.5))
		local define N (2*$n + 1)
		image($N,$N) -1.1 1.1 -1.1 1.1
		define missing_data -100
		set image[*,*] = $missing_data
		#
		define x local
		set foo local
		local set QQ=do(-$n,$n)*1.1/$n
		local set edge=(flags & ((2**$EDGE) | (2**$NOPETRO)))

		do x=-$n,$n {
		   set foo=Q if(abs(U*$n/1.1 - 0.0 - $x) < 0.5 && !edge)
		   set image[*,$n+$x] = histogram(foo : QQ)
		}
		#
		lim QQ QQ 
		#lim -.5 .5 -.5 .5
		box
		if(0) {
		   ltype 1 levels ({0 1}) contour ltype 0
		   levels 10**(0.5+do(0,10,.5)) contour
		} else {
		   levels do(0,1000,2.5) contour
		}
		ctype cyan circle 0 0 1 ct 0
show_flags 01	# See how many objects have flag bits set (for colour $1 if set)
		define i local define str local
		echo $(dimen(flags0)) objects
		foreach i (\
		    CANONICAL_CENTER \
		    BRIGHT \
		    EDGE \
		    BLENDED \
		    CHILD \
		    PEAKCENTER \
		    NODEBLEND \
		    NOPROFILE \
		    NOPETRO \
		    MANYPETRO \
		    NOPETRO_BIG \
		    DEBLEND_TOO_MANY_PEAKS \
		    CR \
		    MANYR50 \
		    MANYR90 \
		    BAD_RADIAL \
		    INCOMPLETE_PROFILE \
		    INTERP \
		    SATUR \
		    NOTCHECKED \
		    SUBTRACTED \
		    NOSTOKES \
		    BADSKY \
		    PETROFAINT \
		    TOO_LARGE \
		    DEBLENDED_AS_PSF \
		    DEBLEND_PRUNED \
		    ELLIPFAINT \
		    BINNED1 \
		    BINNED2 \
		    BINNED4 \
		    ) {
		       define str ( sprintf('%-15s','$i') )
		       if($?1) {
		          define str <$str $( sprintf('%4d',sum(is_set(flags$1,$$i))) )>
		       } else {
		          do 1=0,$NFILTER-1 {
		             define str <$str $( sprintf('%4d',sum(is_set(flags$1,$$i))) )>
		          }
		       }
		       echo $str
		}
		#
flags2 11	# Explain a flags2 value $1 (if -ve, an object ID number)
		define i local define str local
		set x local set x=$1
		if(x < 0) {
		   set x = flags0 if(id == -x)
		}
		foreach i ( \
		    MEASURED \
		    GROWN_MERGED \
		    HAS_CENTER \
		    ) {
		       if(is_set(x,OBJ2_$$i)) {
		          echo $i
		       }
		    }
		#
family	1	# Tell me about object $1's family
		#
		local define parent ( sum(id == $1 ? parent : 0) )
		if($parent == -1) { # list children
		   local set foo=id if(parent == $1)
		   if(dimen(foo) == 0) {
		      echo Object $1 has no family
		      return
		   }
		   local define print_noheader 1
		   print 'Object $1\'s children are ' {}
		   print '%d ' { foo }
		} else {
		   echo Object $1's parent is $parent
		}
		#
read_petroRadii 2 # Read object $2 from file $1 written with dump_petroRadii,
		# setting vectors "flag", "psfCounts", and "rP"
		# (and also rr for the radii)
		da $1
		set id local  read { id 1 }
		local set i=1,dimen(id) set i=i if(id == $2)
		if(dimen(i) == 0) {
		   echo Object $2 is not present in $1
		   return
		}

		read row rP $(i).s
		set flag=atof(rP[1])
		set psfCounts=atof(rP[2])

		set i=1,dimen(rP) set rP=atof(rP) if(i > 3)

		if(dimen(rP) == 0) {
		   set ngood = 0
		} else {
		   set i=1,dimen(rP)
		   set rPErr = abs(rP) if(i%2 == 0)
		   set rP = rP if(i%2 == 1)
		   set ngood = rP[0]
		   set rP[0] = 1
		   set rPErr[0] = 0
		}

		read row rr 1.s
		set i=1,dimen(rr) set rr=atof(rr) if(i > 3 && i < dimen(rP)+4)
		#
show_petroRadii 15 # Show the petroRadii from file $1, with errors if $2,
		# (optionally, nx and ny and n_tot)
		if(!$?2) { define 2 0 } # plot errors? == 2, plot range
		if(!$?3) { define 3 8 } # x-number of windows
		if(!$?4) { define 4 7 } # y-number of windows
		if($?5) {               # max. number of profiles
		   if($5 < 0) { define 5 ( $3*$4 ) }
		} else {
		   define 5 -1
		}
		lim ({0 2}) ({-.2 1.2})
		set id local
		da $1 lin 0 0 read id 1

		set_window
		define id local  local define nplot 0
		local define i 0 
		while {$i < dimen(id)} {
		   define id ( id[$i] )
		   read_petroRadii $1 $id
		
		   if(1) {              # accept these too. Hack.
		      if(flag & (2**$NOPETRO)) {
		         set flag = flag - 2**$NOPETRO
		      }
		      if(psfCounts < 10000) {
		         set flag = flag | 2**$NOPETRO
		      }
		   }
		   
		   if($id < 0 || dimen(rP) > 2 && \
		       !(flag&(2**$BLENDED)) && \
		       (1 || !(flag&(2**$PETROFAINT))) && \
		       (0 || (flag&(2**$NOPETRO)))) {
		      set_window -$3 -$4

		      if($id < 0) {
		         box 1 2 3 3
		      } else {
		         box 3 3 3 3
		      }

		      set rr=asinh10(rr)

		      lt 1 ct cyan
		      rel $fx1 0.25 draw $fx2 0.25
		      rel $fx1 0 draw $fx2 0
		      lt 0 ct 0

		      rel $($fx1 + 0.6*($fx2 - $fx1)) $($fy1 + 0.9*($fy2-$fy1))
		      if($id < 0) {
		         putl 6 \-1\ti ID
		      } else {
		         putl 6 \-1\ti $id
		      }
		      
		      rel $($fx1 + 0.6*($fx2 - $fx1)) $($fy1 + 0.7*($fy2-$fy1))
		      if($id < 0) {
		         putl 6 \-1\ti Cts
		      } else {
		         if(psfCounts < 1e6) {
		            putl 6 \-1\ti $(sprintf('%.0f',psfCounts))
		         } else {
		            putl 6 \-1\ti $(sprintf('%.0g',psfCounts))
		         }
		      }

		      if($id >= 0) {
		         if($2 == 1) {
		            error_y rr rP rPErr
		            errorbar rr rP (asinh10(1.25*sinh10(rr)) - rr) 1
		            errorbar rr rP (rr - asinh10(0.8*sinh10(rr))) 3
		         } else { if($2 == 2) {
		            ctype red
		            con rr (rP+rPErr) #if(do(1,dimen(rP)) <= ngood + 1)
		            con rr (rP-rPErr) #if(do(1,dimen(rP)) <= ngood + 1)
		            ctype 0
		         }}
		
		         ctype magenta
		         con rr rP
		         ctype 0
		         if(index('$1', 'rad.n') >= 0) {
		            ctype green
		         }
		         con rr rP if(do(1,dimen(rP)) <= ngood + 1)
		         ct 0
		      }		      
		      define nplot ($nplot + 1)
		   }
		   if($nplot == $5) {break}
		   define i ($i + 1)
		}
		set_window
		xla asinh_{10}{r}
		yla \2\sc R
		toplabel File: $1
		#
tinterp    01	# interpolate a taut spline, given k[], c0[] etc.
		# if $?1, draw complete cubics (not just between proper knots)
		define i local
		do i=0,dimen(k)-2 {
		   set rr=-4,4,.01
		   set v=c0[$i]+rr*(c1[$i]+rr*(c2[$i]/2 + rr*c3[$i]/6))
		   set rr=k[$i] + rr
		   if($?1) {
		      con rr v 
		   } else {
		      if($i == 0) {
		         con rr v if(rr < k[$i + 1])
		      } else {
		         con rr v if(rr >= k[$i] && rr < k[$i + 1])
		      }
		   }
		}
petro	34	# calculate Petrosian radius for a profile $2 (at points $1),
		# errors $3.
		# if $?4 && $4, use asinh10(r)
		if(!$?4) { define 4 0 }
		set r local set area local
		set cp local set cs2 local
		set area=pi*$1**2 set area = (area concat 0) - (0 concat area)
		set cp=1,dimen($1)+1
		set r=$1 concat 0 if(cp <= dimen($2))
		set area = area if(cp <= dimen($2))
		set cp=$2*area  set cp =cumulate(cp)/(pi*r**2)
		set cs2=$3**2*area  set cs2 = cumulate(cs2)/(pi*r**2)
		set rat = r == 0 ? 1 : $2/cp
		set erat = rat*sqrt(r == 0 ? 1 : ($3/$1)**2 + cs2/cp**2)
		if($4) {
		   set r=asinh10(r)
		}
		lim r (0 concat rat) box
		con r rat error_y r rat erat
		print <$1 $2 $3 cp cs2 rat erat area >
		#
errors	25	# read the output file $1 from jpgtests.tcl; we only
		# want failures for parameter $2. Plot it if $?3; if $3 > 1
		# plot percentage error.
		# if $4, suppress labels
		# If $5 == -1, join corresponding points,
		#    $5 < -1, colour points with flags != 0
		#    $5 > 0, draw a histogram in +-$5
		if(!$?3) { define 3 0 }
		if(!$?4) { define 4 0 }
		if(!$?5) { define 5 0 }
		da $1
		read { test 1.s param 2.s measured 3 true 4 flags 5}
		foreach 9 { test true measured flags} {
		   set $9 = $9 if(param == '$2')
		}
		if($3) {
		   set itest local set yvar local define ylab local
		   define x local
		   set itest = 1,dimen(test)
		   if($3 == 1) {
		      set yvar = (true - measured)
		      define ylab "True - Measured"
		   } else {
		      if($3 == 2) {
		         set yvar = 100*(true - measured)/true
		         define ylab "(True - Measured)/True (%)"
		      } else {
		         set yvar = 2.5*lg(measured/true)
		         define ylab "Measured/True (magnitudes)"
		      }
		   }
		   if($5 > 0) {         # limits for histogram
		      set itest=-$5,$5,int($5*10)/100
		      set yvar=histogram(yvar:itest)
		      lim itest yvar
		      box
		      histogram itest yvar
		      if(!$4) {
		         xla $ylab
		         toplabel $2
		      }
		      return
		   }
		   lim itest yvar
		   if(!$4) {
		      box 0 2
		   } else {             # box interacts with window
		      box
		   }
		   poi itest yvar
		   if($5 == -1) {       # draw points with flags != 0 in cyan
		      ctype cyan poi itest yvar if(flags) ctype default
		   }
		   if($5 < -1) {         # connect pairs
		      set log local
		      set log = index(test,'_c') == -1 ? 1 : 0
		      set yv1 local set yv2 local
		      set itest1 local set itest2 local
		      set yv1 = yvar if(log)
		      set yv2 = yvar if(!log)
		      if(dimen(yv1) != dimen(yv2)) {
		         echo I cannot match tests (using _c); not connecting pairs
		      } else {
		         set itest1 = itest if(log)
		         set itest2 = itest if(!log)
		         pairs itest1 yv1 itest2 yv2
		      }
		   }
		   if(!$4) {
		      define ptype local define ptype | 
		      define angle local define angle |
		      set yvar=string(test)
		      set yvar = index(yvar,'.fits') == -1 ? yvar : \
		          substr(yvar,0,index(yvar,'.fits'))
		      set yvar=quote_TeX(yvar)
		      ptype yvar angle 90
		      define x ($fy1-($gy1 - 1500)*($fy2-$fy1)/($gy2-$gy1))
		      poi itest (0*itest+$x)
		      ptype $ptype angle $angle
		      yla $ylab
		      toplabel $2
		   }
		}
		#
prof_errors 3	# run errors for radial points $1[$2]--$1[$3]
		define i local
		do i=$2,$3 {
		   set_window -2 -3 $($i-$2) 
		   errors errors.out $1<$i> 2 1 1
		}
		window 1 1 1 1
bar		# Provide somewhere to paste a set of spline coeffs from gdb
		echo Please paste the output of a printS command in gdb
		macro foo delete macro edit foo  foo
		lim (-1 concat k) (c0 > -1 ? c0 : -1)
		box 
		expand $($expand*2) poi k c0 expand $($expand/2)
		tinterp
psfs	2	# Draw PSF parameters for colours $1 -- $2
		define i local define j local
		set scr local set prof local
		local set vecs={wid sigmax1 sigmay1 sigmax2 sigmay2 b \
		       app_correction nstar }
		do j=$1, $2 {
		   local set psf_app_correction$j =  app_correction$j
		}

		do i=1,2 {
		   set scr=0
		   do j=$1, $2 {
		      set scr=scr + sum(psf_sigmax$i""$j - psf_sigmay$i""$j)
		   }
		   if(scr == 0) {
		      set vecs=vecs if(vecs != 'sigmay$i')
		   }
		}
		#
		# Measure FWHM of composite profile
		#
		do i=$1,$2 {
		   local set psf_wid$i=psf_b$i
		   do j=0,dimen(psf_b$i) - 1 {
		      set scr=0,4,.005
     set prof=exp(-(scr/psf_sigmax1$i[$j])**2/2-(scr/psf_sigmay1$i[$j])**2/2) + \
     psf_b$i[$j]*(exp(-(scr/psf_sigmax2$i[$j])**2/2-(scr/psf_sigmay2$i[$j])**2/2))
		      set psf_wid$i[$j] = sqrt(sum(scr**3*prof)/sum(scr*prof))
		      set prof=(prof/prof[0] - 0.5)**2
		      sort { prof scr }
		      set psf_wid$i[$j] = 2*sqrt(2)*scr[0]/(2*sqrt(2*ln(2)))
		   }
		}
		#
		#range 0 0.3
		define v local
		foreach v vecs {
		   set_window 1 -$(dimen(vecs))
		   yla $v
		   set scr=psf_$v""$1
		   do i=$1+1,$2 {
		      set scr=scr concat psf_$v""$i
		   }
		   if('$v' == 'nstar') { set scr = scr concat 0 }
		   lim field scr box
		   do i=$1,$2 {
		      ctype_band $i
		      con field psf_$v""$i
		      ctype 0
		   }
		}
		range 0 0
		set_window
		xla Field
		#
astrom_offsets 02 # Plot the {row,col}Offsets from the fieldstat files;
		# connect points if $?1; correct for frame delays if $2
		# use gett_fieldstat field1 field2 first
		if(!$?1) { define 1 0 }
		if(!$?2) { define 2 0 }
		if($1) {
		   local define plot_type "connect "
		} else {
		   local define plot_type "points "
		}

		if($2) {
		   local set dframe = {0 4 -4 -2 2}
		} else {
		   local set dframe = {0 0 0 0 0}
		}

		local define y_gutter 0.8
		define v local  define i local
		foreach v {row col} {
		   local set y$v = 0
		   do i=0,$NFILTER-1 {
		      set y$v = y$v concat 400*$v""Offset$i
		   }
		}
		   
		do i=0,$NFILTER-1 {
		   window 1 -2 1 1
		   foreach v {row col} {
		      if($i == 0) {
		         lim 0 1 0 1 rel .9 .9 putl 1 $v
		      }
		      lim (field[0] + dframe concat field concat field[dimen(field)-1] + dframe) y$v 
		      box
		      ctype_band $i
		      if(sum($v""Offset$i == 0.0) != dimen(field)) {
		         $plot_type (field + dframe[$i]) (400*$v""Offset$i)
		      }
		      ctype 0
		      window 1 -2 1 2
		   }
		}
		window 1 1 1 1
		if($2) {
		   xla Frame
		} else {
		   xla Field
		}
		yla Offset (mas)
		#
app_corrections 2 # plot aperture corrections for colours $1..$2
		lim field 0.94 1.09 
		define i local
		do i=$1,$2 {
		   set_window 1 -$($2 - $1 + 2)
		   box
		   ctype_band $i
		   con field app_correction$i 
		   error_y field app_correction$i app_correctionErr$i
		   ct 0
		}

		set_window 1 -$($2 - $1 + 2)
		local set scr=0
		do i=$1,$2 {
		   set scr = scr concat psf_nstar$i
		}
		lim 0 0 scr box
		xla Nstar
		do i=$1,$2 {
		   ctype_band $i
		   con field psf_nstar$i
		}
		ct 0 set_window
		#
coeffs	47	# create and display a coeffs file for annular photometry
		# Usage: coeffs r1 r2 theta1 theta2 [halfbell] [dec] [no-create]
		# if $?5, it's the 1/2 width of the cosbell (-ve for -i)
		# if $?6 && $6, deconvolve
		# if $?7, simply read the model from file $7 (otherwise create
		# it, and write it to "foo")
		#
		define i local
		do i=1,2 {
		   if($$i < 0) { define $i ( sqrt(-$$i/pi) ) }
		}
		if(!$?5) {
		   define 5 10
		}
		if(!$?6) {
		   define 6 0
		}

		if($5 < 0) {
		   define 5 "-i"
		} else {
		   define 5 "-b $!5"
		}
		if($6) {
		   define 6 "-d"
		} else {
		   define 6 " "
		}
		if(!$?7) {
		   echo !src/make_photom_coeffs $5 $6 -e 1e-5 -S foo $1 $2 $3 $4
		   !src/make_photom_coeffs $5 $6 -e 1e-5 -S foo $1 $2 $3 $4
		}

		define file $7
		image "$!file"
		foreach i (NX NY) {
		   local define $i IMAGE
		   define $i ( int($$i/2) ) 
		}
		image "$!file" -$NX $NX -$NY $NY
		
		lim (-$2 concat $2) (-$2 concat $2)
		box
		set l= 0,2,.1 levels l
		contour
		lt 1
		levels -l contour
		lt 0
		set s local
		set s=0 define y local
		set x=-10,10 do y=-10,10{
		   set s=s+sum(image($y,x))
		}
		if(0) {
		   toplabel Sum of coeffs = $(sprintf('%.3f',s)) \
		    ($(sprintf('%.6g',s/(pi*($2**2-$1**2)*($4-$3)/360))) of expected)
		}
		#
show_region  4	# display the regionintegrated over in a coeffs file
		# for annular photometry
		# Usage: show_region r1 r2 theta1 theta2
		ctype cyan
		if($3 == 0 && $4 == 360) {
		   if($2 > 0) {
		      if($1 != 0) {
		         circle 0 0 $1
		      }
		      circle 0 0 $2
		   }
		} else {
		   local set ang= $3*pi/180, $4*pi/180, .01 
		   local set iang=reverse(ang)
		   local set x=$1*cos(ang) concat $2*cos(iang)
		   local set y=$1*sin(ang) concat $2*sin(iang)
		   set x=x concat x[0]  set y=y concat y[0]
		   con x y
		}
		ctype default
		
show_coeffs 46	# display a coeffs file for annular photometry or Stokes params
		# Usage: coeffs r1 r2 theta1 theta2 [halfbell] [xmax]
		# if $?5, it's the 1/2 width of the cosbell
		# if $?6, plot region +-$6
		if(!$?5) { define 5 10 }
		if(!$?6) { define 6 15 }
		if(0) {
		   define file "cells/$!coeffs:$!5:$!1:$!2:$!3:$!4"
		} else {
		   define file afoo
		} 
		image "$!file"
		define i local
		foreach i (NX NY) {
		   local define $i IMAGE
		   define $i ( int($$i/2) ) 
		}
		image "$!file" -$NX $NX -$NY $NY

		2dhistogram 4 1
		local set x=-int($6)-0.25,$6,.5
		window -3 -3 1:2 1:2 
		ctype blue
		Surface 2 -.1 1.1 x x
		ctype cyan
		Surface 1 -.1 1.1 x x
		ctype default
		box3
		#
		local set l=1e-5 concat do(0.1,1.1,.1)
		window -3 -3 1 3 
		lim (<-$6 $6>) (<-$6 $6>) 
		box 1 2
		levels l ctype yellow contour ctype cyan levels -l contour
		ctype default
		#
		RELOCATE ( $($gx2+2000) $(int(0.5*($gy1 + $gy2))) )

		do i=1,2 {
		   if($$i < 0) { define $i ( sprintf('%.2f',sqrt(-$$i/pi)) ) }
		}
		label \smash{Datafile: $coeffs:$5}
		RELOCATE ( $xp $($yp-800) )
		label \smash{R = $1 \line0 700 $2   \theta = $3 \line0 700 $4}
		#
		window 1 1 1 1
		#
pixel 88	# usage: x0 y0 x1 y1 r1 r2 theta1 theta2
		set $0=disk_area($1,$2,$3,$4,$6,$7,$8)-\
		   disk_area($1,$2,$3,$4,$5,$7,$8)
		calc pixel
		#
disk_area 77	# usage: x0 y0 x1 y1 r theta1 theta2
		define 6 ( $6*pi/180 )  define 7 ( $7*pi/180 )
		define i local
		set x local set y local
		set theta local set r local set ind local set theta2 local

		if($6 > $7) { define i 6  define 6 $7  define 7 $i }

		set x=<$1 $3 $3 $1 $1>
		set y=<$2 $2 $4 $4 $2>

		con x y
		set ang local  set iang local   set xx local set yy local
		set ang= $6, $7, .01  set iang=reverse(ang)
		set xx=$5*cos(ang) concat $5*cos(iang)
		set yy=$5*sin(ang) concat $5*sin(iang)
		set xx=xx concat xx[0]  set yy=yy concat yy[0]
		ctype cyan con xx yy  ctype default
		
		ctype magenta
		do i=0,3 {
		   rel 0 0
		   draw x[$i] y[$i]
		}
		ctype default

		set dimen(r) = 4
		do i=0,3 {
		   set ex$i local  set ey$i local  set a$i local
		   set ex$i = <$(x[$i]) $(x[$i+1])> 
		   set ey$i = <$(y[$i]) $(y[$i+1])>
		   set r[$i] = (ex$i[0]+ex$i[1])**2 + (ey$i[0]+ey$i[1])**2
		}
		set ind=0,3
		sort { r ind }

		do i=0,3 {
		   rel ex$i[0]+(ex$i[1]-ex$i[0])/4 ey$i[0]+(ey$i[1]-ey$i[0])/4
		   putl 6 $i
		}

		do i=0,3 {
		   set theta=atan2(ey$i,ex$i)
		   set theta=theta < 0 ? theta + 2*pi : theta
		   set theta=(theta > $7 ? $7 : (theta < $6 ? $6 : theta))
		   if(ex$i[0] == ex$i[1]) {
		      set ey$i=ex$i*tan(theta)
		   } else {
		      set ex$i=(tan(theta) == 0) ? ex$i : ey$i/tan(theta)
		   }

		   set r=sqrt(ex$i**2 + ey$i**2)
		   if((r[0] - $5)*(r[1] - $5) < 0) {
		      if(ex$i[0] == ex$i[1]) {
		         set ey$i = (r < $5) ? ey$i : \
		          (ey$i > 0) ? sqrt($5**2 - ex$i**2) : -sqrt($5**2 - ex$i**2)
		      } else {
		         set ex$i = (r < $5) ? ex$i : \
		          (ex$i > 0) ? sqrt($5**2 - ey$i**2) : -sqrt($5**2 - ey$i**2)
		      }
		      set r=sqrt(ex$i**2 + ey$i**2)
		   }

		   if(1 || r[0] <= $5 && r[1] <= $5) {
		      if(ex$i[0] == ex$i[1]) {
		         set a$i = abs(ex$i[0]*(ey$i[1] - ey$i[0])/2)
		      } else {
		         set a$i = abs(ey$i[0]*(ex$i[1] - ex$i[0])/2)
		      }
		   
		      set theta2 = atan2(ey$i,ex$i)
		      set theta2=theta2 < 0 ? theta2 + 2*pi : theta2

		      if(0) {
		      echo $i $5 $(ex$i[0]) $(ey$i[0])  $(ex$i[1]) $(ey$i[1])\
		          $(theta[0]) $(theta2[0]) $(r[0])\
		          $(theta[1]) $(theta2[1]) $(r[1])\
		          $(sum(r**2*(theta - theta2)))
		      }
		          
		      set a$i = a$i + sum($5**2*abs(theta - theta2))
		   } else {
		      set a$i = 0
		   }
		}
		#print { a0 a1 a2 a3 }
		
		ctype green
		do i=0,3 {
		   rel ex$i[0] ey$i[0] draw ex$i[1] ey$i[1] 
		}
		ctype default

		#print { a0 a1 a2 a3 }
		set $0 = -(a$(ind[0]) + a$(ind[1])) + (a$(ind[2]) + a$(ind[3]))
		#
do_azi	02	# read and plot azimuthal averages from file $1, or 
		# calculate from given cosbell sigma
		define perc 1
		if(!$?1 || $?2) {
		   if($?2) {
		      define cosbell $1
		      define sigma $2
		   } else {
		      define cosbell ?
		      define sigma ?
		   }
		   !do_annuli $cosbell $sigma > azi.out~
		   da azi.out~
		} else {
		   da $1
		}
		set i=0,330,30
		define y_gutter local; define y_gutter 0.7
		do i=0,4 {
		   read row r1 $(1 + 13*$i).s  #print '%s ' { r1 }
		   if(dimen(r1) > 3) {
		      set cosbell=atof(substr(r1[3],8,-1))
		   } else {
		      define 1 ? {Cosbell?}
		      set cosbell=$1
		   }
		   if(dimen(r1) > 2) {
		      set sigma=atof(substr(r1[2],6,-1))
		   } else {
		      set sigma=1
		   }
		   set r2=atof(substr(r1[1],3,-1)) 
		   set r1=atof(substr(r1[0],3,-1))
		   lin $(2 + 13*$i) 0
		   read { apert 3 true 7 }
		   define true ( sprintf('%.2g',true[0]) )
		   if($perc) {
		      set apert=apert/true set true=true/true
		   }
		   lim i (true concat apert)
		   set_window 1 5 $i
		   box 
		   ctype cyan con i true ctype default
		   con i apert
		   lim 0 1 0 1
		   rel .4 1.2 
		   putl 6 r1=$(sprintf('%g',r1)) r2=$(sprintf('%g',r2)) \
		true=$true
		}
		window 1 1 1 1
		xla \theta
		if($perc) {
		   yla Measured/True
		}
		toplabel \move-10000 0{Sigma = $(sigma) Cosbell=$(cosbell)}
		#
covar	99	# calculate the covariance of two coefficients:
		# Usage: $0 cosbell r1 r2 t1 t2  r1 r2 t1 t2
		define i local
		do i=6,9 {
		   if('$$i' == '*') {
		      define $i $$($i-4)
		   }
		}
		set C1 local set C2 local
		set C1 = get_coeffs($1,$2,$3,$4,$5)
		set C2 = get_coeffs($1,$6,$7,$8,$9)
		set $0=sum(C1*C2)/sqrt(sum(C1**2)*sum(C2**2))
		#
pcovar	111	# like covar, but print results
		covar $1
		echo Sum(C1**2) = $(sprintf('%.3f',sum(C1**2)))\
		 Sum(C1*C2) = $(sprintf('%.3f',sum(C1*C2)))\
		 Sum(C2**2) = $(sprintf('%.3f',sum(C2**2)))\
		 r_{C1 C2} = $(sprintf('%.3f',covar))
covar_matrix_ann 33	# calculate r_xy within each annulus
		# Usage: $0 cosbell ref_theta1 ref_theta2
		# e.g. covar_matrix_ann 10 135 165
		set r local set t local set t2 local
		set t2=0,12 set t2=15+30*t2 set t=t2-30
		set r={0.56 1.69 2.58 4.41 7.51}
		define i local define j local
		do j=0,dimen(r)-2 {
		   set rxy$j local
		   set rxy$j=0*t
		   do i=0,dimen(t)-2 {
		      covar $1 $(r[$j]) $(r[$j+1]) $2 $3 * * $(t[$i]) $(t[$i+1])
		      set rxy$j[$i] = covar
		   }
		   set rxy$j = rxy$j if(t2 < 360)
		}
		foreach i (t t2) { set $i = $i if(t2 < 360) }
		print '%3d--%3d   %8.3f %8.3f %8.3f %8.3f\n' \
		    { t t2 rxy0 rxy1 rxy2 rxy3 }
		#
covar_matrix_sec 33	# calculate r_xy between the same sector at all radii
		# Usage: $0 cosbell theta1 theta2
		# e.g. covar_matrix_sec 100 15 45
		set r local
		set r={0 0.56 1.69 2.58 4.41 7.51}
		if($2 != 0 && $3 != 360) {
		   set r=r if(r > 0)
		}
		set r2=r if(r > r[0]) set r2=r2 concat -1
		define i local define j local
		do j=0,dimen(r)-2 {
		   set rxy$j local
		   set rxy$j=0*r
		   do i=0,dimen(r)-2 {
		      covar $1 $(r[$j]) $(r[$j+1]) $2 $3 $(r[$i]) $(r[$i+1]) * *
		      set rxy$j[$i] = covar
		   }
		   set rxy$j = rxy$j if(r2 > 0)
		}

		foreach i (r r2) { set $i = $i if(r2 > 0) }

		print '%.2f--%.2f   %8.3f %8.3f %8.3f %8.3f %8.3f\n' \
		    { r r2 rxy0 rxy1 rxy2 rxy3 rxy4 }
		#
get_coeffs 55	# Read a coeffs file
		# Usage: $0 cosbell r1 r2 t1 t2
		define 2 (sprintf('%g',$2)+':')
		define 3 (sprintf('%g',$3)+':')
		image "cells/$!coeffs:$!1:$!2$!3$!4:$!5"
		set ix local set iy local
		set x local set y local
		define i local
		foreach i (NX NY X0 X1 Y0 Y1) {
		   define $i IMAGE
		}
		set i local
		set i=0,$NX*$NY - 1
		set iy=int(i/$NX) set ix=i-iy*$NY
		set x=$X0 + ix*($X1 - $X0)/($NX - 1)
		set y=$Y0 + iy*($Y1 - $Y0)/($NY - 1)
		set $0=image(y,x)
		#
diffs	23	# Calculate sigma from the differences of successive
		# values of a vector $1 (noise sigma $2)
		# if $?3, print answer
		set $0$1 local set $0$1 = $1
		set y local set ym local set yp local set tmp local
		set y=$0$1 + $2*gaussdev($(dimen($0$1)))
		set ym=y[dimen(y) - 2] concat y[dimen(y) - 1] concat y
		set yp =y concat y[0] concat y[1]
		set y=y[dimen(y) - 1] concat y concat y[0]
		set tmp=1,dimen(y)
		define v local
		foreach v (ym y yp) {
		   set $v = $v if(tmp > 1 && tmp < dimen(tmp))
		}
		if(1) {
		   set tmp=0,dimen(y)-1 lim tmp y box
		   con tmp y 
		   ctype cyan con tmp yp ctype magenta con tmp ym
		   ctype green con tmp (0.5*(yp+ym))
		   ctype default
		}
		set yp=yp-1000  set y=y-1000 set ym=ym-1000
		set $0=sqrt(2/3*sum((y - 0.5*(yp + ym))**2)/dimen(y))
		if($?3) {
		echo Estimated sigma = $($0) \
		  ($(sqrt((sum(y**2) - 4/3*sum(y*yp) + 1/3*sum(ym*yp))/dimen(y))))\
		  (naively $(sqrt(sum((y-sum(y)/dimen(y))**2)/(dimen(y)-1))))
		}
		set ybar local set ybar=0.5*(ym+yp)
		#print { ym y yp ybar }
		#
match	01	# Match a set of outputs (as read with e.g. Lconcat)
		# from different reruns;  each field is matched
		# separately.  N.b. object [0] is NOT matched, so
		# as to allow me use use match == 0 as the not-matched
		# sentinel (thus allowing psfMag3[match])
		#
		# If $1 is provided (and is > 0) it's the maximum
		# permitted separation in arcseconds to be considered
		# a match
		#
		# E.g.
		#Lconcat /home/s1/rhl/data 5225:40:ts  6 6 65 175 0 4
		#Lconcat /home/s1/rhl/data 5225:51:ts  6 6 65 175 0 4 +
		#
		#set match = match(1)
		#
		#lim ({12 22}) (0.3*{-1 1})
		#ERASE box
		#points psfMag3 (psfMag3-psfMag3[match]) if(rerun<rerun[match])

		if($?1) {
		   local define dmax ($1/0.396)
		} else {
		   local define dmax -1
		}

		local set i = 0,dimen(id)-1
		set $0 = -1 + 0*i
		
		define v local
		foreach v (i rerun objc_flags objc_rowc objc_colc) {
		   set _$v local
		}

		set ii local   set l local   set dist local
		local set fields = uniq(sort(field))
		local set camCol = atof(id)
		local set camCols = uniq(sort(camCol))
		#set fields = {65 166}

		define f local   define c local
		local define i -1
		define j local

		foreach c camCols {
		   foreach f fields {
		      set l = (camCol == $c && field == $f)
		      foreach v (i rerun objc_flags objc_rowc objc_colc) {
		         set _$v = $v if(l)
		      }
		   
		      do j = 0, dimen(_rerun) - 1 {
		         define i ($i + 1)
		         if ($i%1000 == 0) {
		            echo $i
		         }
		      
		         set l = _rerun != _rerun[$j] && \
		             !(_objc_flags & (2**$OBJ1_BRIGHT)) && \
		             (!(_objc_flags & (2**$OBJ1_BLENDED)) || (_objc_flags & (2**$OBJ1_NODEBLEND)))
		         set dist = (_objc_rowc - _objc_rowc[$j])**2 + (_objc_colc - _objc_colc[$j])**2 if(l)
		         set ii = _i if(l)
		         sort { dist ii }
		         set $0[_i[$j]] = \
		             ($dmax <= 0 || dist[0] < $dmax) ? ii[0] : -1
		      }
		   }
		}
		
		set $0 = $0 < 0 ? 0 : $0   
		#
overlap	12	# Usage: set match = overlap(field [,band])
		# Returns a vector of id1:id2, where id1 is the id of
		# a star in the specified field, and id2 the id of the
		# corresponding star in the next field. If you specify
		# band, it'll be used as the band to match in (default:2)
		#
		# See also show_overlap
		#
		# assumes that you have already said
		#   get_fields $1 $($1+1) rowc colc ...
		local define f1 $1  local define f2 ($f1 + 1)
		if($?2) {
		   local define band $2
		} else {
		   if($?NFILTER) {
		      local define band ($NFILTER > 3 ? 2 : $NFILTER - 1)
		   } else {
		      local define band 2
		   }
		}

		set l local  define i local
		do i=1,2 {
		   set l=(atof(substr(id,0,3)) == $f$i) && \
		    rowc$band >= 1361*(2-$i) && rowc$band < 128 + 1361*(2-$i)
		   local set r$i=rowc$band - 1361*(2-$i) if(l)
		   local set c$i=colc$band if(l)
		   local set id$i=substr(id,4,0) if(l)
		}
		if(0) {                 # debugging
		   ERASE lim (c1 concat c2) (r1 concat r2) box
		   ct red poi c1 r1  ct blue poi c2 (r2+0) ct 0
		}
		
		set dimen($0)=$(dimen(r1)).s
		set rc local  set cc local  set idc local
		set d2 local
		do i=0,dimen(r1)-1 {
		   set d2 = (r1[$i] - r2)**2 + (c1[$i] - c2)**2
		   set l = (d2 < 1)
		   if(sum(l) == 0) {
		      set idc='None'
		   } else {
		      set rc=r2 if(l)
		      set cc=c2 if(l)
		      set idc=id2 if(l)
		      set d2=d2 if(l)
		      sort { d2 rc cc idc}
		   }
		   set $0[$i]=id1[$i] + ':' + idc[0]
		}
		#
show_overlap 123 # Print the values of $3... given the match vector $1
		# for fields |$2| and |$2|+1; see overlap for the production
		# of such vectors. The vectors aren't actually printed
		# if $2 < 0
		#
		# e.g.
		#  get_fields 25 26 rowc colc psfMag2 fiberMag2
		#  set match=overlap(25)
		#  show_overlap match 25 psfMag2 fiberMag2
		#
		local define field ( abs($2) )
		define v local define i local
		local define vecs "< "
		foreach v ($3) {
		   do i=1,2 {
		      if($2 >= 0) {
		         set $v""$i local
		      }
		      set dimen($v""$i) = $(dimen($1))

		      define vecs "$!vecs $!v""$!i"
		   }
		}
		define vecs "$!vecs >"
		
		define id1 local define id2 local
		set tmp local
		do i = 0, dimen($1)-1 {
		   define v ( index($1[$i], ':') )
		   define id1 ( atof(substr($1[$i], 0, $v)) )
		   define id2 ( atof(substr($1[$i], $v + 1, 0)) )
		   foreach v ($3) {
		      set tmp = $v if(id == sprintf('%03d',$field) + ':$id1')
		      if(substr('$v',0,4) == 'rowc') {
		         set tmp = tmp - 1361
		      } else { if('$v' == 'id') {
		         set tmp = atof(substr(tmp,4,0))
		      }}
		      set $v""1[$i] = tmp 

		      if('$id2' == '0') {
		         set tmp = -1
		      } else {
		         set tmp = $v \
		          if(id == sprintf('%03d',$field+1) + ':$id2')
		          if('$v' == 'id') {
		             set tmp = atof(substr(tmp,4,0))
		          }
		      }
		      set $v""2[$i] = tmp
		   }
		}
		if($2 >= 0) {
		   print $vecs
		} else {
		   #echo $vecs
		}
		#
plot_overlap 2  #Plot the difference between magnitudes in the overlaps
		local define x_gutter 0.1  local define y_gutter 0.1
		ct 0 set_window 1 1 1
		define f local
		do f=$1,$2 {
		   lim ({14 25}) ({-.2 .2})    
		   #lim 0 0 ({-.5 .5})
		   set match=overlap($f) show_overlap match -$f psfMag0 psfMag1 psfMag2 psfMag3 psfMag4
		   if($2-$1+1 <= 1) {
		      set_window 1 1
		   } else { if($2 - $1 + 1 <= 4) {
		      set_window 2 2
		   } else { if($2 - $1 + 1 <= 6) {
		      set_window 2 3
		   } else { if($2 - $1 + 1 <= 9) {
		      set_window 3 3
		   } else { if($2 - $1 + 1 <= 12) {
		      set_window 3 4
		   } else {
		      set_window 4 4
		   }}}}}
		   box
		   rel $fx1 0 draw $fx2 0
		   do i=0,$NFILTER {
		      ctype_band $i poi psfMag$i""1 (psfMag$i""1-psfMag$i""2)
		   } 
		   ct 0
		   rel 15 $($fy1 + 0.9*($fy2-$fy1))
		   putl 6 $f-$($f+1)
		}
		set_window 1 1 1 
		# 
colours	49	# Usage: colours type1 type2 band1 band2 [logical] [plot_type]\
		#           [expand] [ptype] [contours]
		# plot either an CM diagram (if type1==type2), or a comparison
		# of two types of magnitude (if type1!=type2), or a comparison
		# of colours using two types of magnitude (if type1!=type2 &&
		# band1 != band2)
		#
		# Use band1 as the reference band (or $4 if negative)
		#
		# If $6 == "id" use IDs as ptype; if $6 == "error", plot
		# error bars. If $6 == "SG", plot stars and galaxies in colour;
		# if it's "star", "galaxy", "deV", or "exp" only plot that type
		# if it's a valid ctype, use it for the points
		# if $?7, it's the name of an expansion vector
		# if $?8, it's the name of a ptype vector
		# if $?9, use contour_points

		# refband is the band to provide the magnitude scale
		if($3 < 0) {
		   define 3 (-$3)
		   local define refband $3
		}
		if($4 < 0) {
		   define 4 (-$4)
		   if(!$?refband) {
		      local define refband $4
		   }
		}
		if(!$?refband) {
		   local define refband $3
		} 

		if(0 OR $?9 AND $9) {
		   if(!is_macro(contour_points)) {
		      load images
		   }
		   macro draw_points 33 {
		      local set levs = 0.1
		      set levs = do(1,4) concat do(5,200,5)
		      contour_points 0x0 $1 $2 0.05 0.1 levs $3 
		   }
		} else {
		   macro draw_points 33 { echo RHL\n points $1 $2 if($3) }
		}

		photoL $3
		if($?5) {
		   local set l = $5
		} else {
		   local set l = 1
		}
		if(dimen(l) == 1) {
		   set l = l + 0*$1Mag$3
		}

		if($?show_ids) {
		   local define ptype_id $show_ids
		} else {
		   local define ptype_id 0
		}

		if(!$?6) {
		   define 6 none
		}
		local define point_ctype "default"
		if('$6' == 'star' || \
		    '$6' == 'galaxy' || '$6' == 'deV' || '$6' == 'exp') {
		   set l = l && type=='$6'
		   define 6 SG
		} else { if('$6' == 'SG') {
		   define ptype_id 0
		} else { if(sum(ctype(string) == '$6') > 0) {
		   local set foo = ctype(string) if(ctype(string) == '$6')
		   define point_ctype ( foo[0] )
		}}}
		if('$6' == 'error' && !is_vector($1MagErr$3)) {
		   define 6 none
		}

		#set l = l && good && !blended && type != 'unknown'

		if('$1' == '$2') {
		   local set x = $1Mag$3 - $2Mag$4
		   local set y = $1Mag$refband

		   local define xlab \
		       <$(filter_name($3)) - $(filter_name($4)) ({\-1$1})>
		   local define ylab \
		           <$(filter_name($refband)) ({\-1$1})>

		   range 4 0 lim x 24 13.5 range 0 0

		   lim -0.5 2 0 0
		   lim 0 0 25 14
		   #lim -1 1.5 0 0
		   #lim -0.5 6 0 0
		   #lim -1 7 20.5 18
		   #lim -0.5 0 22 19
		   #lim -0.5 3 0 0
		   #lim -0.5 6 21.5 16
		   #lim 0 0 23 10

		   lim 0 0 (14 concat 20 + 2.5*lg(flux20) - 5) lim 0 0 $fy2 $fy1
		   #lim 0 0 26 13

		   #lim 0 0 $fy1 10      # XXX

		   if('$6' == 'error') {
		      local set xErr = sqrt($1MagErr$3**2 + $2MagErr$4**2)
		      local set yErr = $1MagErr$refband		
		   }

		   #lim  0.3 0.7 20 19
		} else {
		   local set x = $1Mag$refband
		   local define xlab <$(filter_name($refband)) ({\-1$1})>

		   if($3 == $4) {
		      lim 0 0 -0.5 0.7

		      if('$6' == 'SG' || '$6' == 'none') {
		         lim 0 0 -1 1
		         lim 0 0 -.25 .25
		         lim 0 0 -0.85 -0.6
		         #lim 0 0 -.1 .1
		      } else {
		         lim 0 0 -0.3 0.3
		         lim 0 0 -0.1 0.1
		      }

		      local set y = $1Mag$3 - $2Mag$3

		      local define ylab <$(filter_name($3)) {\-1($1 - $2)}>
		   } else {
		      lim 0 0 -0.5 0.7
		      if('$6' == 'SG') {
		         lim 0 0 -1 1
		         #lim 0 0 -.1 .1
		      } else {
		         lim 0 0 -0.3 0.3
		      }
		      
		      local set y = ($1Mag$3 - $1Mag$4) - ($2Mag$3 - $2Mag$4)

		      local define ylab <$(filter_name($3)) - $(filter_name($4)) {\-1($1 - $2)}>
		   }

		   lim x 0 0
		   #lim 13 24 0 0
		   lim ($fx1 concat 20 + 2.5*lg(flux20) - 5) 0 0		   

		   if('$6' == 'error') {
		      local set xErr = $1MagErr$refband
		      if($3 == $4) {
		         local set yErr = sqrt($1MagErr$3**2 + $2MagErr$4**2)
		      } else {
		         local set yErr = sqrt($1MagErr$3**2 + $2MagErr$3**2 +\
		          $1MagErr$4**2 + $2MagErr$4**2)
		      }
		   }
		}
		overload window 1  macro read "$!macro/overload"
		bo

		local define expand |
		if($?7) {
		   local set ee = $7
		} else {
		   local set ee = 1
		}
		if(dimen(ee) == 1) { set ee = ee + 0*x }

		if($?8) {
		   local set pt = $8
		} else {
		   local set pt = 11
		}
		if(dimen(pt) == 1) { set pt = pt + 0*x }

		local set _pt = <$ptype 0 0>  set _pt = _pt[{0 1}]
		local define pt <$(_pt[0]) $(_pt[1])>

		if('$6' == 'SG') {
		   set _ee local set _id local
		   set xx local set yy local set idid local
		   foreach v {star galaxy deV exp} {
		      ctype_from_type $v
		      set _ee = ee if(l && type == '$v')
		      if(dimen(_ee) > 0) {
		         if($ptype_id) {
		            set _id = '\\-2' + id if(l && type == '$v') pt _id
		         } else {
		            expand _ee
		         }
		         if($?8) {
		            if(dimen(pt) > 0) {
		               set _pt = pt if(l && type == '$v')
		               ptype _pt
		            }
		         }

		         draw_points x y l&&type=='$v'
		         if(0) {
		            foreach i (x y id) {
		               set $i""$i = $i if(l && type == '$v')
		            }
		            print { xx yy idid }
		         }
		      }
		   }
		   ct 0
		} else {
		   if('$6' == 'id') {
		      set pt = id if(l) 
		      ptype pt
		   }
		   set ee = ee if(l)  expand ee
		   if($?8) {
		      set pt = pt if(l)  ptype pt
		   }

		   ctype $point_ctype
		   draw_points x y l
		   pt $pt
		   ctype default

		   if('$6' == 'median') {
		      define xx local
		      foreach xx (med siqr npoint) {
		         define $xx local
		         set $xx local  set dimen($xx) = 0
		      }
		      local set xx=int($fx1)-1, int($fx2) + 1, 0.5
		      set tmp local
		      foreach xx xx {
		         set tmp = y if(l && x - $xx < (xx[1] - xx[0])/2)
		         if(dimen(tmp) == 0) {
		            define med 0
		            define siqr 0
		         } else {
		            stats_med tmp med siqr
		         }

		         set npoint = npoint concat dimen(tmp)
		         set med = med concat $med
		         set siqr = siqr concat $siqr
		      }
		      foreach xx (xx med siqr  npoint) {
		         set $xx = $xx if(npoint > 0)
		      }

		      print '%.1f %.3f %0g\n' { xx med npoint }
		      ctype magenta
		      con xx med
		      #error_y xx med 0.741*2*siqr
		      ctype 0
		   }
		}
		rel $fx1 0 draw $fx2 0
		set ee = <$expand>
		expand $(ee)

		if('$6' == 'error' && is_vector(xErr)) {
		   local set _x = x if(l)
		   local set _y = y if(l)
		   local set _xErr = xErr if(l)
		   local set _yErr = yErr if(l)
		   error_x _x _y _xErr
		   error_y _x _y _yErr

		   echo chi^2 = $(sum(((_x < 16 ? _y : 0)/_yErr)**2)/sum(_x<16))

		   ctype red
		   draw_points _x _y 1
		   ctype 0
		}

		local define xla 1
		if($?_iy) {
		   if($_iy > 1) {
		      define xla 0
		   }
		}
		if($xla) { xla $xlab }

		local define yla 1
		if($?_ix) {
		   if($_ix > 1) {
		      define yla 0
		   }
		}
		if($yla) { yla $ylab }

		RELOCATE ( 3000 31500 )
		label \-1Run:Column:Frame: $($run):$frames
		if(dimen(l) > 1) {
		   if($?5) {
		      label   if \-1$5 ($(sum($5)) objects)
		   }
		}
colours_type 48	# Plot magnitudes types $1, $2 in bands $3, $4 for all types
		# if ($?5 && $5), also plot all objects with no type info;
		# if it's -ve use contour_points to plot points	(-0.5 -> 0)
		# if $?6, only plot points for which $6 is true
		# if $?7, use that as a ptype vector
		if(!$?5) { define 5 0 }
		overload exp 1
		local define t1 $1
		local define t2 $2
		overload exp 0
		local define b1 $3
		local define b2 $4
		
		local define l "good&&!blended"
		if($?6) {
		   define l "$!6"
		}

		if($5 < 0) {
		   local define cont 1
		   define 5 (int(-$5))
		} else {
		   local define cont 0
		}

		local set ee = 0*$t1""Mag$b1
		if(dimen(ee) < 50000) {
		   local set pt = {40}
		   set ee = (dimen(ee) > 5000 ? 0.1 : 0.25) + ee
		   echo Setting expand to $(ee)
		} else {
		   set ee = ee + 1
		   local set pt = 10
		   if($?7) {
		      set pt = $7
		   }
		}
		if(dimen(pt) == 1) { set pt = pt + 0*ee }

		local define gy2 |
		location 3500 31000 3500 30000		
		if($5) {
		   local define nwx -2
		   local define nwy -2
		   set_window $nwx $nwy
		   colours $t1 $t2 $b1 $b2 $l none ee pt $cont
		} else {
		   local define nwx -3
		   local define nwy -1
		}

		if(!$?npass) {
		   local define npass 1
		}
		define i local
		set random dimen(psfMag0)
		local set rand = $npass*random(dimen(psfMag0))
		set lrandom local
		do i=0, $npass-1 {
		   set lrandom = (rand%$npass == $i) ? 1 : 0

		   set_window $nwx $nwy
		   colours $t1 $t2 $b1 $b2 $l&&lrandom SG ee pt $cont
		   
		   set_window $nwx $nwy
		   colours $t1 $t2 $b1 $b2 $l&&lrandom star ee pt $cont
		   
		   set_window $nwx $nwy
		   colours $t1 $t2 $b1 $b2 $l&&lrandom galaxy ee pt $cont
		   colours $t1 $t2 $b1 $b2 $l&&lrandom deV ee pt $cont
		   colours $t1 $t2 $b1 $b2 $l&&lrandom exp ee pt $cont

		   if($5) {             # skip everything-no-colour panel
		      set_window $nwx $nwy
		   }
		}

		label  (N_{obj}: $(sum($l)))

		set_window
		pt 4 1
		location $gx1 $gx2 $gy1 $gy2
colours_galtype 4	# Like colour_type, but just for galaxies
		overload exp 1
		local define t1 $1
		local define t2 $2
		overload exp 0
		local define b1 $3
		local define b2 $4
		
		pt 4 0 
		define l "good&&!blended"

		local set ee = 0*$t1""Mag$b1
		set ee = (dimen(ee) > 5000 ? 0.1 : 0.25) + ee

		set_window -3 1
		colours $t1 $t2 $b1 $b2 $l galaxy ee
		set_window -3 1
		colours $t1 $t2 $b1 $b2 $l deV ee
		set_window -3 1
		colours $t1 $t2 $b1 $b2 $l exp ee

		label  (N_{obj}: $(sum($l)))

		set_window
		pt 4 1
colour_excess 47	# Usage: colour_excess type1 type2 band1 band2 [logical] [plot_type] [expand]
		overload exp 1
		local define t1 $1 local define t2 $2 
		local define b1 $3 local define b2 $4
		overload exp 0

		if($?5) {
		   local set l = $5
		} else {
		   local set l = 1 + 0*$1Mag$3
		}
		if(dimen(l) == 1) {
		   set l = l + 0*$1Mag$3
		}
		if(!$?6) {
		   define 6 none
		}
		if('$6' == 'star' || \
		    '$6' == 'galaxy' || '$6' == 'deV' || '$6' == 'exp') {
		   set l = l && type=='$6'
		   define 6 SG
		}
		local define expand |
		if($?7) {
		   local set ee = $7
		} else {
		   local set ee = 1 + 0*psfMag0
		}

		if(!$?show_ids) {
		   local define show_ids 0
		}

		photoL $b1

		lim 13.5 24 -0.5 0.5
		overload window 1  macro read "$!macro/overload"
		bo

		local set y = ($t1""Mag$b1-$t1""Mag$b2) - \
		       ($t2""Mag$b1-$t2""Mag$b2)
		local define xlab \
		       <$(filter_name($b1)) ({\-1$t1})>
		local define ylab \
		           <($(filter_name($b1)) - $(filter_name($b2)))_{\-1$t1}>
		define ylab \
		   <$ylab - ($(filter_name($b1)) - $(filter_name($b2))))_{\-1$t2}>

		if('$6' == 'SG') {
		   set _ee local set _id local
		   foreach v {star galaxy deV exp} {
		      ctype_from_type $v
		      set _ee = ee if(l && type == '$v')
		      if(dimen(_ee) > 0) {
		         if($show_ids) {
		            set _id = '\\-2' + id if(l && type == '$v') pt _id
		         } else {
		            expand _ee
		         }

		         poi $t1""Mag$b1 y if(l && type == '$v')
		      }
		   }
		   ct 0
		} else {
		   if('$6' == 'id') {
		      local set pt = id if(l) 
		      ptype pt
		   }
		   set ee = ee if(l)  expand ee

		   poi $t1""Mag$b1 y if(l)

		   pt 4 1
		}
		rel $fx1 0 draw $fx2 0
		set ee = <$expand>
		expand $(ee)

		local define xla 1
		if($?_iy) {
		   if($_iy > 1) {
		      define xla 0
		   }
		}
		if($xla) { xla $xlab }

		local define yla 1
		if($?_ix) {
		   if($_ix > 1) {
		      define yla 0
		   }
		}
		if($yla) { yla $ylab }

		RELOCATE ( 3000 31500 )
		label \-1Run:Column:Frame: $($run):$frames
		if(dimen(l) > 1) {
		   if($?5) {
		      label   if \-1$5
		   }
		}
 		
colour_excess_type 45	# Plot magnitudes types $1, $2 in bands $3, $4 for all types
		# if $5, also show galxy classes seperately
		if(!$?5) { define 5 0 }
		overload exp 1
		local define t1 $1
		local define t2 $2
		overload exp 0
		local define b1 $3
		local define b2 $4
		
		photoL $b1

		define l "good&&!blended"

		local set ee = 0*$t1""Mag$b1
		if(dimen(ee) < 50000) {
		   local define pt "4 0"
		   set ee = (dimen(ee) > 5000 ? 0.1 : 0.25) + ee
		} else {
		   set ee = ee + 1
		   local define pt "1 1"
		}
		pt $pt

		local define gy2 |
		set_window\n location 3500 31000 3500 30000		
		if($5) {
		   local define nwx -3
		   local define nwy -2
		} else {
		   local define nwx -3
		   local define nwy -1
		}

		set_window $nwx $nwy
		colour_excess $t1 $t2 $b1 $b2 $l SG ee
		
		set_window $nwx $nwy
		colour_excess $t1 $t2 $b1 $b2 $l star ee
		
		set_window $nwx $nwy
		colour_excess $t1 $t2 $b1 $b2 $l galaxy ee
		colour_excess $t1 $t2 $b1 $b2 $l deV ee
		colour_excess $t1 $t2 $b1 $b2 $l exp ee

		if($5) {
		   set_window $nwx $nwy
		   colour_excess $t1 $t2 $b1 $b2 $l deV ee

		   set_window $nwx $nwy
		   colour_excess $t1 $t2 $b1 $b2 $l exp ee

		   set_window $nwx $nwy
		   colour_excess $t1 $t2 $b1 $b2 $l galaxy ee
		}

		label  (N_{obj}: $(sum($l)))

		set_window
		pt 4 1
		location $gx1 $gx2 $gy1 $gy2
colours_psf_fit 12 # Make a colours plot for band $1 stars (&&$2) for psf v. fit fluxes
		if(!$?2) { define 2 1 }
		overload exp 1
		ptype 1 1
		set_window -3 1
		colours exp psf $1 $1 $2 star
		set_window -3 1
		colours deV psf $1 $1 $2 star
		set_window -3 1
		colours model psf $1 $1 $2 star
		set_window
		ptype 4 1
		overload exp 0
		if('$2' != '1') {
		   label   ($(sum($2)) objects)
		}
two_colour 49	# plot a two-colour diagram for magnitudes of type $1,
		# using bands $2, $3, and $4. Only plot points for which
		# $5 is true.
		# If $6 == "id" use IDs as ptype; if $6 == "error", plot
		# error bars. If $6 == "SG", plot stars and galaxies in colour;
		# if it is "star" or "galaxy" just plot that type
		# if $?7, it's the name of an expansion vector
		# if $?8, suppress top labels
		# if $?9, plot points in that colour
		photoL $3

		if($?5) {
		   local set l = $5
		} else {
		   local set l = 1
		}

		if(!$?6) {
		   define 6 none
		}
		if('$6' == 'star' || \
		    '$6' == 'galaxy' || '$6' == 'deV' || '$6' == 'exp') {
		   set l = l && type=='$6'
		   define 6 SG
		} else {
		   local define show_ids 0
		   local define show_nobj 1
		}
		if('$6' == 'error' && !is_vector($1MagErr$3)) {
		   define 6 none
		}

		if(!$?show_ids) {
		   local define show_ids 0
		}

		local set x = $1Mag$2 - $1Mag$3
		local set y = $1Mag$3 - $1Mag$4
		
		local define vecs "x y"
		
		if('$6' == 'error') {
		   local set xErr = sqrt($1MagErr$2**2 + $1MagErr$3**2)
		   local set yErr = sqrt($1MagErr$3**2 + $1MagErr$4**2)
		   define vecs <$vecs xErr yErr>
		} else { if('$6' == 'id') {
		   local define pt <$ptype>
		   local set pt = string(id)
		   define vecs <$vecs pt>
		} else { if('$6' == 'SG') {
		   define vecs <$vecs type>
		   set type local
		} else { if('$6' == 'none') {
		} else {
		   user abort "Illegal value for argument 6: $!6"
		}}}}

		local define expand |
		if($?7) {
		   local set ee = $7 + 0*l
		} else {
		   local set ee = 1 + 0*l
		}
		define vecs <$vecs ee>

		if($show_ids) {
		   define vecs <$vecs id>
		   set id local
		}

		if(sum(l) == 0) {
		   return
		}

		if(dimen(l) > 1) {
		   define v local

		   foreach v ($vecs) {
		      set $v = $v if(l)
		   }
		}

		#range 2 2
		lim x y
		lim ({-0.25 2.0}) ({-0.25 2})
		#lim ({-0.25 2.0} - 0.5) ({-0.25 2}-1)
		lim ({-0.25 2.0}-0.0) ({-0.5 2.0})
		if($2 == 0) {           # u
		   lim ({-0.5 3.0}-0.0) 0 0
		}
		if($4 == 4) {           # z
		   lim 0 0 ({-0.5 1.2})
		}
		if(0 && $3 == 2) {      # XXX
		   lim ({-0.5 3}) 0 0
		}
		range 0 0
		if(!$?8) {
		   bo
		}

		if(is_vector(pt)) {
		   ptype pt
		}

		if(!is_vector(xErr)) {
		   if('$6' == 'SG') {
		      set _ee local  set _id local
		      local define ptype |
		      foreach v {galaxy deV exp star} {
		         ctype_from_type $v
		         if($show_ids) {
		            set _id = '\\-2' + id if(type == '$v') pt _id
		         }
 		         set _ee = ee if(type == '$v')
		         if(dimen(_ee) > 0) {
		            if(!$show_ids) {
		               expand _ee
		            }
		            poi x y if(type == '$v')
		         }
		      }
		      ct 0 pt $ptype
		   } else {
		      expand ee
		      if($?9) {
		         ctype $9
		      }
		      if(1) {
		         poi x y
		      } else {
		         contour_dot 0x0 x y
		      }
		      ct 0
		   }
		} else {                # errorbars. Clip to points within box
		   if(sum(l) > 0) {
		      set ee = ee if(l)
		      expand ee
		      set l = l if(l)
		      set l=l && x >= $fx1 && x <= $fx2 && y >= $fy1 && y <= $fy2
		      foreach v ($vecs) {
		         set $v = $v if(l)
		      }
		      
		      error_x x y xErr
		      error_y x y yErr
		   }
		}
		
		if($?pt) {
		   ptype $pt
		}

		set ee = <$expand>
		expand $(ee)

		local define xla 1
		if($?_iy) {
		   if($_iy > 1) {
		      define xla 0
		   }
		}
		local define yla 1
		if($?_ix) {
		   if($_ix > 1) {
		      define yla 0
		   }
		}

		if(!$?8) {
		   if($xla) {
		      xla $(filter_name($2)) - $(filter_name($3)) ({\-1$1})
		   }
		   if($yla) {
		      yla $(filter_name($3)) - $(filter_name($4)) ({\-1$1})
		   }
		   
		   RELOCATE ( 3000 32000 )
		   label Frame: $frames
		   if(dimen(l) > 1) {
		      label   if \-1$5
		   }
		   if($?show_nobj) {
		      label  $(sum(l)) Objects
		   }
		}
two_colour_type 46	# Plot two-colour diagrams, type $1, colours $2-$4,
		# to a magnitude limit of $5 (if present and positive). Only plot
		# points for which $6 is true, if present. Draw panels for
		# everything, stars, and galaxies. If a colour is -ve, use
		# it for magnitude limit
		local define bref $3
		if($2 < 0) { define 2 (0-$2)  define bref $2 }
		if($3 < 0) { define 3 (0-$3)  define bref $3 }
		if($4 < 0) { define 4 (0-$4)  define bref $4 }
		photoL $bref
		
		overload exp 1
		local define t1 $1
		overload exp 0
		local define b1 $2
		local define b2 $3
		local define b3 $4
		if($?5 AND $5 > 0) {
		   local define maglim $5
		} else {
		   local define maglim delete
		}
		
		local define l "good&&!blended"
		if($?6) {
		   define l "$!6"
		}
		if($?maglim) {
		   echo define l "$!l&&$!t1""Mag$!bref<$!maglim"
		   define l "$!l&&modelMag$!bref<$!maglim"
		}

		local set ee = 0*$t1""Mag$b1
		if('$ptype' == '4 1') {
		   local set pt=40
		   set ee = (sum($l) > 5000 ? 0.1 : 0.25) + ee
		} else {
		   set ee = 0*ee + 1
		}
		
		set_window 1 -3\n 
		two_colour $t1 $b1 $b2 $b3 $l SG ee
		
		set_window 1 -3\n 
		two_colour $t1 $b1 $b2 $b3 $l star ee
		
		set_window 1 -3\n 
		two_colour $t1 $b1 $b2 $b3 $l galaxy ee
		two_colour $t1 $b1 $b2 $b3 $l deV ee
		two_colour $t1 $b1 $b2 $b3 $l exp ee
		
		set_window
		pt 4 1
coloursHist 47	# Draw histograms of colours as a fn of magnitude
		# Usage: coloursHist type1 type2 colour1 colour2 \
		#                                  [logical] [ctype] [logical2]
		# e.g. coloursHist model petro 0 1  1 default type!='star'
		#
		# Only objects for which $5 is true are plotted; the axes
		# are scaled for all points for which $7 is true
		if(!$?5) { define 5 1 }
		if(!$?6) { define 6 default }
		if(!$?7) { define 7 1 }

		if('$1' == '$2') {
		   local set mag=do(-2,2,0.25) + 0.125
		   set mag=do(-.5,2.5,.2) + 0.1
		} else {
		   set mag local
		   set mag=do(-0.5,1,0.02) + 0.01
		   set mag=do(-0.3,0.5,0.01) + 0.005
		   #set mag=do(-1,1,0.05) + 0.025
		   #set mag=do(-0.1,0.1,0.005) + 0.0025
		   #set mag = 0.0,0.3,0.005
		}
		set h2 local  set h1 local  set l local

		set_window 1 1
		location $gx1 $gx2 $gy1 28000
		local set m=15.5,26,1
		set m = m if(m < 25)    # XXX
		define m local
		foreach m m {
		   set_window -2 -$(int((dimen(m) + 1)/2))
		   set l = good && abs($1""Mag$3-$m) <= 0.5 && $7
		   if($3 == $4) {
		      set h1 = $1Mag$3-$2Mag$3 if(l)
		   } else {
		      set h1 = ($1Mag$3 - $1Mag$4) - ($2Mag$3 - $2Mag$4) if(l)
		   }
		   set h1=histogram(h1:mag)
		   lim mag (mag==mag[0]||mag==mag[dimen(mag)-1]?0:h1) bo
		   lt 1
		   rel $fx1 0 draw $fx2 0
		   rel 0 $fy1 draw 0 $fy2
		   lt 0
		   ctype $6
		   if($3 == $4) {
		      set h1 = $1Mag$3-$2Mag$3 if(l&&$5)
		   } else {
		      set h1 = ($1Mag$3 - $1Mag$4) - ($2Mag$3 - $2Mag$4) if(l&&$5)
		   }
		   set h1=histogram(h1:mag)
		   hi mag h1
		   ctype default
		   lim 0 1 0 1 rel .8 .8 putl 5 $m
		}
		set_window
		location $gx1 $gx2 $gy1 31000 
		#rel $fx1 $fy2
		if($3 == $4) {
		   xla $(filter_name($3))_{\2$1} - $(filter_name($4))_{\2$2}
		} else {
		   xla ($(filter_name($3)) - $(filter_name($4)))_{\2$1 - $2}
		}
		#
coloursHist_type 45	# Draw histograms of colours as a fn of magnitude
		# Usage: coloursHist type1 type2 colour1 colour2 [logical]
		# e.g. coloursHist_type model petro 0 1
		if(!$?5) {
		   define 5 1
		}
		photoL $3 
		overload exp 1
		set h local  local define maglim_delta 20 local define nsigma 4

		if(('$1' == 'aper' || '$2' == 'aper') && '$3' == '$4') {
		   define maglim_delta ( $maglim_delta - 2 )
		}
		local set nstars = sum(objc_type == 'star' && $5)
		if(nstars == 0) {
		   define maglim_delta 19
		}
		foreach t {all star deV exp galaxy} {
		   coloursHist $1 $2 $3 $4 $5&&('$t'=='all'||type=='$t') \
		    $('$t' == 'all' ? 'default' : ctype_from_type($t,1)) $5
		    if(('$t' == 'star' && nstars > 0) || \
		        (nstars == 0 && '$t' == 'all')) {
		    
		       if('$3' == '$4') {
		          set h=$1Mag$3-$2Mag$4
		       } else {
		          set h=($1Mag$3-$1Mag$4) - ($2Mag$3-$2Mag$4)
		       }
		       set h = h \
		           if($5 && good && ('$t' == 'all' || type=='$t') && \
		           $1Mag$3 < $maglim_delta)

		       define med local   define siqr local
		       define mean local define sig local  define kk local
		       stats_med h med siqr  define sig (2*0.741301*$siqr)
		       RELOCATE (3500 30000) 
		       label \1\sigma_{$(filter_name($3)) < $maglim_delta} = {\-1$(sprintf('%.3f', $med)) \pm{} $(sprintf('%.3f', $sig))}

		       stats h mean sig kk
		       set h = h if(abs(h - $mean) < $nsigma*$sig)
		       stats h mean sig kk
		       stats_med h med siqr  
		       local define sig_c (2*0.741301*$siqr)

		       label  ({\-1$(sprintf('%.3f', $sig))/$(sprintf('%.3f', $sig_c)), $nsigma\sigma clip})   Fields: $frames
		    }
		}
		overload exp 0
groth		#set variables for groth data
		define level0data "/peyton/scr/tanuki0/fan/photodata/groth/input"
		define photodata "/u/rhl/photodata/groth/output"
		define run {050600}
hdf		#set variables for hdf data
		define level0data "/peyton/scr/tanuki0/fan/photodata/hdf/input"
		define photodata "/u/rhl/photodata/hdf/output"
		define run {050601}
m13		#set variables for M13 data
		define level0data "/peyton/scr/tanuki0/fan/photodata/m13/input"
		define photodata "/u/rhl/photodata/m13/output"
		define run {050601}
3h		#set variables for 3h data
		define level0data "/peyton/scr/tanuki0/fan/photodata/3h/input"
		define photodata "/u/rhl/photodata/3h/output"
		define run {050750}
frames	01	#set variables for frames_? data (default: 8)
		if(!$?1) { define 1 8 }
		define level0data "/peyton/scr/tanuki0/photodata/frames_$!1/input"
		define photodata "/u/rhl/photodata/frames_$!1/output"
		define run {000581}
naoki		#set variables for Naoki's outputs
		define level0data "/u/yasuda/jpgtest"
		define photodata "/u/yasuda/jpgtest"
		define run {000581}
jpg	01	#set variables for ??? data (default: 180)
		if(!$?1) { define 1 180 }
		define level0data "/u/rhl/photodata/$!1/input"
		define photodata "/u/rhl/photodata/$!1/output"
		define run {000581}
set_run	35	#set variables for real data: rootdir run col [tsObj?] [rerun]
		# dirmod is used if we have our own output directory, e.g.
		# data_root/run/2/objcs/...
		#
		define data_root "$!1"
		define run $2
		define col $3
		if(!$?4) { define 4 0 }
		if(!$?5) { define 5 -1 }
		local define tsObj $4
		define rerun $5

		define astrodata "$!data_root/$!run/astrom"
		if($5 >= 0) {
		   define photodata "$!data_root/$!run/$!5/objcs"
		   define psFangdata "$!data_root/$!run/$!5/psFangs/$col"
		} else {
		   define photodata "$!data_root/$!run/objcs"
		   define psFangdata "$!data_root/$!run/psFangs/$col"
		}
		define calibdata "$!photodata"

		if($tsObj) {
		   if($5 >= 0) {
		      define photodata "$!data_root/$!run/$!5/calibChunks/$!col"
		   } else {
		      define photodata "$!data_root/$!run/calibChunks"
		   }
		   define fpObjc tsObj
		} else {
		   define fpObjc fpObjc
		}
		
		if('$run' == 'testbed') {
		   define photodata "$!photodata-test"
		   define run 94
		}
		define run ( sprintf('%06d', $run) )
		
		!test -d $photodata/$col
		if($exit_status == 0) {
		   define photodata "$!photodata/$!col"
		}
		#
ellipse_fit 1	# given r and coeffs, plot them. We expect 3 sets ($1=0,1,2)
		if($1 == 0) {
		set r={-1, -1, -1, 4.94107342, 4.93530989, 4.93331003, -1, 4.94135046, 
  4.92976046, -1, -1, -1}
		set coeffs={4.9184389998667726, -0.018584035583856573, -0.024149216653940063, -0.015375678223314489, -0.0040473817654299235}
		} else {if($1 == 1){
		set r={0.923573375, 0.370157659, 0.0413053334, -1, \
		       4.92764521, 4.9245801, -1, 4.93232346, -1, 1.00386369, 0.804916263, 0.784084022}
		set coeffs={2.4277531462644482, -0.33995642503861445, -2.6518315428943771, 0.50866682806555552, 0.89089433363715642}
		} else {
		set r={1.60788155, 1.68282521, 1.705845, -1, -1, -1, 2.09668279, -1, -1, 1.5780797, 1.52924895, 1.51665425}
		set coeffs={1.7710295788324872, -0.099869570634600779, -0.2422093489368739, -0.020183662366180334, 0.08160829319794019}
		}}

		if($1 == 0) {
		   set coeffs={21.4054 3.17953 -0.771144 3.51762 -8.77675}
		   set r=atof({-1, 15.4815874, 14.2313023, 15.3899736, 28.9192486, 27.6853256, 15.9667015, 14.9108019, -1, 20.546814, 32.6705818, 33.0252266})
		} else { if($1 == 1) {
		   set coeffs={21.4054 1.56779 2.87161 9.38812 1.12617}
		   set r={-1, 15.4815874, 14.2313023, 15.3899736, 28.9192486, 27.6853256, 15.9667015, 14.9108019, -1, 20.546814, 32.6705818, 33.0252266}
		} else {
		   set r=atof({-1, 15.4815874, 14.2313023, 15.3899736, 28.9192486, 27.6853256, 15.9667015, 14.9108019, -1, 20.546814, 32.6705818, 33.0252266})
		   set coeffs={21.4054 1.56779 2.87161 9.38812 1.12617}
		}}


		if($1 == 0) {
		   set coeffs={13.7201 1.04609e-09 8.48759e-07 4.61245 -9.44344e-08}
		   set r={18.2500992, 12.6491003, 10.2610998, 10.2610998, 12.6491003, 18.2500992, 18.2500992, 12.6491003, 10.2610998, 10.2610998, 12.6491003, 18.2500992}
		} else { if($1 == 1) {
		   set coeffs={13.7244 8.88895e-07 -6.23771e-07 -1.5619 -4.35657}
		   set r={10.4698, 10.1149998, 12.0375996, 17.2073002, 19.1525002, 13.3645, 10.4698, 10.1149998, 12.0375996, 17.2073002, 19.1525002, 13.3645}
		} else {
		   set coeffs={10 4.99733 -0.16314 -0.875781 -0.213314}
		   set r={13.9196997, 13.2049999, 11.7875996, 9.41411018, 6.56431007, 4.47893, 4.35005999, 6.36838007, 9.51597023, 12.3161001, 13.8622999, 14.2174997}
		}}
		
		local set theta=(do(0,360,30)+15)*pi/180 
		local set r=atof(r)
		set r = r concat r[0]

		if($1 == 0) {
		   lim (r concat -r) (r concat -r) box
		} else { if($1 == 1) {
		   ctype magenta
		} else {
		   ctype green
		}}

		local set b0 = coeffs[0]
		local set b1 = coeffs[1]
		local set a1 = coeffs[2]
		local set b2 = coeffs[3]
		local set a2 = coeffs[4]

		set mcc = 0.125*(4*b0*b0 + a1*a1 + b1*b1 + 4*b0*b2 + 2*b2*b2 + 2*a2*a2)
		set mcr = 0.5*b0*a2
		set mrr = 0.125*(4*b0*b0 + a1*a1 + b1*b1 - 4*b0*b2 + 2*b2*b2 + 2*a2*a2)


		local set mxx = 0.5*(mcc + mrr + sqrt((mcc - mrr)*(mcc - mrr) + 4*mcr*mcr))
		local set myy = (mcc*mrr - mcr*mcr)/mxx
		local set phi = atan2(mcc - mxx, mcr)

		if(0) { foreach i (mxx myy) {
		   echo $($i): i**2 - $(mrr + mcc)*i + $(mcc*mrr - mcr*mcr) \
		    $($i**2 - (mrr + mcc)*$i + (mcc*mrr - mcr*mcr))
		}}

		local set major = sqrt(mxx/myy*(mxx + myy))
		local set minor = sqrt(myy/mxx*(mxx + myy))

		expand 2 poi (r*cos(theta)) (r*sin(theta)) if(r >= 0) expand 1
		local set t=2*pi*do(0,1,0.001)
		local set cc=coeffs[0]+cos(t)*coeffs[1]+sin(t)*coeffs[2]+\
		    cos(2*t)*coeffs[3]+sin(2*t)*coeffs[4]
		con (cc*cos(t)) (cc*sin(t))
		local set rowc=a1/2 local set colc=b1/2

		set rowc=0.5*(2*b2*b2*a1 + a1*a1*a1 + 2*a1*a2*a2 + \
		    4*a1*b0*b0 + 4*b1*a2*b1 - 4*b2*a1*b0 + b1*b1*a1)/ \
		    (a1*a1 + a2*a2 + 2*b0*b0 + b1*b1 + b2*b2)
		set colc=0.5*(2*b1*a2*a2 + 4*b0*b0*b1 + b1*b1*b1 + \
		        2*b1*b2*b2 + a1*a1*b1 + 4*b0*b1*b2 + 4*a1*a2*b0)/ \
		    (a1*a1 + a2*a2 + 2*b0*b0 + b1*b1 + b2*b2)
		relocate $(colc) $(rowc)

		echo $(colc) \
		    $(sum(cc*cos(t)*0.5*cc**2*(t[1]-t[0]))/sum(0.5*cc**2*(t[1]-t[0]))) 

		expand 3 angle 45 dot expand 1 angle 0

		#echo $(mcc) $(mcr) $(mrr)   $(major) $(minor) $(phi*180/pi)
		#set phi=phi*pi/180
		#p r
		local set x=major*cos(t)  local set y=minor*sin(t)
		ltype 1
		con (colc+x*cos(phi)+y*sin(phi)) (rowc-x*sin(phi) + y*cos(phi))
		lt 0
		ct 0
petro_ratio 125	# read a file $1 of Petrosian ratios, as written using
		# photo's dump_test_info_list. If $?2 it's the band to
		# be plotted; if -1 plot all. If $3 and $4 are present,
		# only plot that range of object IDs
		# If $5 is present, evaluate it for each band, and only
		# plot object if true
		local set band = $2
		if($?3) { define 3 ($3 < 1 ? 0 : $3 - 1) } else { define 3 0 }
		if(!$?4) { define 4 -1 }
		RELOCATE (2000 32000) label $(quote_TeX('$1'))
		if($?5) { label    \0$(quote_TeX('$5')) } else { define 5 1 }

		local set r=profileRadii()
		set lr local

		set id local   set c local 
		da $1
		if($4 > 0) {
		   lin 1 $(5*$4 + 10)
		} 
		read { id 1.s c 2 }
		local set frame=atof(id)
		set id=atof(substr(id,index(id,':')+1,0))

		local set nc=sum(frame == frame[0] && id==id[0])
		local set nobj=sum(c==0)
		if($4 < 0) { define 4 ( nobj ) }
		
		set nobj = int($4 - $3 + 0.5)
		#echo nc = $(nc)  nobj = $(nobj)
		local define nx (int(sqrt(nobj))) local define ny $nx

		while {$nx*$ny < nobj} {
		   define nx ($nx + 1)
		   if ($nx*$ny >= nobj) { break }
		   define ny ($ny + 1)
		}

		set ratio local  set flags local  set l local
		set psfCounts local  set psfCountsErr local

		if(band == -1) {
		   local set row0 = nc*$3 + 1
		   local set row1 = nc*$4
		   local set drow = 1
		} else {
		   local set row0 = nc*$3 + band
		   local set row1 = nc*$4 + band
		   local set drow = nc
		}

		set_window -$nx -$ny 0
		box
		set_window 1 1 1
		lim ({-.1 2}) ({-.1 1.1})
		if(!is_vector(flux20)) {
		   local set flux20 = 1e6*10**(-6*0.4) + 0*do(1,5)
		}

 		define i local
		do i=row0,row1,drow {
		   read row ratio $i.s
		   set id=ratio[0]
		   set ratio=atof(ratio)
		   set c = ratio[1]
		   set flags= ratio[2]
		   set psfCounts= ratio[3]
		   set psfCountsErr= ratio[4]
		   #echo $(id) $(c) $(psfCounts)  $(psfCountsErr)
		   set ratio=ratio if(do(1,dimen(ratio)) > 12)
		   
		   if(band >= 0 || $i%nc == 2) {
		      set_window -$nx -$ny
		      box 3 3 3 3
		      rel $($fx1 + 0.9*($fx2-$fx1)) $($fy1 + 0.9*($fy2-$fy1))
		      #putl 1 \-$(int($nx/6)+1)$(id)
		      putl 1 \-$(int($nx/6)+1)$((psfCounts <= 0) ? ' ' : \
		          sprintf('%6.2f', 20-2.5*lg(psfCounts/flux20[c])))
		   }
		   if($5) {
		      if(band == -1) {
		         ctype_band $(c)
		      }
		      #connect (do(1,dimen(ratio))) ratio
		      set lr=lg(r) if(do(1,dimen(r)) <= dimen(ratio))
		      if(dimen(ratio) > 0) {
		         connect lr ratio if(abs(ratio) < 2)
		      }
		      #print { lr ratio }
		      ctype 0
		      rel $fx1 (1/5) draw $fx2 $uyp
		      rel $fx1 0 draw $fx2 $uyp
		   }
		}
		set_window 1 1 1 
		xla lg(r/pixel)
		yla {\sc R}_P
		#
ctype_band 1	# set a colour given a band index or name
		local set cols={cyan green red magenta yellow}
		if(index('$device', 'post') >= 0) {
		   set cols[4] = 'black'
		}
		local set i = index('ugriz', '$1')
		if(i >= 0) {
		   define 1 i
		}
		ctype $(cols[$1])
		#
filter_name 1	# convert 0-4 to u-z
		set $0 = substr('ugriz', $1, 1)
get_enum 13	# Define a set of variables from a FITS HDU $1
		# defined, it'll be stripped from the start of the name of
		# each variable before it's defined; if $3 is defined it'll
		# be added. E.g.
		#   table fpObjc.fit
		#   get_enum 2 OBJECT OBJ
		# will define $OBJ_SATUR from the OBJECT1_SATUR value read
		# from HDU 2
		table $1
		define i local
		do i=0, 30 {
		   set defName$i local  set attributeName$i local
		}
		set Value local
		read table { defName[0-30] attributeName[0-30] Value }

		set v local
		foreach v (defName attributeName) {
		   set $v local
		   set dimen($v) = $(dimen(defName0)).s
		   do i=0, 30 {
		      set $v = $v + $v""$i
		   }		   
		}

		if($verbose) {
		   echo "Type: $!(defName)"
		}
		do i=0, dimen(attributeName) - 1 {
		   define v (attributeName[$i])
		   if($?2) {
		      if(index('$v', '$2') >= 0) {
		         define v ( substr('$v', strlen('$2'), 0) )
		         if($?3) {
		            define v ( '$3' + '$v' )
		         }
		      }
		   }
		   define $v $(Value[$i])
		}
psf_fiber 23	# Plot PSF - Fibre magnitudes for band $1, psfMag < $2;
		# x-axis range $3 if provided
		local define b $1  local define maglim $2
		if(!$?3) { define 3 0 }
		local define xrange $3
		local set x=-1,1,0.01
		photoL $b
		local set foo=psfMag$b-fiberMag$b \
		    if(good && type=='star' && psfMag$b < $maglim)
		    
		local set h=histogram(foo:x)
		set h[0] = 0  set h[dimen(h)-1] = 0
		lim x h
		range $xrange 0
		bo
		ctype_band $1
		hi x h
		ct 0
		define m local define s local define k local
		stats2 x h m s k
		echo $m +- $s
		yla N
		toplabel Frame: $frames psf$b < $maglim: 
		relocate $($fx1 + 0.9*($fx2-$fx1))  $($fy1 + 0.8*($fy2-$fy1))
		putlabel 4 Band $b; \Delta{} =  $(sprintf('%.3f', $m) + sprintf(' \\pm{} %.3f', $s))
		    
show_velocity 13	# Plot velocities in += 1 $1 (if $2 if present).
		# If present, the 3rd argument means:
		#  $3 & 0x1		Plot errors
		#  $3 & 0x2		Show IDs
		#  $3 & 0x4		Convert to arcmin/day
		#  $3 & 0x8		Draw a set of circle
		#  $3 & 0x10		Label circles
		#
		# See also histogram_velocity
		define v local

		if(!$?3) { define 3 0 }
		local define flags ($3)

		local define errors    ($flags & 0x1)
		local define show_id   ($flags & 0x2)
		local define distance  ($flags & 0x4)
		local define circle    ($flags & 0x8)
		local define label_circles ($flags & 0x10)
		local define planets   ($flags & 0x20)

		foreach v (rowv colv rowvErr colvErr) {
		   set $v local
		}

		local set alpha = 0.986 # v = alpha/(R + sqrt(R)); Jewitt 1999
		if($distance) {
		   local set theta = atan2(colv, rowv)
		   local set v = sqrt(rowv**2 + colv**2)
		   local set R = (0.5*(-1 + sqrt(1 + 4*alpha/v)))**2
		   
		   if($errors) {
		      local set dv = sqrt(((rowv*rowvErr)**2 + (colv*colvErr)**2))/v
		      local set dR = (alpha*dv/v**2)/(1 + 1/(2*sqrt(R)))
		      set rowvErr = dR*cos(theta)  set colvErr = dR*sin(theta)
		   }
		   
		   set rowv = R*cos(theta)  set colv = R*sin(theta)
		}

		if($circle) {
		   if($planets) {
		      local set radii = {1.524 5.203 9.539 19.18 30.06 39.44}
		      local set planets = {Mars Jupiter Saturn Uranus Neptune Pluto}
		   } else {
		      local set radii = {40 34 20 10 5 3 2}
		   }
		}

		lim (<-$1 $1>) (<-$1 $1>)
		#lim (<-$1 0>) (<-$1 0>)
		box

		if($?2) {
		   local set l = $2
		} else {
		   local set l = 1
		}

		set l = l && (\
		    colv >= $fx1 && colv <= $fx2 && \
		    rowv >= $fy1 && rowv <= $fy2)
		
		foreach v (rowv colv) {
		   set $v = $v if(l)
		   
		   if($errors) {
		      set $v""Err = $v""Err if(l)
		   }
		}
		if($show_id) {
		   local set id = id if(l)
		}
		if($show_id) {
		   ptype id
		}

		if($errors) {
		   if($show_id) {
		      if(0) {
		         p id
		         local set foo = sqrt(rowv**2 + colv**2)
		         p foo
		         set foo = string(int(objc_rowc - 1361*(field-field[0]))) + \
		             ',' + string(int(objc_colc)) if(l)
		             
		         p foo
		      }
		      poi colv rowv
		      ct yellow
		   }
		   
		   error_x colv rowv rowvErr
		   error_y colv rowv colvErr

		   ct 0
		} else {
		   poi colv rowv
		}
		ct 0

		if($circle) {
		   ct cyan

		   define R local  define lab local
		   do v=0,dimen(radii)-1 {
		      define R (radii[$v])
		      if($planets) {
		         define lab ( '\\4\\' + planets[$v] )
		      } else {
		         define lab $R
		      }
		      if(!$distance) {
		         define R (alpha/($R + sqrt($R)))
		      }
		      		       
		      circle 0 0 $R
		      rel 0 $R

		      if($uyp < $fx2) {
		         putl 8 $lab
		      }
		   }

		   ct 0
		}

		if($distance) {
		   local define xla "{\1\mu}/A.U."
		   local define yla "{\1\\nu}/A.U."
		} else {
		   local define xla "row velocity (deg/day)"
		   local define yla "column velocity (deg/day)"
		}

		xla $xla
		yla $yla
		relocate $($fx1 + 0.05*($fx2-$fx1)) $($fy1 + 0.95*($fy2-$fy1))
		putl 3 $(sum(l)) objects

		if($show_id) {
		   ptype 4 1
		}
		#
cprof	1	# Read cumulative profiles for all bands for field $1
		#
		define i local define j local
		if(!$?NFILTER) {
		   define NFILTER 5
		}
		#
		# Setup the geometry
		#
		set radii = profileRadii()
		set area = 0*radii
		set area[0] = pi*radii[0]**2
		do i=1,14 {
		   set area[$i] = pi*(radii[$i]**2 - radii[$i-1]**2)
		}

		do i = 0, $NFILTER-1 {
		   set prof_nprof$i local
		   do j=0, 14 {
		      set prof_mean$(15*$i + $j) local
		      set prof_sig$(15*$i + $j) local
		   }
		}
		#
		# Read the data
		#
		set field local  set psp_status local # read by gett_calib
		gett_calib $1
		table 6
		read table { prof_nprof[0-4] prof_mean[0-74] prof_sig[0-74] }
		#
		# Transpose it
		#
		do i=0,$NFILTER-1 {
		   set cprof$i = 0*area  set cprofErr$i = -9999 + 0*area
		   do j = 0, prof_nprof$i-1 {
		      set cprof$i[$j] = prof_mean$(15*$i + $j)
		      set cprofErr$i[$j] = prof_sig$(15*$i + $j)
		   }
		}
