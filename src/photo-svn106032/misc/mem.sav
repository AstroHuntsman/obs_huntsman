Dump, Fri May 12 17:35:39 1995

Variables:

data_file	mem.trace
ed_macro	trace

Macros:

block      23	set u=-usize if(id >= $1 && id <= $2)
		set t=tsize if(id >= $1 && id <= $2)
		set f=file if(id >= $1 && id <= $2)
		set l=line if(id >= $1 && id <= $2)
		set i=id if(id >= $1 && id <= $2)
		sort{u t f l i}
		set u=-u
		if($?3) {
		   print '%10d %10d %20s %5d %d\n' { u t f l i }
		}
		 define su (sum(u)) define waste (sum(t)-$su)
		echo Total used = $($su/1e6) Mb, \
		(Waste = $($waste/1e6)Mby  $($su==0?0:100*$waste/$su)%)
execute    11	# read and execute an SM file of commands (1 per line)
		# (This is identical to input_new)
		define 3 5              # maximum nesting for execute
		do 2=1,$3 {
		   IF(is_set(_temp$2,1) == 0 && is_set(all$2,1) == 0) {
		      MACRO all$2 0 10000 # save history
		      DELETE 0 10000
		      RESTORE $1        # read commands
		      define 3 5        # maximum nesting for input
		      MACRO _temp$2 0 10000
		      DELETE 0 10000
		      WRITE HISTORY all$2 # restore history
		      _temp$2
		      MACRO _temp$2 DELETE
		      MACRO all$2 DELETE
		      RETURN
		   }
		}
		echo Attempt to nest too many $0s (max depth: $3)
		#
extend_history 11	# Extend history buffer to be of size $1
		del1
		MACRO all 0 10000
		DELETE 0 10000
		MACRO __junk { one line }
		do 2=1,$1 { WRITE HISTORY __junk }
		DELETE 0 10000
		WRITE HISTORY all
		MACRO __junk DELETE
growth    	define 1 0 define 1 ? {Cumulate?}
		if($1) {
		   cumulate usize cusize   cumulate tsize ctsize  
		}
		lim id ctsize box hi id cusize ctype cyan hi id ctsize ctype default
		ptype bp angle 90 poi mid (1e7*(1+mid/mid[dimen(mid)-1]))
		ptype 4 1 angle 0
		xla Memory ID
		yla Mbytes
		#
print_block	data mem.ser read { bp 1.s mid 2 }
		do i=0,dimen(bp)-2 {
		   echo $(bp[$i]) -- $(bp[$i+1])\n block $(mid[$i]) $(mid[$i+1])
		}
ctrace	112	# loop, repeating a trace command every $1 seconds; opt args
		# to trace at end of line. If $1 <= 0, only redraw when file
		# mem.trace changes size
		if(!$?2) { define 2 " " }
		set oldsize = 0              # old size of file
		if($1 <= 0) {
		   define 1 (-$1)
		   define name :
		   macro foo {
		      !ls -l mem.trace > $temp_dir""$name
		      DATA "$!temp_dir""$!name"
		      read { size 5 }
		      if(size != oldsize) {
		         set oldsize = size
		         trace $!!2
		      }
		      !rm $temp_dir""$name; sleep 10
		   }
		} else {
		   macro foo { trace $!!2 !sleep $!!1 }
		}
		while {1} { foo }
		#
trace	05	# if $1 == 1, plot the total memory used rather than the memory wasted
		# if $2 == 1, draw the vertical lines, if == 2 draw important
		# labels but no lines; if > 2, don't draw labels or lines
		# if $3 == 1, use the total time for the x-axis, if $3 == 2,
		# use user time
		# if $?4, use it as mem.trace file.
		# if $?5 &   1 don't erase
		# if $?5 &  10 don't scale in x
		# if $?5 & 100 don't scale in y
		local define pt <$ptype>  ptype 4 1
		if($?1 == 0) { define 1 0 }
		if($?2 == 0) { define 2 0 }
		if($?3 == 0) { define 3 0 }
		if(!$?4) { define 4 0}
		if('$4' == '0') { da mem.trace } else { da $4 }
		if(!$?5) { define 5 0}

		read '%d %d %d %d %d %f %f%*[ ]%[^@]' { ser tot actual use pool utime stime when }
		set when=quote_TeX(when)
		define i local
		foreach i ( tot actual use pool ) { set $i=$i/(1024*1024) }
		if(!$1) {
		   set tot = tot - (use + pool)
		   set actual = actual - (use + pool)
		}
		set ttime = utime + stime
		if($3) {
		   if($3 == 1) {
		      set ord = ttime
		   } else {
		      set ord = utime
		   }
		} else {
		   set ord = ser
		}
		if(!($5 % 10)) { 
		   ERASE 
		}
		if(!(int($5/10) % 10)) { # rescale in x
		   lim (ord concat ($2>2?1:$2==2?1.2:1.4)*ord) 0 0
		}
		if(!(int($5/100) % 10)) {
		   echo lim 0 0 (0 concat tot concat use concat pool)
		   lim 0 0 (0 concat tot concat use concat pool)
		}

		bo

		define nlab 40 
		if($2 <= 2) {
		   set ptord local
		   define i <$ptype>
		   local set pt=when
		   if($2 >= 2) {
		      local set l = \
		          (index(pt,'start field') != -1 || \
		          index(pt,'Aborting') != -1 || \
		          ($verbose > 0 && index(pt,'parent objects') != -1) ||\
		          index(pt,'Timer expired') != -1 || \
		          do(1,dimen(pt)) == dimen(pt))
		      set ptord = ord if(l)
		      set pt = pt if(l)
		   } else {
		      set ptord = ord
		   }
		   set pt='|\\smash{-'+pt+'}' if(ptord > $fx1)
		   ptype pt 
		   set i=0,dimen(ptord)-1
		   set i = 1.0*modulo(i,$nlab)/$nlab
		   set i=$fy1+0.05*($fy2-$fy1) + i*0.95*($fy2-$fy1)
		   poi ptord i  if(ptord > $fx1)
		   ptype $i
		}
		if($2 == 1) {
		   set ss=ptord concat ptord sort { ss }
		   set v=1,dimen(ss) set v=int(v/2) set v=(v-2*int(v/2)==0 ? 1e4 : -1e4)
		   ltype 1 con ss v ltype 0
		}
		ctype cyan lt 2 con ord pool lt 0
		if($2 < 2) { poi ord pool }
		ctype green con ord tot
		ctype default lt 2 con ord actual lt 0
		if($2 < 2) { poi ord tot }
		ctype red con ord use ctype default
		if($2 < 2) { poi ord use }
		if(!$?_ix) { local define _ix 1 }
		if(!$?_iy) { local define _iy 1 }
		if($_iy == 1) {
		   if($3) {
		      if($3 == 1) {
		         xla Total time/seconds (user + system)
		      } else {
		         xla User time/seconds
		      }
		   } else {
		      xla Memory ID
		   }
		}
		if($_ix == 1) {
		   yla Mbytes
		}
		ptype $pt
		#
types      11	#Plot the files where memory was allocated as different symbols
		set cusize=cumulate(usize)
		lim (ord concat 1.4*ord) cusize box
		xla Memory ID
		yla Mbytes (user)
		do 9=0,dimen($1)-1{
		   set ss=id if(file == $1[$9])
		   set cus=cusize if(file == $1[$9])
		   con ss cus
		   putl 6   $($1[$9])
		}
		
waste      11	da mem.trace
		read '%d %d %d %d%*[ ]%[^@]' { ser tot use pool when }
		set i=0,dimen(tot)-1 set i=3e6 + i/i[dimen(i)-1]*(tot[dimen(tot)-1] - 3e6)
		ERASE lim (ser concat 1.4*ser) tot 
		#lim 629944 629970 tot
		#lim 306447 306645 tot
		box
		ctype red con ser use poi ser use
		ctype cyan con ser pool poi ser pool
		ctype default con ser tot poi ser tot
		define 2 <$ptype>
		set pt='|\\smash{-'+when+'}' if(ser > $fx1) ptype pt 
		poi ser i if(ser > $fx1)
		ptype $2
		if(!$?1) {
		   set ss=ser concat ser sort { ss }
		   set v=1,dimen(ss) set v=int(v/2) set v=(v-2*int(v/2)==0 ? 1e9 : -1e9)
		   ltype 1 con ss v ltype 0
		}
		xla Memory ID
		yla Mbytes
		#
speed	13	# Tell me how fast photo's running
		# Usage: speed field0 [fac] field]
		#
		# Use the cursor to mark the _beginning_ of field field;
		# the time per field will be multiplied by fac and printed
		local define field0 $1

		if($?2) {
		   local define fac $2
		} else {
		   local define fac 1
		}
		
		if($?3) {
		   define field $3
		} else {
		   define field ? {Current field}
		} 
		local define nfield ( $field - $field0 )

		echo Move the cursor to the start of field $field and hit button-3
		CURSOR
		echo $(sprintf('%.1f',$fac*$uxp/$nfield)) sec/field
