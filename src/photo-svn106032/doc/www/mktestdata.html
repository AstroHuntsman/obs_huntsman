<HTML>
<HEAD> 

<TITLE>  Making Your Images Run Under Photo</TITLE>
<BODY>

<H1>Making Your Images Run Under Photo</H1>

<P>
A description of what is required to change the input data to photo is
given in the <EM> Changing the Input Data </EM> section of the <A
HREF="photo.howto.html">How to Use the Photometric Pipeline</A>
document. 

<P> Here we describe TCL procedures designed to make setting up the
data painless and fun. The procedures assume that the images are fully
reduced and are stored as scaled integers (floating point images will
have their pixel values rounded to the nearest integer when they are
converted to U16). You must create a directory to hold the new data
which should have subdirectories called <EM> input </EM> and <EM>
output</EM>.

<P> If you do not have a your own checked out version of photo, the
first thing to do is to setup photo:

<LISTING>
% setup photo
</LISTING>

This sets the environment variables PHOTO_DIR and PHOTODATA_DIR.
PHOTODATA_DIR is used by the mktestdata procedure to find template
parameter files.  

<P> Run photo and cd into the <EM> input</EM> subdirectory of the directory
you made to contain your test data. You must source the file that
contains the TCL procedures:

<LISTING>
photo> source $env(PHOTO_DIR)/etc/mktestdata.tcl
</LISTING>

<P> How to proceed from here depends on how many sets of images you have
and whether you want to specify the psfs and offsets between filters,
determine them interactively, or use the defaults. Below we give some examples.
First the simple case of two images in different filters
using the default (zero pixel) offsets and psfs. Suppose you have just
two images in two filters (g and r). Then run mktestdata as follows. 

<LISTING>
photo> mktestdata {foo.fit bar.fit} {g r} 0 1 
</LISTING>

<P> Here 0 is the frame number and 1 is the ccd column. This procedure
will create the raw images
R-1-<EM>ccdcol</EM>-<EM>filter</EM>-<EM>frame</EM>.fit, the bias
vectors B-1-<EM>ccdcol</EM>-<EM>filter</EM>.fit, the flat vectors
FF-1-<EM>ccdcol</EM>-<EM>filter</EM>-<EM>frame</EM>.fit, the
calibration table CB-1-<EM>ccdcol</EM>-<EM>frame</EM>.fit (which
contains any information on offsets between bands, psfs and
photometric calibration), the data processing plan  and the hardware
and software parameters files. 

However, we are not quite done yet. If you have  another set of
images (the same size with the same filter set) that you want to run
together with the first, you can run mktestdata again, incrementing
the frame number each time. In any case, whether you make one or
several frames, you must make the overlap image with the command

<LISTING>
photo> mkoverlap {imagelist} {filterlist} $frame $ccdcol
</LISTING>

where $frame is a number one greater than last frame you made with
mktestdata. You will need to modify the data_processing_plan to
reflect the number of frames you made, set <EM>startframe</EM> to the
number of the first frame and <EM>endframe</EM> to the number of the
overlap image. If you run mktestdata again, it will overwrite these
changes. 

<P> Here's another example. Suppose you want to set the calibration
parameters (psfs and offsets) and you already know what the values
are. The form of the psf is described <A HREF="tclDgpsf.html">here</A>.
To set the psf by hand, you must know sx1, sy1, sx2, sy2,  and b. 

<P>The transformation is defined by 
<pre>
        (r2)         (a)      (b  c) (r1)
        (  )    =    ( )  +   (    ) (  )
        (c2)         (d)      (e  f) (c1)
</pre>

<P>
For a unary transform a=c=d=e=0 and b=f=1. For a constant shift in
rows and columns a=dr, d=dc, c=e=0 and b=f=1.

<P> The photometric calibration consists of the number of counts in
each filter (plus the error) corresponding to a 20th magnitude star,
as seen above the atmosphere. 

<P> You can put all this information into the calibration file used by
photo with the mktestdata command above. Mktestdata has a number of
optional parameters that are grouped into 3 sets: psf parameters,
offset parameters, and photometric calibration parameters. The
complete form of the mktestdata command is

<LISTING>
photo> mktestdata imagelist filterlist frame ccdcol sx1 sy1 sx2 \
                sy2 psfratio a b c d e f mag20 mag20 
</LISTING>

The optional parameters must be given in that order. You can leave
parameters off the end of the list, but you can not skip any. For
example, you could use defaults for all parameters, all but the psf
parameters, all but the psf and offsets, or none of the parameters.
If you set one parameter in each set, you must set all the parameters
in each set, otherwise the procedure will not work. (It does not
currently check that you do so). Each optional parameter should
be a list of values, one for each filter, or else it should be a single 
value which will be used for all the filters (not very useful for the
offsets). Below are several examples of commands where the inputs are
set by hand. 

<LISTING>
photo> mktestdata {foo.fit bar.fit} {g r} 0 1 

photo> mktestdata {foo.fit bar.fit} {g r} 0 1 3.9 3.9 1.8 1.8 .9 

photo> mktestdata {foo.fit bar.fit} {g r} 0 1 {3.9 4.2} {3.9 4.7} {1.8 1.2} \
            {1.8 1.3}  {.9 .8}

photo> mktestdata {foo.fit bar.fit} {g r} 0 1 3.9 3.9 1.8 1.8 .9  \
        {5 0} {1 1} {0 0} {10 0} {0 0} {1 1}

photo> mktestdata {foo.fit bar.fit} {g r} 0 1 3.9 3.9 1.8 1.8 .9  \
        {5 0} {1 1} {0 0} {10 0} {0 0} {1 1} \
        {1304 899} {45 28}
</LISTING>

However, most often you will not know ahead of time what values
all these parameters should have. Fortunately, they can be determined
interactively using the findpars procedure. For example

<LISTING>
photo> findpars {foo.fit bar.fit} 3 6 
</LISTING>

would display the images, tell you to click on stars or objects until
it had 3 good psf candidate stars on each frame and 6 objects in
common between the frames from which to determine the offsets. The
calculated values of the psfs and offsets are stored in the global
variables sx1, sy1, sx2, sy2, psfratio, a, b, c, d, e, and f. 
Findpars will not determine the photometric calibration, but it does
print out the aperture counts of the stars used to determine the psf,
so, if you know their magnitude, you can determine the calibration. 

<P>
To use findpars, you must
first create a file on disk called <EM>params</EM> that contains the
following lines:
<LISTING>
star1_regsize   29      # Size of region to cut out around star
star1_aperrad    5      # radius (in pixels) of aperture used for photometry
psf_min_val     50      # min peak pix value for star used in PSF creation
psf_max_val     25000   # max peak pix value for star used in PSF creation
psf_dev_sig     1.5     # max tolerance in stdev of fit params from mean
                        # for an acceptable PSF star
</LISTING>
with the appropriate values for your data. 

<P>
After running findpars, you can call mktestdata as follows:

<LISTING>
photo> mktestdata {foo.fit bar.fit} {g r} 0 1 $sx1 $sy1 $sx2 \
             $sy2 $psfratio $a $b $c $d $e $f 
</LISTING>

Then, after calling mkoverlap, you are ready to run photo.

<P> One final example. The following script will take one image in two bands 
and do everything, from determining offsets etc to making the overlap image:


<LISTING>
proc doit {} {
    global sx1 sy1 sx2 sy2 psfratio a b c d e f 
    set imagelist {B2053.fit V2051.fit} 
    findpars  $imagelist 2 3 
    mktestdata $imagelist {g r} 0 1 $sx1 $sy1 $sx2 $sy2 $psfratio  $a $b $c $d $e $f
    mkoverlap $imagelist {g r} 1 1
}
</LISTING>



