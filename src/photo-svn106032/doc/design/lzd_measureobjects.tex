
\subsection {Introduction}

  The Measure Objects module has three goals:

\begin {description}
\item [A] measure a set of parameters (size, brightness, position, etc.)
             for every object in a field, in all colors
\item [B] de-blend objects which overlap each other
\item [C] using some subset of those parameters, classify the object as
   \begin {description}
   \item [1] star, galaxy or other
   \item [2] for galaxies, classify type of galaxy as far as possible
   \end {description}
\end {description}

  Let me address each of these three goals in order.

\subsection {Measuring Parameters}

  The Level Zero implementation performs goal A adequately, although 
it may not measure all parameters in the most efficient manner.
I include here a document that describes all the parameters 
in an OBJECT1 structure, the manner in 
which each is calculated, and the function that does the work: 

\begin{verbatim}
========================================================================

   int npixels          number of rows in region times number of cols
                            (frames_pipeline_procs.tcl)

   float rowc           first moment of pixels > 0 after sky subtraction,
                            in a rectangular region with sides 3*FWHM
                            of gaussian fitted to object (find_moments);
                            if cannot be calculated, use the position
                            of the peak pixel (calc_params) in object.

   float rowcErr        not calculated, set to 0.0

   float colc           see rowc
                            
   float colcErr        not calculated, set to 0.0

   float ra             not calculated, set to 0.0

   float raErr          not calculated, set to 0.0

   float dec            not calculated, set to 0.0

   float decErr         not calculated, set to 0.0

   float skyLevel       the value of the "background frame" at the 
                        position of the center of the object;
                        the "background frame" is calculated by
                          a. finding the median inside a set of large boxes
                          b. interpolating bi-linearly between median values
                             at box centers
                                 (phMedianFrame2, phAssignSky)

   float skySig         calculate stdev from the mean of the pixels
                        in a rectangular annulus around object edges
                                 (phLocalSkyForObject1)

   int npix             count all pixels which have MASK_OBJECT set
                        in the object's mask; all colors are considered
                        together.
                                 (calc_params)

   int nsat             count all pixels which have MASK_SATUR set
                        in the frame MASK and are marked as part of 
                        the object; one color only is considered.
                                 (build_bright)

   int npeaks           look at all pixels which have MASK_OBJECT set
                        in object's MASK (considering all colors);
                        count all such pixels which have eight neighbors
                        around them with values larger than 0 but smaller
                        than that of the pixel in question.  This may pick
                        up low noise peaks in u', say, which are really
                        part of the object only in z'.
                                 (find_peaks)

   int blend            set to 0 if object returns unchanged by deblender
                               1 if object had children found inside it
                               2 if object is a child of another object
                                 (adopt_children)

   float w_xx           a. calculate FWHM of gaussian fitted to marginal
                           sum of all pixels with MASK_OBJECT set 
                        b. construct rectangle with sides 3*FWHM, 
                           centered on (rowc, colc)
                        c. ignore all pixels with sky-subtracted value
                           less than zero inside rectangle
                        d. using all other pixels (including perhaps
                           those outside marked extent!), calculate
                           second moment (row*row)
                                  (calc_params)

   float w_xy           see w_xx, but with (row*col)

   float w_yy           see w_xx, but with (col*col)

   enum bright_type     set to BRIGHT_UNK (0)
                                  (measure_properties)

   enum faint_type      if FWHM of object within reasonable range,
                        and PSF_fit chisq < critical value, 
                               --> FAINT_STAR (1)
                        else if FWHM > stellar limit in both directions
                               --> FAINT_GAL (2)     
                        else if FWHM < stellar limit in both directions
                               --> FAINT_CR (3)
                        else if ratio of FWHM in the directions > critical
                               --> FAINT_DEFECT (4)
                        else
                               --> FAINT_UNK (0)
                                  (classify; see also combine_types)

   float apCounts       sky-subtracted sum of all pixels which fall within
                        circular aperture of fiber radius, regardless of
                        MASK values.  Pixels falling partway inside
                        aperture given only fractional weight.
                                  (calc_aper_stuff)

   float apErr          sqrt of the sum of the squares of the 'noise'
                        region values for all pixels included in 
                        apCounts aperture.  Q: should this include
                        another term for sky-subtraction?
                                  (calc_aper_stuff)

   float apRad          set to radius of fiber aperture, in units
                        of pixels; this is the same constant for all objects
                                  (find_extent)

   float psfCounts      sum of all counts under the fitted model of the 
                        PSF, extrapolated to radius of infinity
                                   (obj_chisq)

   float psfErr         see psfCounts

   float fibreCounts    set to same value as apCounts; probably we should
                        delete this parameter
                                  (calc_aper_stuff)

   float totalCounts    a. start at the "xc" and "yc" position
                        b. ignore all pixels with MASK_SATUR or MASK_NOTCHECKED
                        c. calculate sum of all sky-subtracted pixels inside
                           circular annuli (use integral pixels, no fractional
                           pixels, so each annulus not truly a circle).  Use
                           apertures with radius 1, 2, 3, 4, etc. 
                        d. go outwards in radius until either
                              1. total counts/area <= a constant
                              2. total radius >= a limit (currently 150 pixel)
                        e. set totalCounts to sum of all counts to this radius
                                   (moTotalCounts)

   float totalRad       set to the radius at which we stop growing annuli
                        for totalCounts
                                   (moTotalCounts)

   float petroRad       given constant petr_inner, petr_outer, petr_ratio
                        loop over radii: 1, 2, 3, 4, ...
                          set rad_inner = (int) radius*petr_inner
                          set rad_outer = (int) radius*petr_outer
                          set annulusCounts = total integrated counts
                                 between rad_inner and rad_outer
                          if (annulusCount/totalCount < petr_ratio)
                                 stop
                        set petroRad = radius
                                   (find_petrosian)

                        Note that we do NOT interpolate in the radial
                        profile, which will be important because the
                        typical value is only 3-6 pixels; we should
                        interpolate, I think.

                        Note also that we do not have a parameter which
                        saves the value of the radial profile at this
                        Petrosian radius; we should add one.

   float psf_xc         fit a double-gaussian PSF model to the data
                        at radii between two constant limits (inner one
                        is currently 0, outer is currently 5.0 pixels),
                        ignoring pixels with MASK_NOTCHECKED or 
                        MASK_SATUR.  Set psf_xc to the row center position
                        from the fit.
                                   (obj_chisq)
 
                        The implementation of the PSF-fit is very slow,
                        and accounts for a large fraction of the total
                        pipeline execution time.  I have not been able
                        to test its degradation with increased speed.

   float psf_yc         set to the col center of the PSF-fit.
                                   (obj_chisq)

   float psf_amp        set to the amplitude of the PSF-fit; this is NOT
                        properly normalized, and needs to be fixed.
                                   (obj_chisq)

   float psf_chisq      set to the chi-square of the PSF-fit; this seems
                        not to be properly calculated, but I'm not sure.
                                   (obj_chisq)
    
   float majaxis        using the w_xx, w_xy and w_yy parameters already
                        calculated, find the major axis.  Result is in
                        degrees, with 0 degrees meaning "along a column"
                        and 90 degrees meaning "along a row".
                                   (find_axes)

   float minaxis        see majaxis
                                   (find_axes)

   float eccen          using w_xx, w_xy and w_yy parameters already
                        measured, calculate eccentricity via
                             eccen = 1.0 - (Maa / Mbb)
                        where Maa is smaller of w_xx and w_yy, Mbb is larger
                                   (find_axes)

   float gauss_xc       a. calculate marginal sum of pixel values along
                           the row-direction, using all pixels with mask
                           values of MASK_OBJECT
                        b. attempt to fit a 1-D gaussian to the marginal sum
                        c. set gauss_xc to the fitted center, or, if fit fails,
                           to BADVALUE = -99
                        
   float gauss_yc       see gauss_xc

   float gauss_wx       set to FWHM of fitted gaussian described for gauss_xc

   float gauss_wy       see gauss_wy

   int nprof            There are a fixed set of 10 radii at increasing
                        spacing: 1, 2, 4, 8, ... pixels.  Set nprof to the
                        index of the first spacing larger than totalRad, 
                        calculated above.  Thus, if totalRad = 5, then
                        nprof = 4.  There will be 'nprof' entries in each
                        of the following six parameter arrays; all entries
                        after the number 'nprof' will be set to zero.
                                   (count_profile)

   float profRad[10]    radius of n'th aperture for which the following
                        parameters are measured:
                                   (do_aper_stuff)

   float profMean[10]   mean of sky-subtracted pixels (ignoring MASK_SATUR
                        and MASK_NOTCHECKED) in the annulus between radius
                        profRad[N-1] and profRad[N].
                                   (do_aper_stuff)

   float profMed[10]    median of pixels in annuli
                                   (do_aper_stuff)

   float profStdev[10]  standard deviation of the mean of pixels in annuli
                                   (do_aper_stuff)

   float profRatio[10]  a. consider circular apertures of radius profRad[N]
                        b. ignore pixels with MASK_SATUR or MASK_NOTCHECKED
                        c. subtract sky, ignore all pixels with value < 0
                        d. calculate intensity-weighted zero'th, first and
                           second moments inside each aperture
                        e. calculate ellipse using moments
                        f. set profRatio[N] to axis ratio of ellipse
                                   (mo_findellipse)

   float profAngle[10]  set to position angle of major axis of ellipse
                        fitted in description of profRatio.  Angle is 
                        expressed in degrees, with 
                             0 degrees = along columns "up-down"
                            45 degrees = "up-right" to "down-left"
                            90 degrees = along rows "left-right"
                           135 degrees = "up-left" to "down-right"
                                   (mo_findellipse)

   float xc             Bright Objects, before mergeColors:
                            a. find rmin, rmax: extent of MASK_BRIGHTOBJECT
                                  pixels in row direction
                            b. set xc = 0.5(rmin + rmax)
                                    (build_bright)
                        Bright Objects, after mergeColors:
                            set xc = position of peak pixel with MASK_OBJECT
                            bit set in the object's mask
                                    (phSimpleParameters)

                        Faint Objects, before mergeColors:
                            a. find peak pixel value of all MASK_OBJECT pixels
                            b. if possible, fit parabola to peak pixel,
                                  pixel at row-1, pixel at row+1; set xc
                                  to center of parabola
                            c. if not possible to fit parabola, set xc to
                                  peak pixel position
                                    (phRegPeakFind) 
                        Faint Objects, after mergeColors:
                            set xc = position of peak pixel with MASK_OBJECT
                            bit set in the object's mask
                                    (phSimpleParameters)
                       
   float yc             see xc

   float fiso           sum of sky-subtracted counts of all pixels with 
                        MASK_OBJECT set
                                    (expand)
                        same, but using union of pixels marked in all colors
                                    (phObjSimpleParameters)

   float xmin           minimum row in which a pixel belonging to this object
                        (i.e. with object's mask MASK_OBJECT bit set) extends
                                    (expand)
                        same, but using union of pixels marked in all colors
                                    (phObjSimpleParameters, calc_params)

   float xmax           maximum row of object extent; see xmin

   float ymin           minimum column of object extent; see xmin

   float ymax           maximum column of object extent; see xmin

   float peak           sky-subtracted value of peak pixel
                                    (phRegPeakFind)
                        same, but using union of pixels marked in all colors
                                    (phObjSimpleParameters, calc_params)
   
   long ipeak           row position of peak pixel value in object
                                    (phRegPeakFind)
                        same, but using union of pixels marked in all colors
                                    (phObjSimpleParameters, calc_params)
                              
   long jpeak           see ipeak
                          
   float Mxx            set to 0.0, never calculated; should be deleted

   float Myy            set to 0.0, never calculated; should be deleted

   float Cin            a. use parameters 'fiso' and 'npix' calculated already
                        b. calculate effective rad R = sqrt(npix/PI)
                        c. choose L = integer radius closest to 0.3*R
                        d. use circular radial profile, tabulated at
                           integer radii (no interpolation), calculated
                           above for "totalCounts"
                        e. set Cin = profile[L] / fiso, or use BADVALUE = -99
                           if fiso <= 0.0
                                     (calc_jpg_params)
 
                        Question: replace 'fiso' with 'allCounts' ??
   
   float SB             a. use parameter 'fiso' and 'npix' calculated already
                        b. set x = fiso / npix
                        c. use surface-brightness limit used to calculate
                           totalCounts; this is a constant for all objects
                           in each color
                        d. calculate ratio of x to surface-brightness limit,
                           convert to magnitudes; example: if x = 23.5 mag
                           per sq. arcsec, and surface-brightness limit for
                           total magnitude is 22.0, then set 
                              SB = 23.5 - 22.0 = 1.5
                                     (calc_jpg_params)

                        Question: replace 'fiso' with 'allCounts' ??

   int blend_id         set to ID of other object with which this object 
                        is blended
                                     (phMergeObjectList)
                        set to -1
                                     (special_format)

   OBJECT1 *blend_next  set to pointer to other object with which this
                        object is blended
                                     (phMergeObjectList)
                        set to NULL
                                     (special_format)
                             
   float allCounts      set to sum of all sky-subtracted pixels which
                        have MASK_OBJECT set (in all colors) 
                                     (calc_params)

   float allCerr        set to sqrt of sum of squares of noise values
                        for all pixels with MASK_OBJECT set (in all colors)
                                     (calc_params)

   float texture        set to 0.0, never calculated

 
   long flags           set in several places; values are:

#define OBJECT1_TINY        0x1    /* object has "too few" pixels */
#define OBJECT1_LINEAR      0x2    /* object is really elongated */
#define OBJECT1_PEAKCENTER  0x4    /* couldn't calc first moment, so use */
                                   /*   pos of peak pixel in row_c, col_c */
#define OBJECT1_BLENDED     0x8    /* object is/was blended */
#define OBJECT1_EDGE        0x10   /* object touches edge of frame */
#define OBJECT1_APEREDGE    0x20   /* fiber aperture touches edge of frame */
#define OBJECT1_TOTALEDGE   0x40   /* 'total' aperture touches edge of frame */
#define OBJECT1_NOCONVERGE  0x80   /* fit to PSF did not converge */
#define OBJECT1_BRIGHT      0x100  /* object found b findBrightObjects */
#define OBJECT1_TOTALMAG    0x200  /* 'total' mag calc halted because object */
                                   /*   exceeds the 'mo_tot_rad_max' size */
#define OBJECT1_NODEBLEND   0x400  /* no deblending attempted because object */
                                   /*   exceeds the 'db_maxsize' size */

==========================================================================
\end{verbatim}

\subsection{Deblending}

  The deblending method we have chosen is the COSMOS algorithm,
as implemented at STScI by Istvan Szapudi-Laendler and Marc
Postman.  The basic idea is to assume that all objects are 
perfect two-dimensional gaussians, and, based on the locations
of local peaks, to calculate the contribution of each object
at every pixel in a merged object.  

  The deblending function contributes around 10-20\% of the 
total CPU time used by the Measure Object module; it is not
insignificant, but not very important, either. 

  We run the deblender on all objects, regardless of their
properties, in the following fashion:

\begin{verbatim}

   for each object in objectList
     measure its properties
     attempt to deblend it
     append any children to the objectList
   end of loop

\end{verbatim}

  The COSMOS deblender has the property that it ought never to find
any children in a child; it will deblend each area completely in a
single pass.  Thus, we do not have to worry about multiple levels
of children.

\subsection{Classification}

  The Level Zero module does a poor job of classification.
Our idea was to use a binary decision tree to determine optimum
classification parameters, and to perform the classification.
Unfortunately, the decision-tree code was tested as a stand-alone
program; although the code has been converted to compile together
with PHOTO, it has never been executed or tested in this form.

  In the meantime, we have settled on a simple method of classification
which is inaccurate.  See the description of the "fainti\_type"
parameter above.  The basic idea is to use the width of an object
to classify it as star (stellar width), galaxy (larger-than-stellar
width) or defect (smaller-than-stellar width).  Each object is 
classified in each passband independently.  After all five
passbands have been analyzed, the object is given an overall
classification based upon a combination of the individual types.

  There have been no comprehensive tests of this algorithm,
but informal runs show that it separates stars from galaxies
at less than a 50\% success rate, and is unacceptable.

