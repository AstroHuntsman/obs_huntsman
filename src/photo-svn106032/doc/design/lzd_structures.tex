
%
{\hfuzz=85pt			% the code is pretty wide

These structures are the structures defined in the level one pipeline,
copied from the include (but not the include/prvt) directory.
This chapter is intended to be a guide to the structures referred to 
in other parts of this document.

\subsection{Enumerated Types}

These types are needed in order to understand the structure definitions
that follow.

\begin{verbatim}
typedef enum { ... } BRIGHT_TYPE;     /* type of bright object 
					(e.g. BRIGHT_STAR) */
typedef enum { ... } FAINT_TYPE;     /* type of faint object 
					(e.g. FAINT_STAR) */
typedef enum { ... } MASKBITTYPE;     /* defines the meaning of each bit
					in the mask (e.g. saturated) */
typedef enum { ... } CATALOG;         /* name of catalogue (e.g. SAO) */

typedef enum { ... } QUALITY;         /* quality of the object */

typedef enum { ... } SYSTEM;          /* astrometric system, (e.g. J2000) */

typedef enum { ... } TIMESTANDARD;    /* time system, (e.g. CST) */

typedef enum { ... } PSF_FLAGS;       /* which psf model to use 
					(e.g. residuals) */
\end{verbatim}

\subsection{Structs}

The first two, {\tt MASK} and {\tt REGION}, are defined in the Dervish
header file {\bf region.h}.

\begin{itemize}
\item[{\tt MASK}]
These are used to store flags associated with each pixel.

\begin{verbatim}
typedef struct mask {
   char *name;          /* identifying name */
   int nrow;            /* number of rows in mask */
   int ncol;            /* number of columns in mask */
   MASK_PIX **rows;     /* pointer to pointers to rows */
   int    row0,col0;    /* location of LLH corner of child in parent */
   struct mask_p *prvt; /* information private to the pipeline */
} MASK;
\end{verbatim}

\item[{\tt REGION}]
These are the primary SDSS image type. They may own their
own storage, or point back to some other {\tt REGION} that does. All
image utilities are expected to work on {\tt REGION}s. Note that
{\tt REGION}s may have data of a wide variety of types;
there are utility functions to convert between them.

\begin{verbatim}
typedef struct region{
   char           *name;        /* a unique identifier */
   int            nrow;         /* number of rows in image */
   int            ncol;         /* number of columns in image */
   PIXDATATYPE    type;         /* pixel data type */
   U16            **rows;       /* pointer to pointers to rows */
   U8             **rows_u8;
   S8             **rows_s8;
   U16            **rows_u16;
   S16            **rows_s16;
   U32            **rows_u32;
   S32            **rows_s32;
   FL32           **rows_fl32;
   MASK           *mask;        /* associated bad pixel mask */
   int            row0,col0;    /* location of LLH corner of child in parent */
   HDR            hdr;          /* header */
   struct region_p *prvt;       /* information private to the pipeline */
} REGION;
\end{verbatim}

\end{itemize}


The remaining types are photometric-pipeline specific.

First a variety of object types; most have an associated list type.

\begin{itemize}

\item[{\tt ATLASIM}]

\begin{verbatim}
typedef struct atlasim {
   TYPE type;
   struct atlasim *next, *prev;
   int ncolors;         /* number of filters in which this object is detected */
   char **filter;       /* character corresponding to filter name */
   int **id;              /* id number of this object (from OBJECT1 struct)*/
   float **rowc;          /* row position of center*/
   float **colc;          /* column position of center*/
   REGION **reg;           /* sub region containing object */
   MASK  **regmask;        /* sub mask of which pixels are in this object */
   REGION **regnoise;     /* sub region containing pixel noise */
   MASK  **objmask;           /* sub mask of which pixels are in this object */
} ATLASIM;              /* pragma SCHEMA */
\end{verbatim}

\item[{\tt EDIT}]

\begin{verbatim}
typedef struct edit {
   struct edit *memchain;               /* link to previous node allocated */
   struct edit *link;                   /* link to previous edit command */
   enum { DELETE, INSERT, IDENTICAL } op; /* editing commands:
                                             DELETE: delete from list1
                                             INSERT: insert into list1
                                             IDENTICAL: the lists are the same
                                           */
   union {
      int n;                            /* index of element */
      void *ptr;                        /* pointer to element */
   } line1,line2;                       /* elements in lists 1 and 2 */
} EDIT;
\end{verbatim}

\item[{\tt CALIB1}]

\begin{verbatim}
typedef struct CALIB1 {
  TYPE type;
  struct CALIB1 *next;
  struct CALIB1 *prev;
  char filter[FILTER_MAXNAME];
  float sky;
  float mag20;
  float mag20Err;
  DGPSF *psf;
  TRANS *toRefcolor;
  /* Put astrometric calibration parameters here */
 } CALIB1;
\end{verbatim}

\item[{\tt CALIB1BYFRAME}]

\begin{verbatim}
typedef struct CALIB1BYFRAME {
  TYPE type;
  struct CALIB1BYFRAME *next;
  struct CALIB1BYFRAME *prev;
  int frameNum;
  int ncolors;
  CALIB1 **calib;
 } CALIB1BYFRAME; /* pragma USER */
\end{verbatim}

\item[{\tt CALIB1BYTIME}]

\begin{verbatim}
typedef struct CALIB1BYTIME {
  TYPE type;
  struct CALIB1BYTIME *next;
  struct CALIB1BYTIME *prev;
  PHTIME *time;
  int ncolors;
  CALIB1 **calib;
 } CALIB1BYTIME; /* pragma SCHEMA */
\end{verbatim}

\item[{\tt CCDDEFECT}]

\begin{verbatim}
typedef struct CCDDEFECT              /* Defect structure definition        */{
        TYPE type;
        struct CCDDEFECT *next;
        struct CCDDEFECT *prev;
        int defect_flag;
        int defect_scol;
        int defect_cval;
} CCDDEFECT;
\end{verbatim}

\item[{\tt CCDPARS}]

\begin{verbatim}
typedef struct CCDPARS                  /* A single CCD parameter record     */
{
  TYPE type;
  struct CCDPARS *next;
  struct CCDPARS *prev;
  int ccd_location;       /* CCD Location ID                   */
  int ccd_version;        /* CCD version number - to track CCD
                             upgrades or change outs           */
  int bscol1, bncol1;     /* First and Total number of columns
                             in first overscan region          */
  float readnoise1;       /* Read noise in electrons for amp 1 */
  float gain1;            /* Gain value in elec/DN for amp 1   */
  int splitcol;           /* First column in data region for amp 2 */
  int bscol2, bncol2;     /* First and Total number of columns
                             in second overscan region         */
  float readnoise2;       /* Read noise in electrons for amp 2 */
  float gain2;            /* Gain value in elec/DN for amp 2   */
  LIST *CCDDefect;       /* Pointer to linked list of defects
                             as defined in struct CCDDEFECT   */
} CCDPARS;
\end{verbatim}

\item[{\tt DGPSF}]

\begin{verbatim}
typedef struct dgpsf {
  TYPE type;
  float sigmax1;
  float sigmax2;
  float sigmay1;
  float sigmay2;
  float b;
 } DGPSF;
\end{verbatim}

\item[{\tt EXTINCTION}]

\begin{verbatim}
typedef struct EXTINCTION {
        TYPE type;
        struct EXTINCTION *next;
        struct EXTINCTION *prev;
        PHTIME *time;
        int ncolors;
        MAG **extinctionCoefficients;           /* coefficients are of type
                                                MAG; there is one for every
                                                color, stored as an array */
        QUALITY quality;
} EXTINCTION; /* pragma SCHEMA */
\end{verbatim}

\item[{\tt FLUXINST}]

\begin{verbatim}
typedef struct FLUXINST {
  TYPE type;
  struct FLUXINST *next;
  struct FLUXINST *prev;
  float flux;
  float fluxErr;
  float radius;
 } FLUXINST;
\end{verbatim}

\item[{\tt FRAMEPARS}]

\begin{verbatim}
typedef struct FRAMEPARS               /* A single FRAME parameter record     */
{
        TYPE type;
        struct FRAMEPARS *next;
        struct FRAMEPARS *prev;
        int scol2;                     /* First column of data from amp #2    */
        float readnoise1, readnoise2;  /* Read Noise levels for this CCD      */
        float gain1, gain2;            /* Gain settings (e/DN) for this CCD   */
        float skyval1, skysig1;        /* Sky statistics for data from amp #1 */
        float skyval2, skysig2;        /* Sky statistics for data from amp #2 */
        float skyint, skyslope;        /* Regression parameters for global sky*/

} FRAMEPARS;
\end{verbatim}

\item[{\tt FRAMEINFO}]

\begin{verbatim}
/* This struct will hold information about each frame */
typedef struct FRAMEINFO {
  TYPE type;
  struct FRAMEINFO *next;
  struct FRAMEINFO *prev;
  int frameNum;
  float airmass;                 /* zenith distance */
  PHTIME *time;                 /* observation time, UT */

 } FRAMEINFO;
\end{verbatim}

\item[{\tt FRSTAT}]

\begin{verbatim}
/* This struct will accumulate info about region in the frames pipeline */
typedef struct FRSTAT {
  TYPE type;
  struct FRSTAT *next;
  struct FRSTAT *prev;
  float minpix;
  float maxpix;
  float meanpix;
  float sigpix;
  float sky;
  int nbadpix;
  int nbrightobj;
  int nfaintobj;
} FRSTAT;
\end{verbatim}

\item[{\tt FRAMESTAT}]

\begin{verbatim}
/* This struct will accumulate the status for one ncolor frame in the
        frames pipeline. */
typedef struct FRAMESTAT {
  TYPE type;
  struct FRAMESTAT *next;
  struct FRAMESTAT *prev;
  int frameNum;
  float nobjects;
  float nstars;
  float ngals;
  int ncolors;
  FRSTAT **filter;
} FRAMESTAT; /* pragma USER */
\end{verbatim}

\item[{\tt MAG}]

\begin{verbatim}
/* This struct will hold the magnitude in one color for an object */
typedef struct MAG {
  TYPE type;
  struct MAG *next;
  struct MAG *prev;
  char passBand[FILTER_MAXNAME];
  float  mag;
  float  magErr;
 } MAG;
\end{verbatim}

\item[{\tt OBJC}]

\begin{verbatim}
typedef struct objc1 {
   TYPE type;
   struct objc1 *next,*prev;
   const int id;                        /* id number for this objc */
   const int ncolor;                    /* number of colours */
   OBJECT1 **color;                     /* obj1 information from each band */
   LIST *children;                      /* list of split-off objects */
   FAINT_TYPE obj_class;                /* overall classification */
} OBJC;                                 /* pragma USER */
\end{verbatim}

\item[{\tt OBJECT1}]

\begin{verbatim}
typedef struct OBJECT1 {
   TYPE type;
   struct OBJECT1 *next, *prev;
   const int  id;            /* id number of this object (set by framework)*/
   int parentid;             /* id number of parent - could be OBJC or OBJECT1*/
   char filter[FILTER_MAXNAME]; /* character filter */
   int npixels;              /* =nrow*ncol - this is need for schema heap */
   REGION *region;           /* sub region containing object */
   MASK  *mask;              /* sub mask of which pixels are in this object */
   REGION *noise;            /* noise values for pixels in object's REGION*/
   DGPSF *dgpsf;             /* Double Gaussian psf structure */
   QUALITY quality;          /* Quality of detection*/
   float rowc,rowcErr;       /* row position and error of center*/
   float colc,colcErr;       /* column position and error of center*/
   float ra,raErr;           /* RA and error of center*/
   float dec,decErr;         /* Dec and error of center*/
   float skyLevel;           /* local sky level near this object */
   float skySig;             /* local sky sigma near this object */
   long npix;                /* Number of pixels within object*/
   long nsat;                /* Number of saturated pixels within object*/
   int npeaks;               /* number of peaks in object */
   int blend;                /* isolated (0) blended (1) deblended (2) */
   float w_xx,w_xy,w_yy;     /* simple shape parameters */
   BRIGHT_TYPE bright_type;  /* classification: BRIGHT_STAR, etc. */
   FAINT_TYPE faint_type;    /* classification: FAINT_STAR, etc. */

/*
 * PSF and aperture fits/magnitudes
 */
   float apCounts,apRad,apErr; /* Counts within aperture and error */
   float psfCounts,psfErr;     /* Counts via PSF-fitting and error */
   float fibreCounts;          /* Counts within 3" fibre at center of psf fit*/
   float totalCounts;          /* Counts defining a "total magnitude" */
   float totalRad;             /* Radius (pix) defining a "total magnitude" */
   float petroRad;             /* analog to "Petrosian radius" (pix) */
   float psf_xc;               /* PSF-fitted x center */
   float psf_yc;               /* PSF-fitted y center */
   float psf_amp;              /* PSF-fitted amplitude */
   float psf_chisq;            /* goodness-of-fit to PSF (small==good) */

/*
 * Profile and extent of object
 */
   float majaxis;            /* angle of major axis (degrees) */
   float minaxis;            /* angle of minor axis (degrees) */
   float eccen;              /* eccentricity (from second moments) */
   float gauss_xc;           /* x center of gaussian fitted to marginal dist*/
   float gauss_yc;           /* y center of gaussian fitted to marginal dist.*/
   float gauss_wx;           /* x width (FWHM) of gaussian  */
   float gauss_wy;           /* y width (FWHM) of gaussian  */
   int   nprof;              /* num of valid profile values in arrays */
   float profRad[NELLIP];    /* semimajor axis of circular annuli */
   float profMean[NELLIP];   /* Radial profile, mean within annuli */
   float profMed[NELLIP];    /* Radial profile, median within annuli */
   float profStdev[NELLIP];  /* Radial profile, stdev from mean in annuli */
   float profRatio[NELLIP];  /* ratio of major/minor axes of ellipse fit */
   float profAngle[NELLIP];  /* pos angle of major axis of ellipse fit */

/*
 * Parameters from the JPG
 */
   float xc, yc;             /* intesity weighted image center */
   float fiso;               /* isophotal flux */
   long xmin, xmax;          /* image extent */
   long ymin, ymax;          /* image extent */
   float peak;               /* peak value */
   long ipeak, jpeak;        /* peak position */
   float Mxx;                /* Moment parameter */
   float Myy;                /* Moment parameter */
   float Cin;                /* concentration index */
   float SB;                 /* surface brightness */
   int blend_id;             /* the id of object1 which is blended with this */
   struct OBJECT1 *blend_next; /* pointer to object1 whose id is blend_id */

/*
 * parameters found (or used) by Measure Objects
 */
   float allCounts;          /* sum all counts from all (color) object pixels*/
   float allCErr;            /* estimated uncert in 'allCounts' */
   float texture;            /* measure of object texture/galaxy type */
   long flags;               /* flags used by Measure Objects code only */
} OBJECT1;
\end{verbatim}

\item[{\tt OFFSET}]

\begin{verbatim}
typedef struct {
   float drow;          /* centre of image needs shifting by this amount */
   float dcol;          /* centre of image needs shifting by this amount */
   float alphaxx;       /* matrix to transform to new coordinates */
   float alphaxy;       /*   1+alphaxx          alphaxy         */
   float alphayx;       /*    alphayx           1+alphayy       */
   float alphayy;       /*      operate about CENTER of shifted image   */
} OFFSET;
\end{verbatim}

\item[{\tt PSF}]

\begin{verbatim}
        /* a 2-D bivariate gaussian plus lookup table of residuals, similar
           to the structure used in DAOPHOT */

typedef struct PSF {
         TYPE type;
         struct PSF *next;
         struct PSF *prev;
    int nstars;     /* number of stars used to define PSF */
    float weights;  /* sum of weights of stars added into PSF so far */
    float sigmax;   /* sigma width (=FWHM/2.35) of gaussian in X(=row) */
    float sigmay;   /* sigma width of gaussian in Y(=col) */
    int nr, nc;     /* number of rows, cols in grid */
    float dx;       /* size of a grid unit, in image pixels */
    float **data;   /* normalized values of the empirical PSF */
} PSF;              /* pragma USER */
\end{verbatim}

\item[{\tt QUARTILES}]

\begin{verbatim}
typedef struct quartiles {
   TYPE type;
   struct quartiles     *next,*prev;
   int ntilesPercentiles[3];            /* percentages in ntiles - (25,50,75)*/
   int nr, nc;                          /* nrows and ncolumns in image */
   int tscal;                           /* factor by which the data is scaled*/
   REGION *data[3];                     /* obj1 information from each band */
} QUARTILES; /* pragma SCHEMA */
\end{verbatim}

\item[{\tt STAR1}]

\begin{verbatim}
/* This struct will hold the magnitude in one color for an object */
typedef struct STAR1 {
  TYPE type;
  struct STAR1 *next;
  struct STAR1 *prev;
  int id;
  double row;
  double rowErr;
  double col;
  double colErr;
  double ra;
  double raErr;
  double dec;
  double decErr;
  int frame;
  float skyLevel;
  float w_xx;
  float w_yy;
  DGPSF *dgpsf;
  FLUXINST *psfCounts;
  FLUXINST *apCounts;
  QUALITY quality;
  REGION *region;
  REGION *noise;
  MASK *mask;
 } STAR1;
\end{verbatim}

\item[{\tt STAR1STARCMERGE}]

\begin{verbatim}
/* This struct stores the matched objects for two sets of stars: one of
        type STAR1, and one of type STARC                               */

typedef struct STAR1STARCMERGE {
  TYPE type;
  struct STAR1STARCMERGE *next;
  struct STAR1STARCMERGE *prev;
  STAR1 *star1;
  STARC *starc;
  int starcMagPos;              /* magnitude array element that matches star1 */
  float airmass;               /* airmass at observation of star1 */
  PHTIME *time;                /* time of observation of star1 */

  float flux20;                 /* Flux in a 20th magnitude star */
} STAR1STARCMERGE; /* pragma SCHEMA */
\end{verbatim}

\item[{\tt STARC}]

\begin{verbatim}
/* This struct holds the information from one star in a catalog */

typedef struct STARC {
  TYPE type;
  struct STARC *next;
  struct STARC *prev;
  int id;
  double ra;
  double raErr;
  double dec;
  double decErr;
  PHTIME *time;         /* This must be some average of times in diff bands */
  int ncolors;
  MAG **mag;
  QUALITY quality;
} STARC; /* pragma SCHEMA */
\end{verbatim}

\item[{\tt TEMPLATE}]

\begin{verbatim}
/* This struct will hold a shape template - basically, a region */

typedef struct TEMPLATE {
  TYPE type;
  struct TEMPLATE *next;
  struct TEMPLATE *prev;
  const int id;
  REGION *region;
 } TEMPLATE;
\end{verbatim}

\item[{\tt PHTIME}]

\begin{verbatim}
/* This struct contains a time.  The time system will eventually be an
 * enumerated type.
 */

typedef struct  PHTIME {
        TYPE    type;
        struct PHTIME *next;
        struct PHTIME *prev;
        int     sec;         /* seconds after the min [0,60] */
        int     min;         /* minutes after the hour [0,59] */
        int     hour;        /* hours since midnight [0,23] */
        int     mday;        /* day of the month [1,31] */
        int     mon;         /* months since Jan [0,11] */
        int     year;        /* years since 0000 */
        TIMESTANDARD system; /* System in which time is measured */
} PHTIME;
\end{verbatim}

\end{itemize}
}				% end \hfuzz



