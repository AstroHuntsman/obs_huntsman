
\def \bom{{\bf Bright Objects\ }}

\medskip
\centerline{\it Author: Michael Richmond}
\medskip

\subsection {Introduction}

  The \bom module is responsible for ``cleaning up'' a CCD frame
so that the {\bf Find Objects} module will not have to worry about
pathological cases or extremely bright things.  Examples of 
features that the \bom module may find and deal with are bright
cosmic rays, very saturated stars, bleed trails, bright ghosts,
very bright galaxies, planets, globular clusters, bright nebulosity,
airplanes and other distracting items.  Obviously, this module can
be built in an incremental fashion, so that additional procedures
to recognize and handle different types of artifacts may be added
as time passes.

  For the Level Zero Implementation, I recommend that \bom attempt
to deal first with

\begin{itemize}
  \item all saturated objects
  \item bleed trails
  \item catalogued bright objects
\end{itemize}

and later add other code.  Note that we will probably discover new
and unexpected classes of ``contaminants'' as soon as the Test
Year begins.

  It has been suggested that this module not only identify annoying
bright things, but also attempt to remove them from the image.
I feel that we should attempt to do so in some cases, but not in the
Level Zero implementation.  Instead, I suggest that the Level Zero
\bom module simply find bright things and mark them (by setting mask
bits) so that other modules may avoid them.

\subsection {InitModule}

\subsubsection {Description}

  The initialization routine sets parameters that the main module will
use in identifying objects as ``Bright''.  It may also read information
used by some of the sub-modules which specialize in specific types of
``contaminants.''

\subsubsection {Input}

  The {\bf InitModule} reads parameters from the ``parameters file''
into memory which is private to the \bom module.  I suggest that it
use these values in particular:

\begin{itemize} 
  \item a threshold value above which pixels are classified as being
        ``Bright;''  this may be either an absolute Data Number,
        or some multiple of the sky sigma.  Any object which contains
        a pixel above this threshold is a ``Bright Object.''
  \item another threshold, down to which it will extend objects from their
        bright portions;  this should be some small multiple of the sky
        sigma
  \item (optionally) a value above which pixels are regarded as BAD
        because the Poisson noise in the number of incoming photons is
        so much larger than the typical pixel noise values that it
        becomes impossible to model and subtract them to yield useful
        ``underlying'' data
\end{itemize}

  However, after some experimentation, we may find that some other
kind of parameters are more appropriate; these are simply suggestions.

\subsubsection {Output}

  There is no output under normal operation.

\subsubsection {Modules}

  The only job of the {\bf InitModule} is to read parameter values 
into memory.

\subsubsection {Algorithms}

  Any simple algorithm will do.

\subsubsection {Quality, Debugging, Resources}

  The {\bf InitModule} should print error messages and call the standard
error-handling routine if it is unable to read the appropriate parameter
values.  

  In ``debug mode,'' the function should print out the value of 
each parameter as it succeeds in reading it from the parameters file.

  This routine will consume neglible resources.

\subsubsection {Test Data Required}

  There is no test data required.

\subsubsection {Regression Testing}

  The ``debug mode'' output should suffice for regression testing.

\subsection {Module}

\subsubsection {Description}

  The job of \bom is to identify bright things in a CCD frame that are
not (unsaturated) stars, nor (normal-sized) galaxies, and mark
them in some way so that other modules --- {\bf Find Objects}, especially ---
won't become confused by them.
Most such ``contaminants'' are clearly defects of some kind: saturated
stars, bleed trails, glints, airplane and meteor trails, bright
cosmic rays.  However, occasionally a ``real'' object will appear that
falls into its domain: very bright, large galaxies, globular clusters,
other large and bright astronomical bodies.

  Note that all bright {\it stars} (and even some marginally saturated
stars) have already been identified and removed from the frame by the
{\bf Find Bright Stars} module before it reaches the \bom module.

  There are two ways this module can deal with ``contaminants:''

\begin{itemize}
  \item mark affected pixels as BAD, so that other modules can
        avoid the regions 
  \item attempt to remove the feature, leaving a ``cleaned'' image
        in which faint objects may be sought and found
\end{itemize}

  I {\it strongly} suggest that the Level Zero pipeline take the
first approach; we may be able to remove at least some kinds of 
``contaminants'' in Level One.  If we do not attempt to remove
objects, we do not need the {\it noise mask} which has been
mentioned by some people.  I do think that such as mask is a
good idea, but feel that we should postpone it until Level One.

\subsubsection {Input}

  This module requires

\begin{itemize}
   \item a corrected frame from which bright stars have been subtracted
         (by the {\bf Find Bright Stars} module)
   \item a small set of parameters describing objects upon which it
         will act (created by the {\bf InitModule})
   \item a list of known objects in the frame, created by the 
         {\bf Research Known Objects} module
   \item a list of bright stars found in the frame by the {\bf Find Bright
         Stars} module
   \item the {\it PSF} structure for this frame (determined by
         the {\bf Find Bright Stars} module)
\end{itemize}

\subsubsection {Output}

  \bom produces two kinds of output. First, it creates a linked list of
objects, one for each of the things found in the frame.  Second, 
it sets bits in the {\it MASK} of the region, according to the following
scheme (which is common to a number of pipeline modules):

\begin{itemize}
  \item for each pixel which it determines is part of a Bright Object,
        the module sets a single bit which indicates 
        ``this pixel belongs to some object''
  \item another two bits in the {\it MASK} state that a pixel is
        OK, FIXED or BAD (meaning that the pixel has no problems,
        had a problem which has been fixed, or still has a terrible
        problem, respectively), which are set as follows:
  \begin{itemize}
    \item saturated pixels are set to BAD
    \item pixels with values higher than some critical value (see Input
          section of {\bf InitModule} above) are also set to BAD
  \end{itemize}
\end{itemize}

  {\it IF} the module attempts to model features and subtract them from
the image --- which may not be done in the Level Zero Implementation ---
then it will produce two additional kinds of output:

\begin{itemize}
  \item the {\it REGION} data values will be modified whereever
        features are removed from the frame
  \item then any pixels not already marked as BAD in such a subtracted 
        region are set to FIXED
\end{itemize}

  Note that in this case, we would have to make COPIES of the Bright
Objects after identifying them and write postage stamps around them
into the database, since they are removed from the image.
In fact, we would need to make sure that the subtracted Bright Objects
were not later part of a big list of objects for which postage
stamps were cut out, since they would no longer be part of the frame.

\subsubsection {Modules}

  \bom is a task easily separated into a number of sub-modules, especially
in later versions when we may have a number of routines to deal with
individual types of image defects.  However, the following are
certainly tasks that the module must accomplish:

\begin{itemize}
  \item identify Bright Objects, following some definition
  \item create a structure for each one, fill it with an appropriate amount
        of information, and add it to the linked list of Objects
  \item attempt to classify a Bright Object (is it a cosmic ray, or a
        bleed trail, or an airplane, etc.)
  \item attempt to match an object with an item from the list of Known
        Objects from catalogs
  \item mark all the {\it MASK} pixels in a Bright Object
\end{itemize}

  {\it IF} the module attempts to remove features, it must in addition

\begin{itemize}
  \item cut out a postage stamp around the Object and write it to
        the database (and make sure that the Object isn't cut out
        as a postage stamp by any later modules)
  \item fit a model to the Object and subtract it from the frame
  \item mark {\it MASK} pixels appropriately
\end{itemize}

\subsubsection {Algorithms}

  Although there are several different ways of identifying
bright things, I suggest a simple connected-pixel algorithm 
with a very bright object-formation threshold.  It is not
clear how far down into the sky we should go; like many other
parts of this module, experience is the only way to know
for sure.

  Recognizing an object as one of the ``contaminant'' 
types may not be easy.  Fritz suggested an algorithm for
finding linear features at the April Workshop --- he can
provide details.  Bleeding trails should be easy to recognize,
since they will be oriented exactly along the readout direction
and always have a saturated terminus.  Very bright cosmic
rays might leave distinctively sharp edges.  A list of 
possible utility routines that would be useful includes

\begin{itemize}
  \item Fritz's linear-feature finder
  \item general-purpose edge-detection (via derivatives)
  \item PSF-fitting (objects ``sharper'' than the PSF
          are likely to be defects of some sort)
\end{itemize}

  Some more sophisticated ideas are

\begin{itemize}
  \item a set of rules or tree for classifying Bright Things
          on the basis of a set of parameters
  \item a function to predict the position of ghosts and/or
          glints based on the positions of Bright Stars
          (found via the {\bf Find Bright Stars} module
          or in catalogs)
  \item a routine to check if a Bright Thing corresponds
          any catalogued object
\end{itemize}

  There are many more possibilities; obviously,
a good deal of experimentation will be required.
The function which predicts ghost images of bright
stars obviously cannot be written until the optical
design of the telescope is finished.

\subsubsection {Quality, Debugging, Resources}

  Quality Assurance is a very difficult task for this
module, because the number, relative frequency and
severity of bright stuff vary greatly from one
frame to the next.  One check would be to examine the
list of Bright Objects created by the module to see
if all the known, catalogued strange objects were
found.  It would be useful for the module to print 
a summary, in several lines, of all the things it
found for a given frame (i.e., ``15 cosmic rays,
3 bleed trails, 1 ghost''), as well as the total
number of pixels marked as belonging to Bright
Objects, and the number marked as BAD or FIXED.

  For debugging and QA, it should be possible to
display an image and blink on/off all those pixels
belonging to identified Bright Objects, all those
marked as BAD, etc.  

  It might be useful to enable only certain types
of defects to be recognized by this module, or to
disable them.  Debugging would be much easier if
only one sort of object was under consideration.

  If the connected-pixel algorithm is used to 
identify objects, an amount of memory equal to the
size of the image times one byte (roughly 3 MegaBytes)
could possibly be required if a huge object fills the
frame.  Some of the measurement routines will require
four bytes per pixel of detected objects(s), which
could again be as large as the entire frame (thus
12 MegaBytes).  The \bom module can require very
large amounts of memory, and will also need quite
a bit of CPU time.  

\subsubsection {Test Data Required}

  We will need many examples of every sort of ``contaminant''
which we wish to detect.  Several of them --- bleed trails,
cosmic rays --- may be available from the camera group
during engineering tests; talk to Jim Gunn.  
In order to test the ghost prediction-and-finding routine,
we will need a complete optical design of the telescope and
ray-tracing software.  In order to test our ability to
recognize big, bright galaxies, globular clusters, etc.,
we will need images of such objects {\it and} 
a set of catalogs (real or simulated) in which the
galaxies, etc., are listed.

  We will need a set of images which include the entire
gamut of possible ``contaminants,'' together with 
real or simulated catalogs, in order to make sure that
we can handle all the defects we've imagined.  
I don't know how to test for defects we {\it haven't}
considered!

\subsubsection {Regression Testing}

  Verifying that the output of \bom is correct requires
a tool which can compare lists of numerical data with 
``fuzzy'' comparison.  That same tool can be used to
test other modules ({\bf Find Objects, Measure Objects}).
It would help if, when the pipeline was placed into 
a certain ``debug mode,'' this module could produce
output lists with all numerical values rounded to 
some intermediate precision (either fixed, or based on 
the debugging level).

\subsection {FiniModule}

\subsubsection {Description}

  The {\bf FiniModule} basically has to free any memory
which was allocated by the {\bf InitModule}.  However, 
it would be useful if it also could, upon demand,
produce a list (either of structures, or an ASCII file)
summarizing the results of \bom on all frames processed
in the current run.

\subsubsection {Input}

  The only input comes from information the module
has been keeping in private data space during the 
module operation.

\subsubsection {Output}

  No output is required from the code which frees memory.

  I suggest that the {\bf FiniModule} produce an ASCII
list summarizing the number and type of Bright Objects
detected during the entire pipeline execution.
This list could be used for QA, debugging, or as a
scientific product in its own right.

\subsubsection {Modules}

  There are two functions:

\begin{itemize}
  \item free memory
  \item create and print summary
\end{itemize}

\subsubsection {Algorithms}

  Both functions can use straightforward methods.
We need only simple statistics in the summary.

\subsubsection {Quality, Debugging, Resources}

  The memory-freeing routine will call standard error
functions if it has a problem.  It will consume negligible
resources.

  The summary routine might make sanity checks
on its statistics before printing them (for example,
it might check to see if there were negative numbers
of any sort of defect, or more defects than pixels, etc.).
It would help telescope operators if they knew what 
kind of summary was typical; thus, the following
might be nice: ``there were 25 cosmic rays per frame on
average ... (typical value: 23).''

  No significant amounts of memory or CPU time will
be required.

\subsubsection {Test Data Required}

  We will use the ``standard set frames with Bright Objects''
mentioned above to verify that the summary list
is calculated correctly.
  
\subsubsection {Regression Testing}

  Comparing the summary lists can be done with a byte-
by-byte comparison program.

% end of section


