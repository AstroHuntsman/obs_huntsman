<HTML>
<TITLE>Correct Frames</TITLE>
<H1>The Correct Frames Module</H1>

There are two parts of the correct frames module; the production of
flat fields and biases in the <A HREF=psp.html#psp>postage stamp pipeline</A>,
and the correction of raw data in the <A HREF=#frames>frames
pipeline</A>.

<H2><A name=frames>Correcting Raw Frames</A></H2>

<UL>
<LI><A HREF=#frames_inputs>Inputs</A>
<LI><A HREF=#frames_algorithms>Algorithms</A>
<LI><A HREF=#frames_outputs>Outputs</A>
</UL>

<H3><A name=frames_inputs>Frames Pipeline Inputs</A></H3>

The inputs to the correct frames module are:

<UL>
<LI><A HREF=#raw_data>The raw pixel data</A>
<LI><A HREF=#bias_vec>A 1-D bias vector</A>
<LI><A HREF=#flat_vec>A 1-D inverted flat-field vector</A>
<LI><A HREF=#ccdpars>A CCDPAR structure</A>
<LI><A HREF=#drifts>The bias drift for both left and right amplifiers</A>
</UL>

<H4><A NAME=raw_data>The raw pixel data</A></H4>

The correct frames module can accept two forms of raw data, either complete
frames (including overscan region), or subregions (which must <EM>not</EM>
have overscan regions attached); the latter are used by the PSP to
flat field postage stamps.
<P>

<H4><A name=bias_vec>A 1-D bias vector</A></H4>

The bias vector must be the full width of the chip with overscan
regions removed. It's scaled up by
some value, <CODE>TSCALE</CODE>, that's specified in the header.
<P>

<H4><A name=flat_vec>A 1-D inverted flat-field vector</A></H4>

The flat vector is the full width of the chip with overscan
regions removed. It is scaled as described
in the section on <A HREF=psp.html#reduced>PSP algorithms</A>.

<H4><A name=ccdpars>A CCDPAR structure</A></H4>

The following elements of the CCDPAR structure are used:
<UL>
<LI> The location of the overclock regions
<LI> How the data is split between amplifiers
<LI> The amplifiers' readnoise (in electrons) and gain (electrons/DN)
<LI> The list of bad columns (<EM>double-column defects should be
specified as a pair of single-column defects; they are processed correctly
despite this requirement</EM>)
</UL>

<H4><A name=drifts>The left and right bias drifts</A></H4>

How much the bias level of the right and left amplifiers has drifted
relative to the bias vector.

<H3><A name=frames_algorithms>Frames Pipeline Algorithms</H3></A>

First the entire frame is searched for saturated pixels (using a different
threshold for each amplifier of two-amplifier chips), which are
grouped into <CODE>OBJMASK</CODE>s in the <CODE>MASK_SATUR</CODE>
mask. Because a saturated pixel may have bled into its neighbour above
or below it, but the resulting pixel value may be below threshold, an
additional pixel at above and below each saturated column is added to
this mask.  In addition, if <CODE>extra_bad_satur_columns</CODE> is
specified in the <CODE>fpParam.par</CODE> file (default: 1), pixels
just to the left and right of the saturated <CODE>OBJMASK</CODE>
are treated as saturated; they appear to be contaminated by charge transfer
problems in the serial register.
<P>

There are also effects that look like bias variations due to bright
stars generating charge as they cross the serial register, which is as
light-sensitive as any other part of the detector and is not masked on
our CCDs.  To remove these, we monitor the median value of the
overclock and bias (extended register) pixels.  While doing this, we
note that the extended register was pixels were read <EM>before</EM>
the data region, so the value from the previous row should be used. If
the correction is greater than half a DN we linearily interpolate between
the value from the left and the right of the chip (or to the centre for
two-amplifier chips) and subtract the result.
<P>

Each pixel that is not saturated is then bias subtracted (allowing for bias
drifts) and divided by the flat field (or, more precisely, multiplied by
the inverse flat field). The <A HREF="misc.html#softBias">soft_bias</A>
is then added back to keep all pixel values positive.
<P>

<A NAME="saturation_level"></A>
Because of the way that the flat field is normalised, a low-sensitivity pixel
that isn't saturated in the raw frame can have a value too large to fit
into 16 bits after flatfielding. If this is the case, the nominal
<CODE>saturation_level</CODE> for the frame is lowered. Unless something
nasty has happened (e.g. the bias drift is wildly wrong) the adopted
saturation level should still be close to 65000.
<P>

The final stage is to interpolate over all bad pixels, including those
labelled as saturated. The algorithm used is described
<A HREF="misc.html#interpolation">elsewhere</A>. In deriving the
interpolation coefficients we assume that the signal-to-noise is infinite,
and that the PSF is a sigma=1pixel Gaussian (i.e. ~ 1" FWHM). The correction
code is machine generated, to it wouldn't be <EM>too</EM> hard to relax
these restrictions if it proved necessary.
<P>

All interpolated pixels are added to the <CODE>MASK_INTERP</CODE> mask.
<P>

Interpolation is only
carried out
using good pixels from the same row; it would be better to use a region
with larger support, but the book-keeping involved was too frightening
to contemplate (remember; we have to handle bleed trails as well as
intrinsic bad columns, and they can easily be adjacent or separated by
a single column or row).
<P>

<EM>No provision is made for non-linearity of the CCDs. XXX</EM>

<H3><A name=frames_outputs>Frames Pipeline Outputs</A></H3>

Outputs are:

<UL>
<LI> The corrected data (which <EM>must</EM> have a mask)
<LI> The corrected data's mask
</UL>

Furthermore, once the C code to correct the frame has been run, the TCL routine
<CODE><A HREF="misc.html#regStatsFromQuartiles">regStatsFromQuartiles</A></CODE>
is used to determine the global sky level (and its standard deviation).
<EM>These values should come from PSP, but there seem to be problems. XXX</EM>

</HTML>
