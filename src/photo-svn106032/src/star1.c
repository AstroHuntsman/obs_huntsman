/*
 * <AUTO>
 *
 * FILE: star1.c
 *
 * DESCRIPTION:
 * Support for the STAR1 structure 
 *
 * </AUTO>
 */
 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <alloca.h>
#include "dervish.h"
#include "phStar1.h"
#include "phFindPsf.h"
#include "phDgpsf.h"
#include "phUtils.h"
#include "phObjectCenter.h"
#include "phObjects.h"
#include "phObjc.h"
#include "phMeasureObj.h"
#include "phExtract.h"
#include "phMathUtils.h"
#include "phFocus.h"
#include "phCellFitobj.h"
#include "phCosmic.h"
#include "phRandom.h"

#define LOCAL_SKY 0			/* use a local sky? */
#define MAXRAD 100		 /* Maximum radius for radial profile */
#define CHECK_OFFSETS 0			/* true to generate diagnostics
					   about offset between astrometric
					   and photometric positions */

#define BAGEL 1            /* if true do not count first 3 annuli for QU */ 

#define USE_U_Q 0
#if USE_U_Q
   static void calcQandU(STAR1 *star, const CELL_STATS *prof);
#endif


/***************************************************************************/
/*
 *Temporarily insert focus code here:
 */
/*********************** MODULE SDSSFOC.C **************************/
/*
 * Code for the focus array, to find the optimum sigma for smoothing,
 * and to find the focus offsets.
 * 
 * jeg 960512
 *
 */

#define DXF  0.5
#define DYF  0.5
/* 
 * These are the offsets needed to go from natural floating coordinates
 * in which an object CENTERED in pixel i j has floating coordinates
 * i.0000 j.0000 to the insane ones adopted by the SDSS, in which an
 * object centered on the LL corner of a pixel (and therefor has its light
 * equally shared with pixels i-1,j i-1,j-1 and i,j-1) has zero fractional 
 * part. These routines can be used in rational systems by setting DXF and DYF
 * to zero.
 */

#define SIZFIL 50
/* max length of filter arrays */
static short int fgarray[SIZFIL];
static short int x2fgarray[SIZFIL];
/* arrays to hold generated gaussian and
 * moment filters
 */

static int sig_ncut=0;           /* the size of the last generated filter */
static double sigmagen = -1;     /* the width param of the last gen. filter */

/* 
 * The scheme used for these focus routines uses gaussian-weighted moments
 * to calculate image sizes. If a gaussian star of width parameter sigma
 * is multiplied by another gaussian of the same width parameter times
 * the polynomial C*( 2*(r/sigma)^2 - 2) and integrated, the result is 
 * zero; this function is the first in a set of circularly symmetric
 * (gaussian * polynomial) orthogonal functions. The real stars are not,
 * of course, gaussians, but we use the same scheme; findsigma() finds the
 * value of sigma for which the star*gaussian*(1-(r/sigma)^2) integrates to 
 * zero; the resultant value of sigma is an 'equivalent' sigma the gaussian of 
 * which width in some sense 'best' represents the real psf. It can be shown
 * that that gaussian is the most efficient gaussian filter for finding
 * objects, and is so close to optimum for astrometric centering that it is
 * not worth refining. In order to eliminate the dependence on the brightness
 * of the star, we use the normalized moment
 *
 *         Sum(star*gaussian*(2*(r/sigma)^2)-2)/Sum(star*gaussian)
 *
 * to measure the deviation from focus; with the correct sigma this
 * vanishes in focus, and it grows approximately quadratically with deviations
 * from the correct focus. The scheme is thus to monitor sigma in an
 * approximately in-focus image, and monitor the focus moments in 
 * pairs of symmetrically out-of-focus images; we then use 
 * a simple quadratic interpolation scheme to find out how far we are
 * from the true focus.
 */


/************************ SETFSIGMA() *********************************/
/* This routine calculates gaussian smoothing and moment arrays for a 
 * given gaussian psf width parameter sigma. The normalization is to a value
 * of about 512 in the center. This should be thought about carefully. 
 * In the production code, there should be a library of these separated by 
 * about 10% in sigma from about 0.7 to 2.0 or so, from which the one one 
 * wants is generated by linear interpolation. Especially in the case of
 * the focus servo, one is changing sigma constantly, and the interpolation
 * scheme is badly needed. The routine bombs and returns (-1) if a ridiculously
 * large sigma is asked for.
 */
static int 
setfsigma(double sigma)
{
    int ncut;
    float sig2inv;
    float edge;
    int i;
    int sum = 0;
    float isig2;
    float gau;

    shAssert(sigma == sigma && sigma > 0);
    
    if(sigma == sigmagen) return 0;	/* already done it */
    sigmagen = sigma;
    
    ncut = (int)(4*sigma + 0.5) + 1;
    if(ncut >= SIZFIL) {			/* sigma's too large */
        shErrStackPush("setfsigma: sigma=%f is too large",sigma);
        return (-1);
    }
    
    sig2inv = 0.5/(sigma*sigma);
    edge = 512.*exp(-((double)(ncut*ncut))*sig2inv);
    sig_ncut = ncut;

    for(i=0;i<ncut;i++){
        isig2 = (double)i;
        isig2 = isig2*isig2*sig2inv;
	gau = 512.*exp(-isig2) - edge + 0.5;
        fgarray[i] = gau;
        x2fgarray[i] = 2.*gau*isig2;
        sum += fgarray[i];
	
        if(i > 0 && x2fgarray[i] == 0) {
	   sig_ncut = i;		/* trim to last nonzero val */
	   break;
	}
    }
    for(i=sig_ncut;i<SIZFIL;i++) fgarray[i] = 0;  /* zero out rest of array */

    /* 
     * normalization of filter; nominally 2pi * sigma^2 * 2^18 
     */
    return 0; 
}

/********************** LGAUSMOM() ****************************************/
/*
 * This routine calculates the normalized moments of a star multiplied by
 * a gaussian of width sigmagen (last filter generated) and the polynomials
 * 2x^2 -1 and 2y^2-1. It returns their sum and, if the pointer supplied
 * is nonzero, populates the first three entries of the moment structure.
 * p is the image, xsz, ysz the x and y sizes, 
 * x and y the integer pixel locations; the moments at the
 * floating interpolated center are found later by findfocmom().
 * sky is an integer estimate of the background; this routine is designed
 * to work on bright objects (focus stars) so one does not need to be
 * too fussy about this, but the sky is nonnegligible in the focus
 * array, and it needs to be determined somehow.
 */
static double 
lgausmom(PIX **p, 
	 int x,
	 int y,
	 int sky,
	 struct gausmom_P *ps)
{
    int i;
    float sum,xsum,ysum;
    float lsum,lxsum;
    register int n;
    register PIX *lptrpp,*lptrpm,*lptrmp,*lptrmm;
    register int psum;
    const int ncut = sig_ncut;
    float x2mom,y2mom,fsum;
    int sky2 = 2*sky;
    int sky4 = 4*sky;
    
    shAssert(sigmagen > 0.0);

    sum = 0;
    xsum = 0;
    ysum = 0;
    for(i=0; i< ncut; i++){
        lptrpm = lptrpp = p[y + i] + x;
        lptrmm = lptrmp = p[y - i] + x;
        lxsum = 0;
        n = ncut-1;

        if(i==0){     /* do not double-count central line */
            lsum = ((*lptrpm) - sky)*fgarray[0];        
            while(n){
                lsum += (psum = ((*(++lptrpp) + *(--lptrpm)) - sky2))
                            *fgarray[ncut-n];
                lxsum += psum * x2fgarray[ncut-n];
                n--;
            }
        }else{       
            lsum = ((*lptrpm) + (*lptrmm) - sky2)*fgarray[0];
            while(n){
                psum = ((*(++lptrpp) + *(--lptrpm) + *(++lptrmp) + *(--lptrmm))
                         - sky4);
                lsum += psum * fgarray[ncut-n];

                lxsum += psum * x2fgarray[ncut-n];                       
                n--;
            }
        }

	sum += lsum*fgarray[i];
	ysum += lsum*x2fgarray[i];
	xsum += lxsum*fgarray[i];
    }

    if(sum == 0) {
       fsum = x2mom = y2mom = 0;
    } else {
       fsum = sum;
       x2mom = (double)(2*xsum - sum)/fsum;
       y2mom = (double)(2*ysum - sum)/fsum;
    }

    if(ps != NULL) {
        ps->g_xmom = x2mom;
        ps->g_ymom = y2mom;
        ps->g_filval = fsum;
    }

    return x2mom + y2mom;
}


/********************* FINDFOCMOM() ***************************************/
/* 
 * This routine finds the position of a focus image (to second order only)
 * and populates the proferred moment structure quadratically interpolated to 
 * the float position of the object. p is the image, xsz, ysz the x and y
 * sizes. x and y are guesses for the closest pixel to the maximum 
 * in the gaussian-smoothed image (the routine iterates if this
 * guess is not correct); ps is a pointer to a gausmom_P structure in
 * which the moments and position are returned, and sky is the value of the 
 * background. The routine returns the number of tries it has to make in order
 * to find the maximum pixel, but bombs and returns -1 if the number of tries
 * is larger than the threshold FINDERR or if the star is too close to the
 * edge of the frame. If the image is at all normal and of reasonably high 
 * signal-to-noise it will never require more than one iteration if the 
 * initial try is the maximum pixel in the unsmoothed image.
 */

#define FINDERR 5
        /* allowed number of tries to find max in smoothed image */
static int
findfocmom(PIX **p, 
           int xsz, 
           int ysz, 
           int x,
           int y,
           int sky, 
           struct gausmom_P *ps
           )
{
    int i,j;
    struct gausmom_P sq[9];
    struct gausmom_P *val[3];  
    float v,vc;
    float xvc,yvc;
    int xp,yp;     
    float dx,dy; 
    float d2x, d2y;
    float sx, sy;
    float v0;    /* value at maximum */    
    float xd2x, xd2y; 
    float xsx, xsy;
    float yd2x, yd2y;
    float ysx, ysy;
    const int ncut = sig_ncut;
    int ret = 0;

    /* We will bomb if the star is too close to an edge; one could do fancier
     * things, but one would regret it.
     */
    if( x < ncut+FINDERR || y < ncut+FINDERR || 
        x > xsz - ncut -1 -FINDERR || y > ysz - ncut -1 -FINDERR){
       shErrStackPush("FINDFOCMOM: Star too close to edge (%d %d), ncut=%d, FINDERR=%d",
                    x,y,ncut,FINDERR);
        return -1;
    }
        
    /* set up pointers */
    for(i=0;i<3;i++)  val[i] =  sq + 3*i;
    
start:
    if(ret > FINDERR) return (-1);
    (void)lgausmom(p,x,y,sky,&val[1][1]); 
                /* get central value first; then rest.*/
    vc = (val[1][1]).g_filval;
    for(i=0;i<3;i++){
        yp = y + i -1;
        for(j=0;j<3;j++){
            xp = x + j -1;
            if(!(i==1 && j==1)){
                (void)lgausmom(p,xp,yp,sky,&val[i][j]);
                v= (val[i][j]).g_filval;
                if(v > vc){      /* 
                                  * missed the maximum--ie the max in the smth
                                  * image is not at the same place as that 
                                  * in the raw image.
                                  */
                    ret++;
                    x += j-1;
                    y += i-1;
                    goto start;  /* we could call ourselves recursively,
                                  * but this allows us to set a semi-error
                                  * flag. We could also save some time
                                  * by saving and moving the values we have 
                                  * already computed, but the bookkeeping is
                                  * messy.
                                  */
                }
            }
        }
    }

    
    d2x = 2.*vc - val[1][2].g_filval - val[1][0].g_filval;
    sx  = 0.5*(val[1][2].g_filval - val[1][0].g_filval);
    if(d2x == 0) {
       return(-1);
    }
    dx  = sx/d2x;
    
    d2y = 2.*vc - val[2][1].g_filval - val[0][1].g_filval;
    sy  = 0.5*(val[2][1].g_filval - val[0][1].g_filval);
    if(d2y == 0) {
       return(-1);
    }
    dy  = sy/d2y;
    
    ps->g_xf = x + dx + DXF;
    ps->g_yf = y + dy + DYF;

    /* these are just the parabolic values for the central crossstripe */

    v0 = vc + 0.5*(((sx*sx)/d2x + (sy*sy)/d2y));
    ps->g_filval = v0;
    /* 
     * Estimate for real peak value above sky.
     */

    /* now interpolate the moments */
    xvc = val[1][1].g_xmom; 
    yvc = val[1][1].g_ymom; /* central pixel moment values */

    xd2x = 2.*xvc - val[1][2].g_xmom - val[1][0].g_xmom;
    xd2y = 2.*xvc - val[2][1].g_xmom - val[0][1].g_xmom;
    xsx  = 0.5*(val[1][2].g_xmom - val[1][0].g_xmom);
    xsy  = 0.5*(val[2][1].g_xmom - val[0][1].g_xmom);
    
    yd2x = 2.*yvc - val[1][2].g_ymom - val[1][0].g_ymom;   
    yd2y = 2.*yvc - val[2][1].g_ymom - val[0][1].g_ymom;    
    ysx  = 0.5*(val[1][2].g_ymom - val[1][0].g_ymom);
    ysy  = 0.5*(val[2][1].g_ymom - val[0][1].g_ymom);
    
    ps->g_xmom = xvc + xsx*dx + xsy*dy - 0.5*(dx*dx*xd2x + dy*dy*xd2y);
    ps->g_ymom = yvc + ysx*dx + ysy*dy - 0.5*(dx*dx*yd2x + dy*dy*yd2y);
    
    return ret; 
}    

/******************** FINDSIGMA() ***************************************/

#define SALPHA 0.5  
/* acceleration parameter; this is near the optimum choice */
#define SIGGUESS 1.2
/* initial guess for width parameter; this is near the nominal value,
 * which is about 1.2 times the width parameter for the little gaussian,
 * which is near 1.0 for the nominal imaging conditions.
 */
 
#define SIGITERAT 10
/* iteration limit */
#define SIGERR 1.e-3
/* tolerance */

/* 
 * this routine iterates to find the optimum sigma for smoothing for object
 * finding (and, though not QUITE optimum for astrometry, is trivially
 * different from the correct value and I suggest we use it) by finding the 
 * sigma value for which the focus moment 2*r^2 - 2 weighted by that gaussian 
 * vanishes. It returns the found value or -1.0 if any invocation of 
 * findfocmom fails. It will populate a struct gausmom_P if one is offered, 
 * or will use an internal one for its calculations if one is not 
 * (the argument is NULL).
 */ 

static double
findsigma(PIX **p, 
	  int xsz, 
	  int ysz, 
	  int x,
	  int y,
	  int sky, 
	  struct gausmom_P *ps)
{
    float sig = SIGGUESS;    
    float mom;
    int i;
    struct gausmom_P gmom;
    
    if(ps == NULL) ps = &gmom;
   
    for(i=0;i<SIGITERAT;i++) {
        if(sig != sig || sig <= 2e-10 || setfsigma(sig) < 0 || sig > 12.) {
	   return(-1);
	}

        if(findfocmom(p,xsz,ysz,x,y,sky,ps) < 0) {
	   return(-1);
	}
        mom = ps->g_xmom + ps->g_ymom;
        if(fabs(mom) < SIGERR) break;
        sig *= (1. + SALPHA*(mom));

/*
 * JEG's code doesn't converge for too-good images.
 */
	if(sig < 0.5) {			/* ~ 0.5" seeing */
	   break;
	}
    }
    return sig;
}

double
phGaussianWidthEstimate(const REGION *reg,
			int rowc,	/* row centre */
			int colc,	/* column centre */
			int bkgd,	/* background value */
			struct gausmom_P *ps) /* return information; or NULL */
{
   float width;
   
   shAssert(reg != NULL && reg->type == TYPE_PIX);

   width = findsigma(reg->ROWS, reg->ncol, reg->nrow, colc, rowc, bkgd, ps);

   if(width >= 0) {
      width /= sqrt(2.0);
   }

   return(width);
}

/***************** FINDFOCOFFSET() *************************************/
/* 
 * The field of the two focus chips is divided horizontally into three
 * focus zones of nominally equal widths (about 683 pixels), with two bad 
 * zones about 50-60 pixels wide at the intersections of the focus zones.
 * In the first (say leftmost, though which is which is yet to be determined)
 * the focus is about 300 microns outside of nominal (closer to the corrector;
 * this zone has a filter which is too THIN). The x values for this zone
 * are, say, 0-650.  The center zone (x=720-1330) has the nominal focus
 * and can be used to determine the seeing and sigma for the star images.
 * The right zone (1400-2048) is used for immediate loading and unloading
 * of passengers only. NO PARKING. nonono--is 300 microns inside of nominal
 * focus (it has a filter which is too THICK.) It can be shown that this
 * focus offset (which is the nominal 60 micron FWHM image size times the
 * f-ratio) results in the highest signal-to-noise ratio in the determination
 * of the focus. The idea, then, is to determine the image parameters 
 * using the central zone, and then, using the focus moments generated
 * from images in the outer zones, to determine the focus offsets. When the
 * system is IN focus, the degradation in the two outer images will be 
 * equal. I decided NOT to use the astigmatic deformation in the outer
 * zones, which would appear to be useful in focus determination, because
 * it is degenerate with tracking errors, which also can elongate the images
 * and must not be interpreted as focus errors.
 *
 * The focus errors from aberrations and photon statistics (the actual 
 * errors will almost certainly be dominated by SEEING) are about 3 microns 
 * for any star brighter than about r'=15.5, the limit set by psf variations
 * across the focus chip. For fainter objects, photon noise becomes important
 * and the errors are about 6 microns at 17.0, 9 at 18.0, and 20 at 19.0. 
 * At the galactic pole, the star counts are about 250, 500, 820, and 
 * 1300 per square degree brighter than 15.5, 17, 18, and 19, respectively, 
 * and fainter than the saturation limit at r'=11.5. The three focus zones 
 * are each about 4 arcminutes wide, so the camera will see about 0.0167 
 * square degrees per minute of time in each of the zones. Thus it will see 
 * 4 stars brighter than 15.5, 8 brighter than 17, 13 brighter than 18, and
 * 21 brighter than 19 per minute. We wish to control the focus to about
 * 25 microns, and the errors grow very rapidly fainter than 19th, so this is
 * practical limit. The servo bandwidth should be about 0.2/minute or perhaps 
 * slower, but should be faster at the beginning to GET INTO focus initially.
 * There are lots and lots of stars.
 * 
 * The prescription for the focus servo is thus the following: For the central
 * (nominal focus) stripe, run findsigma 'often enough' on stars of
 * high signal-to-noise. Do statistics on sigma and reject outliers. 
 * Meanwhile, with the current 'good' sigma (run setfsigma(), or, preferably,
 * interpolate into a set of arrays generated once and for all), do 
 * findfocmom() on stars in the two outside stripes, one 300 microns 
 * inside focus and the other 300 microns outside. We can assume that 
 * the central moment is zero, since findsigma makes it so. 
 * Let m300out be the moment returned by findfocmom() (the sum of 
 * g_xmom and g_ymom in the argument structure) on stars in the stripe 300 mu 
 * out and m300in that in the stripe 300 mu in. The focus offset is then 
 * calculated by simple parabolic interpolation (which the simulations show 
 * is good to about 10 microns over the range +/-300 microns) by this simple 
 * routine. The units of the return value are the same as the units of 
 * DELFOC and FOFFSET, here taken to be microns; These need to be converted 
 * eventually into secondary motor step units, but for diagnostics and the 
 * log I think microns are the appropriate units.
 */

#define DELFOC 300.   
/* focus increment between the 'in focus' images and the two out of focus 
 * ones, which here are assumed to be symmetrically placed on either side
 * of the correct focus. This value is pretty close, but its exact value 
 * will depend on the final manufactured filter thicknesses. 
 * Its value does not affect the goodness of the focus (so long as the
 * two out-of-focus images are in fact symmetrically placed) only the 
 * 'gain' of the focus servo, and hence is not at all critical as 
 * long as it is in the ballpark. Since the behavior of the moments as
 * a function of focus is not EXACTLY quadratic, its effective value
 * near focus is not quite the real offset but is somewhat greater; a value
 * closer to 330 works best for offsets less than 100 microns, and we may
 * well want to use such a value, but I cannot imagine that it will make
 * much difference.
 */
 
#define FOFFSET 0.
/* It may turn out that the 'in focus' images differ slightly in focus
 * from the mean of the rest of the array, in which case one needs to have
 * a nonzero value for this parameter. In the production code, both of these
 * parameters need to be kept in some initialization file rather than being
 * compiled in. 
 */
 
/*
 * The offset is taken to be positive if the focus needs to
 * be MOVED OUT (ie, the secondary needs to be moved DOWN). In this case the
 * in image is better (smaller moment) than the out image. The case of
 * the focus being so bad that the real focus is not between the two
 * reference images is not done well here, and the servo will take a long
 * time to reach the focus if the focus is way off. This case, which is
 * likely to obtain when the session begins and the telescope is not
 * in focus yet, is handled by bigfocoffset() below. If somethin untoward
 * happens to the focus within a run, however, the servo WILL continue to
 * work using only findfocoffset().
 */

double
findfocoffset(double m300out, double m300in)
{
    float s,d2;
    float focoff;
    float sense = m300out*m300in;
    
    if (sense < 0.){  /* focus is NOT between out-of-focus images */
        return m300out > 0. ? DELFOC : -DELFOC ; 
        /* 
         * move in steps of DELFOC until the focus is between the +/-300u
         * points
         */
    }else{     /* OK; quadratic interpolate */
        s = 0.5*(m300out - m300in);     /* positive means move focus out */
        d2 = m300out + m300in;
        focoff = (DELFOC*s)/d2 + FOFFSET;
        return focoff;
    }
}

/* When the observing session is beginning, and especially at the beginning
 * of the survey, when the behavior of focus with temperature and zenith
 * angle may not be very well understood, it will often be the case that the
 * focus will not lie within 300 microns of its correct value. In that case,
 * a rather coarser but more robust algorithm is needed to get into focus
 * quickly. There are several caveats about automating such a scheme, perhaps
 * sillily but the most serious being that terribly out-of-focus images have
 * holes in the middles, and finding their centers is not trivial. It turns
 * out, however, that findsigma() works pretty well on such images, though
 * not very efficiently--that should not matter, however, since until the
 * telescope is in focus, the astrometric DA has nothing else to do. 
 * The scheme for using findsigma() is the following: For very out-of focus
 * images, which are essentially uniform annuli with a ratio of inner to outer
 * radius of almost exactly two (just the ratio of primary mirror diameter to 
 * that of secondary-with-baffle), findsigma() returns a value which is about
 * 0.75 of the outer radius of the image. Thus sigma grows with focus offset
 * like dsigma = 0.75*dfoc/(2*fratio*pixsize) = 3.1e-3*dfoc, with dfoc in
 * microns. Since at any focus, some rms measure of the image diameter, which
 * in a strongly cut-off sense sigma is, is just the rss of the in-focus
 * image diameter with the out-of-focus annulus, it follows that to some
 * fair approximation
 *
 *          sigma = sqrt(sigma0^2 + (3.1e-3*dfoc)^2)
 * 
 * where sigma0 is the in-focus value. Now if we have the values of sigma
 * returned by findsigma() for the two outer zones, which differ in focus
 * by 2*DELFOC, one can subtract the two values of sigma^2; in the result
 * sigma0 and the square of dfoc fall out, and one obtains
 * 
 *          dfoc = (sigout^2 - sigin^2)/(4*DELFOC*DSIGDFOC^2),
 *
 * where sigout is the sigma in the 300 micron out zone and sigin the sigma
 * in the 300 micron in zone; DSIGDFOC is the coeffiecient 3.1e-3 found 
 * above. The constant 1/(4*DELFOC*DSIGDFOC^2) is 86.7.
 *
 * Thus when one is beginning, all one need do is determine sigma for a
 * star in the out zone and one in the in zone and invoke bigfocoffset().
 * It would probably be best if there were a tool in IOP to allow picking
 * such objects with the mouse in order to avoid writing special code to find
 * terribly out-of-focus images. For example, one could just have the output
 * of the two focus sensors scrolling by on the upper and lower parts of
 * a screen; clicking on a star would stop that display scrolling (?) and
 * evaluate sigma; the routine would know which zone the star was in, clearly.
 * when one star had been found in each of the outer zones for each focus
 * sensor, bigfocoffset() would be called with the relevant sigmas, once for
 * each sensor, and the telescope focus would be updated; in theory, the focus
 * servo could then be turned on.
 */

#define DSIGDFOC 3.1e-3
/* derivative of sigma with focus for large focus errors */

#define DFOCDSIG2 86.7
/* coef of focus offset with delta sigma^2 */

double 
bigfocoffset(double sigout, double sigin)
{
    return 0.25*(sigout*sigout - sigin*sigin)*DFOCDSIG2;
}    
    
/********************* END MODULE SDSSFOC.C *********************************/





/***************************************************************************
 * <AUTO EXTRACT>
 *
 * create a new STAR1 structure, setting fields to NULL or (mostly)
 * impossible values.  
 *
 * return: STAR1 * to new structure
 */

STAR1 * 
phStar1New(void)
{
  static int id;
  STAR1 *star1 = shMalloc(sizeof(STAR1));

  *(int *)&star1->id = id++;
  star1->starid = -1;
  star1->frame=-1;
  star1->ra = star1->dec = -1000;
  star1->raErr = star1->decErr = 0;
  star1->aperture = -1;
  star1->apCounts = star1->apCountsErr = -1000;
  star1->apCounts1 = star1->apCounts2 = -1000;
  star1->wingcorr = -1;
  star1->psfCounts = star1->psfCounts_PSF = -1000;
  star1->psfCountsErr = -1000;
  star1->apCorr_PSF = -1.0;
  star1->count_rat    = 0;
  star1->count_ratErr = 0;
  star1->Eff_width = -1.0;
  star1->PSFflag = 0;
  star1->badstar = 0;
  star1->Q = star1->U = -1000.0;
  star1->M_rms = -1;
  star1->dgpsf = NULL;
  star1->object = phObject1New();
  star1->cprof = NULL;
  star1->sym = NULL;
  star1->syncreg = NULL;
  star1->flags = STAR1_NOFLAGS;
  star1->PSFwidth = -100;
  star1->used4coeffs = -1;

  return(star1);
}

/***************************************************************************
 * <AUTO EXTRACT>
 *
 * Delete the given structure, including all its sub-structures:
 * dgpsf, psfCounts, apCounts, region, and mask.
 *
 * return: void
 */

void
phStar1Del(
   STAR1 *star             /* I: structure to delete */
   ) 
{
  if (star->dgpsf != NULL) {
    phDgpsfDel(star->dgpsf);
  }
  if (star->object != NULL) {
    phObject1Del(star->object);
  }
  if(star->cprof != NULL) {
     phCellProfDel(star->cprof);
  }
  if(star->sym != NULL) {
     phSymdiagDel(star->sym);
  }
  if(star->syncreg != NULL) {
     shRegDel(star->syncreg);
     star->syncreg = NULL;
  }

  shFree(star);
}

/***************************************************************************
 * <AUTO EXTRACT>
 *
 * Delete sub-structures which are not needed for photometric calibration
 * from STAR1:
 * return: void
 */

void
phStar1Relax(
   STAR1 *star             /* I: structure to delete */
   ) 
{
  if (star->dgpsf != NULL) {
    phDgpsfDel(star->dgpsf);
    star->dgpsf = NULL;
  }
  if (star->object != NULL) {
    phObject1Del(star->object);
    star->object = NULL;
  }
  if(star->cprof != NULL) {
     phCellProfDel(star->cprof);
     star->cprof = NULL;
  }
  if(star->sym != NULL) {
     phSymdiagDel(star->sym);
     star->sym = NULL;
  }
  if(star->syncreg != NULL) {
     shRegDel(star->syncreg);
     star->syncreg = NULL;
  }
}

/***************************************************************************
 * <AUTO EXTRACT>
 *
 * create a new STAR1PC structure, setting fields to NULL or (mostly)
 * impossible values.  
 *
 * return: STAR1PC * to new structure
 */

STAR1PC * 
phStar1pcNew(void)
{
  static int idpc;
  STAR1PC *star1 = shMalloc(sizeof(STAR1PC));

  *(int *)&star1->id = idpc++;
  star1->starid = -1;
  star1->frame=-1;
  star1->ra = star1->dec = -1000;
  star1->aperture = -1;
  star1->apCounts = star1->apCountsErr = -1000;
  star1->flags = STAR1_NOFLAGS;

  return(star1);
}

/***************************************************************************
 * <AUTO EXTRACT>
 *
 * Delete STAR1PC.
 *
 * return: void
 */

void
phStar1pcDel(
   STAR1PC *star           /* I: structure to delete */
   ) 
{
  shFree(star);
}



/***************************************************************************
 * <AUTO EXTRACT>
 *
 * create a new FRAME_INFORMATION structure, setting fields to NULL or (mostly)
 * impossible values.  
 *
 * return: FRAME_INFORMATION * to new structure
 */

FRAME_INFORMATION *
phFrameInformationNew(int size)
{
  FRAME_INFORMATION *frame_info = shMalloc(sizeof(FRAME_INFORMATION));
  int l;

  frame_info->size = size;
  frame_info->starflags = (size <= 0) ? NULL : shMalloc(size*sizeof(int));
  frame_info->filter[0] = '\0';
  frame_info->frame = -1;
  frame_info->Nframestars = -1;
  frame_info->Nallstars = -1;
  frame_info->NgoodBasis = -1;
  frame_info->NgoodCoeffs = -1;
  frame_info->NgoodKLbasis = -1;
  frame_info->NgoodKLcoeffs = -1;
  frame_info->NbadSSb = 0;
  frame_info->NbadCell = 0;
  frame_info->NbadQU = 0;
  frame_info->Nphoto = -1;
  frame_info->firststar = -1;
  frame_info->ap_corr = -1;  
  frame_info->apCorr_max = -1;  
  frame_info->apCorr_min = -1; 
  frame_info->apCrat_med = -1; 
  frame_info->apCrat_q25 = -1; 
  frame_info->apCrat_q75 = -1; 
  frame_info->width_med = -1;
  frame_info->width_q25 = -1;
  frame_info->width_q75 = -1;
  frame_info->patch_flux20 = -1;  
  frame_info->Nprof = -1;
  for(l = 0; l < NANN; l++) {
     frame_info->ptarr[l] = 0.0; 
  }

  return(frame_info);
}

/***************************************************************************
 * <AUTO EXTRACT>
 *
 * Delete FRAME_INFORMATION structure.
 * return: void
 */
void
 phFrameInformationDel(
   FRAME_INFORMATION *frame_info  
   ) 
{
   if(frame_info != NULL) {
     shFree(frame_info->starflags);
   }
   shFree(frame_info);
}
 
/*****************************************************************************/
/*
 * Estimate the sky level all pixels more than radius from centre.
 *
 * We estimate the sky from the median, but correct to the mean
 * assuming Poisson statistics
 */
static float
estimate_sky_from_corners(const REGION *reg, /* region with sky */
			  int radius, /* exclude disk of this radius */
			  float gain)	/* gain of CCD */
{
  float *arr;			/* pixel values in the sky area */
  int i, j, k;
  const int nrow = reg->nrow, ncol = reg->ncol;
  int nel;			/* estimate of number of sky points */
  int rad2 = radius*radius;
  PIX **rows = reg->ROWS;	/* == reg->ROWS */
  PIX *row;			/* == rows[] */
  float sky = 0;		/* desired estimate */

  shAssert(reg->type == TYPE_PIX);
  shAssert(radius > 0);

  nel = nrow*ncol - 2.5*rad2;	/* ~ number of sky points; 2.5 <~ M_PI */
  shAssert(nel > 0);

  arr = alloca(nel*sizeof(float));
  
  for(i = k = 0; i < nrow; i++) {
    int y2 = (i - nrow/2)*(i - nrow/2);
    row = rows[i];
    for(j = 0; j <= ncol/2; j++) {
      int x2 = (j - ncol/2)*(j - ncol/2);
      if(x2 + y2 < rad2) {
	break;
      }

      arr[k++] = row[j];
      if(i != ncol/2) {
	arr[k++] = row[ncol - j - 1];
      }
    }
  }
  shAssert(k <= nel);

  phFloatArrayStats(arr, k, 0, &sky, NULL, NULL, NULL);
  sky += 0.16666/gain;			/* correct median to mean */

  return(sky);
}

#define DEBUG
#undef DEBUG2
/***************************************************************************
 * <AUTO EXTRACT>
 *
 * given a U16 region, sky value, sky sigma, background
 * variance, gain, and aperture index, create a new STAR1 structure.
 * The star is identified by the peak pixel in the region.  
 *
 * First sky subtract the region, estimating the value from pixels outside
 * the central sky_annulus_r pixels
 *
 * If the specified radius is 0 use default; Skip this step if it's -ve 
 *
 * Find the star's center, extract a radial profile and measure an aperture
 * magnitude. Find the best fitting dgpsf. If a reasonable psf fit
 * cannot be found, set the dgpsf field to NULL and set the
 * appropriate flag.
 *
 * return: pointer to new STAR1 
 */
STAR1 *
phStar1MakeFromReg(REGION *reg,		/* use data from this REGION */
		   int sky_annulus_r,	/* estimate sky from pixels outside
					   this radius. If 0 use default size; 
					   if -1 skip estimation */
		   float sky,		/* sky value in new STAR1 */
		   float skyerr,        /* uncertainty of sky level */
		   float skysig,        /* sigma of sky level */
		   const FRAMEPARAMS *fparams, /* describe frame */
		   REGION *scr1,	/* scratch regions, same size as reg */
		   REGION *scr2,	/*         both may be NULL */
		   int aperture,        /* index of outer aperture for mag */
		   int psf_def_rad,     /* search radius for star peak */
                   float cr_min_s,      /* CRs must be > this many sky-sig above sky */
                   int cr_min_e,        /* CRs must have > this many electrons in peak pixel */
                   float cr_cond3,      /* used in condition 3 for CR; see CR.c code */
                   float cr_cond32,     /* used in condition 3 for CR; see CR.c code */
		   int threshold,	/* threshold for object finder */
                   float sigma_multi,   /* number of sky sigma for multiple */
                   float sigma_badsky,  /* number of sigma for bad sky */
                   float second_peak)   /* max. allowed strength for 2nd peak */
{
   REGION *big = NULL;			/* a large region to embed reg in */
   float bkgd;				/* level of background to subtract */
   float dark_variance;			/* variance of the background */
   float gain;				/* gain of amplifiers */
   STAR1 *star;
   float posErr;			/* rms positional error for star */
   int i, rpeak, cpeak, nprof;
   PEAKS *peaks;
   PEAK *peak0, *peak1;			/* brightest and 2nd brightest peaks */
   float xc=0, yc=0, dxc=0, dyc=0, smooth=1.0;
   float annulus_sig;
   float corr5, corr7, oldsky;
   float *profile, *profErr;		/* unpacked from STAR1->object */
   float *profileMedian;                /* the above two are mean profiles */
   CELL_STATS *cellstats;
   CELL_STATS *cstats_loc = NULL;      

   shAssert(reg != NULL && reg->type == TYPE_PIX);
   if(scr1 != NULL) {
      shAssert(scr1->nrow == reg->nrow && scr1->ncol == reg->ncol && \
	       scr1->type == reg->type);
   }
   if(scr2 != NULL) {
      shAssert(scr2->nrow == reg->nrow && scr2->ncol == reg->ncol && \
	       scr2->type == reg->type);
   }
   shAssert(fparams != NULL);

   bkgd = SOFT_BIAS + sky;
   dark_variance = phDarkVariance(fparams, reg->row0 + 0.5*reg->nrow, reg->col0 + 0.5*reg->ncol);
   gain = phGain(fparams, reg->row0 + 0.5*reg->nrow, reg->col0 + 0.5*reg->ncol);

   star = phStar1New();
   star->dgpsf = phDgpsfNew();
   star->object->region = (REGION *)reg;
   star->object->mask = phObjmaskFromRect(reg->col0, reg->row0,
					  reg->col0 + reg->ncol - 1,
					  reg->row0 + reg->nrow - 1);
   star->object->sky = sky;
   star->object->skyErr = skyerr;

/* check for cosmic rays */
   /* first guess approximate PSF */
   star->dgpsf->sigma1_2G = star->dgpsf->sigmax1 = star->dgpsf->sigmay1 = 1.0;
   star->dgpsf->sigma2_2G = star->dgpsf->sigmax2 = star->dgpsf->sigmay2 = 2.5;
   star->dgpsf->b_2G = star->dgpsf->b = 0.1; 
   if(skysig > 0.0) {			/* needed to find CRs */
      if( (i = phFindCR((REGION *)reg,sky,sky,skysig,star->dgpsf,gain,cr_min_s,
			cr_min_e,cr_cond3,cr_cond32,1,NULL,NULL)) > 0 ) {
	 star->flags |= STAR1_CR; 
	 if (i > 50) {
	    shError("phStar1MakeFromReg: Found VERY many CRs (%d).",i);
	 }
      }
   }

#if 0					/* replace PSF star by DGPSF;
					   used for debugging centering code */
   {
      RANDOM *rand = phRandomNew("10000:2", time(NULL));
      shRegIntSetVal(reg, bkgd);
      phDgpsfAdd(reg, star->dgpsf, -1,
		 reg->nrow/2.0 + phRandom_u16()/32767.0 - 0.5,
		 reg->ncol/2.0 + phRandom_u16()/32767.0 - 0.5, 10000);
      phRegIntNoiseAdd(reg, rand, SOFT_BIAS, 2, 0);
      phRandomDel(rand);
   }
#endif

/*
 * Update our estimate of the local sky
 */
   if(sky_annulus_r == 0) {		/* Use default size */
     sky_annulus_r = (reg->nrow/2) - 1;
   }
   oldsky = sky;
   if(sky_annulus_r > 0) {
     const float lsky =
       estimate_sky_from_corners(reg, sky_annulus_r, gain) - SOFT_BIAS;
     /* adjust the sky value, but don't change the region */
     bkgd = bkgd - sky + lsky;
     sky = star->object->sky = lsky;
   }

/*
 * Find all peaks in the postage stamp; we could run the object finder,
 * but let's be lazy
 *
 * We cannot be so lazy as to not smooth the region
 */
   {
      REGION *sreg = (scr1 != NULL) ? scr1 :
				 shRegNew("", reg->nrow, reg->ncol, reg->type);
      REGION *scr = (scr2 != NULL) ? scr2 :
				 shRegNew("", reg->nrow, reg->ncol, reg->type);
      sreg->row0 = reg->row0; sreg->col0 = reg->col0;
      phConvolveWithGaussian(sreg, reg, scr, 5, 1, 0, CONVOLVE_ANY); 
      /* peak positions are relative to row0, col0 */
      peaks = phPeaksNew(0);
      phObjectPeaksFind(sreg, star->object->mask, 1, peaks, -1);
      if(sreg != scr1) shRegDel(sreg);
      if(scr != scr2) shRegDel(scr);  
   }
/*
 * now look at the peaks critically. Specifically, ensure that the highest
 * peak is near the centre of the frame, and that the two brightest
 * acceptable peaks are not too close to having equal peak values
 */
   if(peaks->npeak == 0) {
      star->flags |= STAR1_BADCENTER;	/* no peaks */
      rpeak = cpeak = -1;		/* make compiler happy */
   } else {				/* is brightest peak too eccentric? */
      rpeak = peaks->peaks[0]->rpeak;
      cpeak = peaks->peaks[0]->cpeak;

      /* make sure that star is further than psf_def_rad from any edge */
      if((reg->ncol - cpeak < psf_def_rad) ||
         (reg->nrow - rpeak < psf_def_rad) ||
         (cpeak < psf_def_rad) || (rpeak < psf_def_rad)) {  
	        star->flags |= STAR1_BADCENTER;
      }

      peak0 = peak1 = NULL;		/* look for two brightest peaks
					   near centre of frame */
      for(i = 0;i < peaks->npeak;i++) {
	 peaks->peaks[i]->peak -= bkgd;
	 
/*
 * we don't want a second star anywhere in the stamp (PR 2464) so don't pass
 * on those outside psf_def_rad.  On the other hand, the stamp size if fixed
 * by a #define (PSIZE) in the ssc, and if we're running binned we really
 * _do_ want to exclude part of the chip.
 */
#if 0
	 if(pow(peaks->peaks[i]->cpeak - cpeak, 2) +
	    pow(peaks->peaks[i]->rpeak - rpeak, 2) > pow(psf_def_rad,2)) {
	    continue;
	 }
#endif
	 
	 if(peak0 == NULL) {
	    peak0 = peaks->peaks[i];
	 } else if(peak1 == NULL) {
	    peak1 = peaks->peaks[i];
	 } else {
	    break;
	 }
      }

      if(peak1 != NULL) {		/* found a second peak */
	 if (peak1->peak > sigma_multi*skysig) {
	    float bad_peak_ratio = 0.05; /* XXX */
	    float bad_radmin = 10;	/* XXX */
	    if(peak1->peak/peak0->peak > second_peak) {
	       star->flags |= STAR1_MULTIPLE;
	       if (peak1->peak/peak0->peak > bad_peak_ratio &&
		   pow(peak1->rpeak - rpeak, 2) + pow(peak1->cpeak - cpeak,2) <
							  pow(bad_radmin, 2)) {
		  star->flags |= STAR1_BADMULTIPLE;
	       }
	    }
	 }
      } 
   }
/*
 * free the PEAKS
 */
   phPeaksDel(peaks);
      
   if(star->flags & STAR1_BADCENTER) {
      return(star);
   }
/*
 * refine centre
 */
   /* peak positions are in abs. coord. (row0 and col0 included) */
   if (phObjectCenterFind(reg, cpeak + reg->col0, rpeak + reg->row0,
			  sky, smooth, bkgd, dark_variance, gain, &xc, &yc,
			  &dxc, &dyc, NULL, NULL, NULL) < 0) {
       star->flags |= STAR1_BADCENTER;
       return(star);
   }       

   if (xc < 0.0 || yc < 0.0) {
       star->flags |= STAR1_BADCENTER;
       return(star);
   }   

#define RECENTROID 1			/* recentroid once we know the
					   PSF width */
#if !RECENTROID
   star->object->rowc = yc;
   star->object->rowcErr = dyc;
   star->object->colc = xc;
   star->object->colcErr = dxc;
   
#if CHECK_OFFSETS 
/* added to investigate differences in astrometric and PS positions  */
   star->col_off = xc - reg->col0 - 0.5*reg->nrow;
   star->row_off = yc - reg->row0 - 0.5*reg->ncol;
#endif

#endif
   yc -= reg->row0; xc -= reg->col0;
/*
 * region may be too small to extract a radial profile, or the centre of
 * object may be too close to edge; if so, embed it in a larger region
 *
 * This should be unnecessary with the 65x65 stamps, but it isn't.
 */
   if(yc < SYNC_REG_SIZEI/2 + 2 || yc + SYNC_REG_SIZEI/2 >= reg->nrow - 2 ||
      xc < SYNC_REG_SIZEI/2 + 2 || xc + SYNC_REG_SIZEI/2 >= reg->ncol - 2) {
      REGION *sbig;

#if 0
      /* this is a benign problem with an awfully annoying message */
      shError("phStar1MakeFromReg: "
	      "enlarging postage stamp %d, (r,c) = (%.3f,%.3f)",
	      star->id, yc, xc);
#endif
      big = shRegNew("enlarged",
		     reg->nrow + SYNC_REG_SIZEI, reg->ncol + SYNC_REG_SIZEI,
		     reg->type);
      sbig = shSubRegNew("", big, reg->nrow, reg->ncol,
			 SYNC_REG_SIZEI/2, SYNC_REG_SIZEI/2, NO_FLAGS);
      shAssert(sbig != NULL);

      yc += sbig->row0; rpeak += sbig->row0;
      xc += sbig->col0; cpeak += sbig->col0;

      shRegIntSetVal(big,bkgd);
      shRegIntCopy(sbig,reg);

      big->row0 = reg->row0 - sbig->row0;
      big->col0 = reg->col0 - sbig->col0;
      reg = big;

      shRegDel(sbig);
   }
/*
 * estimate the width
 */
   star->dgpsf->width = phGaussianWidthEstimate(reg, yc, xc, bkgd, NULL);
   if (star->dgpsf->width <= 0) {
      star->flags |= STAR1_BADPSF;
   }

   /*** don't upset phObjectCenterFind by overly small sigma ***/
   if (star->dgpsf->width <= 0.1) {
       /* Can't use this star without its syncreg */
       shDebug(STAR1_ERRLEVEL,
	       "phStar1MakeFromReg: phGaussianWidthEstimate returns width < 0.1 pix");
       star->flags |= (STAR1_NOPROFILE | STAR1_NOAPMAG | STAR1_BADSKY);
       if(big != NULL) shRegDel(big);
       return(star);
   }

#if RECENTROID
/*
 * Recentroid now that we have an estimate of the width
 */
   if (phObjectCenterFind(reg, cpeak + reg->col0, rpeak + reg->row0,
			  sky, star->dgpsf->width, bkgd, dark_variance, gain,
			  &xc, &yc, &dxc, &dyc, NULL, NULL, NULL) < 0) {
       star->flags |= STAR1_BADCENTER;
       if(big != NULL) shRegDel(big);
       return(star);
   }

   star->object->rowc = yc;
   star->object->rowcErr = dyc;
   star->object->colc = xc;
   star->object->colcErr = dxc;
   
#if CHECK_OFFSETS 
/* added to investigate differences is astrometric and PS positions  */
   star->col_off = xc - reg->col0 - 32.5;
   star->row_off = yc - reg->row0 - 32.5;
#endif

   yc -= reg->row0; xc -= reg->col0;
#endif
/*
 * Extract the radial profile
 */
   if ((cellstats = phProfileExtract(star->id, -1, reg, yc, xc,
				     -(aperture < 7 ? 7 : aperture), bkgd,
				     star->object->skyErr, 0)) == NULL) {
       shDebug(STAR1_ERRLEVEL,
	       "phStar1MakeFromReg: phProfileExtract returns NULL");
       star->flags |= STAR1_NOPROFILE;
   }
   shAssert(cellstats != NULL);

   if (cellstats->syncreg == NULL) {
       /* Can't use this star without its syncreg */
       shDebug(STAR1_ERRLEVEL,
	       "phStar1MakeFromReg: phProfileExtract returns no syncreg");
       star->flags |= (STAR1_NOPROFILE | STAR1_NOAPMAG | STAR1_BADSKY);
       if(big != NULL) shRegDel(big);
       return(star);
   }
/*
 * Calculate the aperture magnitude. 
 */
   if (cellstats->nannuli_c < aperture) {
       shDebug(STAR1_ERRLEVEL,
	       "phStar1MakeFromReg: star1 %d profile has fewer than %d aps",
	       star->id,aperture);
       star->flags |= STAR1_NOAPMAG;
   } else {
       cstats_loc = phProfileGetLast();
       star->apCounts = phApertureCounts(cstats_loc, aperture,
					 gain, dark_variance, sky,
					 &star->apCountsErr);
#if 1
       star->apCounts1 = phApertureCounts(cstats_loc, 5,
					 gain, dark_variance, sky,
					 NULL);
       star->apCounts2 = phApertureCounts(cstats_loc, 7,
					 gain, dark_variance, sky,
					 NULL);
       star->apC1area = 0;
       for (i = 0; i <= 5; i++) {
           star->apC1area += cellstats->area[i];
       }
       star->apC2area = star->apC1area;
       for (i = 6; i <= 7; i++) {
           star->apC2area += cellstats->area[i];
       }
       if(star->apCounts1 > 0) {
           corr5 = star->apCounts1 + star->apC1area * (star->object->sky-oldsky);
           corr7 = star->apCounts2 + star->apC2area * (star->object->sky-oldsky);
           if(corr5 > 0) {           
              star->wingcorr = corr7 / corr5;
           }          
       }
#endif
       star->aperture = aperture;
       if (star->apCounts <= 0.0) star->flags |= STAR1_NOAPMAG;         
   }


/*
 * copy sinc shifted region which will be needed for psfCounts 
 */
   star->syncreg = shRegNew("syncreg", cellstats->syncreg->nrow, 
                   cellstats->syncreg->ncol, cellstats->syncreg->type);
   shRegIntCopy(star->syncreg,cellstats->syncreg);	

/*
 * We have to do the symmetry rejection here while we still have a REGION
 * to use.  It would be desirable to do it in psfReject, but we'd run out
 * of memory on long runs because we ported around these REGIONs.
 */
   if(threshold >= 0) {
      star->sym = phStar1Symmetric(star,cellstats,fparams,threshold);
   }
/*
 * estimate a local sky, if so desired
 */
#if LOCAL_SKY
   {
      float lsky = phProfileMean(cellstats, cellstats->nannuli_c - 1,
				 2, 1, &annulus_sig);
      phProfileSkySubtract(cellstats, lsky);
      /* star->object->sky += lsky; */
   }
#endif
/*
 * set radial profiles from cellstats
 */
   profile = star->object->profMean;
   profErr = star->object->profErr;
   profileMedian = star->object->profMed;

   for (i = 0; i < cellstats->nannuli_c; i++) {
       profileMedian[i] = phProfileMedian(cellstats, i, 4, 0, NULL);
       profile[i] = phProfileMean(cellstats, i, 4, 0, &annulus_sig);
       if (i == 0) {
	   profErr[0] = sqrt((profile[0] + sky*cellstats->area[0])/gain +
			   cellstats->area[0]*(dark_variance + skysig*skysig));
       } else {
	   profErr[i] = annulus_sig;
       }
   }

   nprof = cellstats->nannuli_c;
   star->object->nprof = nprof;
/*
 * Save the cell profiles.
 */
   posErr = sqrt(pow(star->object->rowcErr,2) + pow(star->object->colcErr,2));

   star->cprof = phCellProfNew(0);

   if (star->dgpsf->width > 0.001 || posErr == 0.0) {
       phCellProfSet(star->cprof, cellstats, 0, sky, gain, dark_variance,
				          star->dgpsf->width, posErr, 1, 0);
   } else { 
       star->flags |= STAR1_NOPROFILE;
   }



/*
 * see if the outermost annulus is too high, due to a bad sky level (e.g.
 * the wings of a bright star)
 */
   if(profile[nprof - 1] > sigma_badsky*skyerr) {
      star->flags |= STAR1_BADSKY;
   }

/* calculate quantities needed for clipping in findPsf */
   if(1 ||				/* RHL -- check with Zeljko XXX */
      star->flags == STAR1_NOFLAGS ||
      (star->flags == (STAR1_NOFLAGS | STAR1_CR))) {
       /* fit 2 Gaussians to get sigmas for clipping in findPsf */
       phDgpsfFitFromCellprof(star->dgpsf,star->cprof); 
       /* mark obviously bad stars */
/* it seems that later rejection takes care of this:
       if (star->dgpsf->b > 0.5) star->flags |= STAR1_BADWIDTH; 
*/

#if USE_U_Q
       /* calculate Q and U */
       calcQandU(star,cellstats);
#else
       {
	  float bkgd_var = 1;		/* background per-pixel variance */
	  float e1 = 0, e2 = 0, rr_cc = 0; /* desired values */
	  int flags2;			/* OBJECT2_??? bits set */
	  float rad = 10;		/* initial guess for radius of object*/
	  float shiftmax = 1;		/* max allowed centroid shift */

	  flags2 = phAdaptiveMomentsGet(reg, yc, xc, rad, bkgd,
					bkgd_var, shiftmax,
					&e1, &e2, &rr_cc, NULL,
					NULL, NULL, NULL, NULL, NULL);
	  if(flags2 == 0) {
	     star->U = e1;
	     star->Q = e2;
	     star->M_rms = sqrt(0.5*rr_cc);
	  } else {
	     star->object->U = star->object->Q = -10001;
	     star->flags |= STAR1_NOSTOKES;
	  }
       }
#endif
   } 

   if(big != NULL) shRegDel(big);

   return(star);
}

/***************************************************************************
 * <AUTO EXTRACT>
 *
 * ROUTINE: phStar1MakeAtPos 
 * 
 * DESCRIPTION: 
 * given a region, and (row, col) position, create a new STAR1
 * structure.  Associate with it a region with STAR_SIZE pixels on a 
 * side, centered at the given position.
 *
 * return: pointer to new STAR1
 *
 * </AUTO>
 */
STAR1 *
phStar1MakeAtPos(REGION *reg,	        /* REGION containing data for STAR1 */
		 float row,		/* central row of star */
		 float col,		/* central col of star */
		 int starsize)		/* size of new STAR1's REGION */
{
   int i, oldi, oldj, sr, sc, er, ec;
   STAR1 *star;
   REGION *newreg;
   
   shAssert(reg != NULL && reg->type == TYPE_U16);

   star = phStar1New();

   /* figure out where to make the new region.  Try to center it on
      given position and have starsize per side. */
   if ((sr = row - starsize/2) < reg->row0)
     sr = reg->row0;
   if ((sc = col - starsize/2) < reg->col0)
     sc = reg->col0;
   if ((er = sr + starsize) >= (reg->row0 + reg->nrow))
     er = (reg->row0 + reg->nrow) - 1;
   if ((ec = sc + starsize) >= (reg->col0 + reg->ncol))
     ec = (reg->col0 + reg->ncol) - 1;
   
   /* 
    * now make a new Region and copy into it the appropriate pixels;
    */
   newreg = shRegNew("phStar1MakeAtPos",er - sr,ec - sc, reg->type);

   newreg->row0=sr;
   newreg->col0=sc;
   
   oldi = sr - reg->row0;
   for (i = 0; i < newreg->nrow; i++, oldi++) {
      oldj = sc - reg->col0;
      memcpy(newreg->rows_u16[i],&reg->rows_u16[oldi][oldj],
	     newreg->ncol*sizeof(U16));
   }
   /* copy the appropriate section of the old region's Mask, too */
   if (reg->mask == NULL) {
      shDebug(1, "phStar1MakeAtPos: region's mask is NULL");
      newreg->mask = (MASK *)phSpanmaskNew(newreg->nrow, newreg->ncol);
   } else {
      shAssert(((SPANMASK *) reg->mask)->cookie == SPAN_COOKIE);
      newreg->mask = (MASK *)phSpanmaskCopy((SPANMASK *) reg->mask,0,0);
   }
   
   star->object->region = newreg;

   return(star);
}

/**********************************************************************/

SYMDIAG *
phSymdiagNew(void)
{
  SYMDIAG *new = shMalloc(sizeof(SYMDIAG));

  new->rms_resid = -1.0;
  new->amp_resid = -1.0;
  new->star = NULL;
  new->residual = NULL;

  return(new);
}

void
phSymdiagDel(SYMDIAG *symdiag)
{
  if(symdiag == NULL) {
     return;
  }

  if(symdiag->star != NULL) {
     shRegDel(symdiag->star);
  }
  
  if(symdiag->residual != NULL) {
     shRegDel(symdiag->residual);
  }

  shFree(symdiag);
}

/*****************************************************************************/
/* 
 *  <AUTO EXTRACT>
 *
 * Return a SYMDIAG, or NULL in case of error
 */
SYMDIAG *
phStar1Symmetric(STAR1 *star1,       /* The STAR1 to be tested */
		 const CELL_STATS *cstats, /* the extracted cell array */
		 const FRAMEPARAMS *fparams,
		 int threshold)      /* floor level for object finder */
{
   int i, j;
   int nrow, ncol;			/* size of the sinc centered image */
   double bkgd;  
   U16 **centim;			/* the sinc centered image we'll flip*/
   U16 thresh[1];			/* Threshold for the object finder */
   REGION *diff, *sync;  /* REGIONS for storing centered & flipped stars */
   CHAIN *objsfound;			/* found objects */
   float rms;				/* rms of residual image */
   int resid_peak;			/* peak amplitude of residuals */
   int star_peak;			/* peak amplitude of image */
   SYMDIAG *sym;			/* holds diagnostic info about the sinc
					   centered subtracted image */

   shAssert(star1 != NULL);
   shAssert(fparams != NULL);

   bkgd = SOFT_BIAS + star1->object->sky;
   rms = 0.0;
   resid_peak = star_peak = 0;

   centim = cstats->syncreg->rows_u16;
   nrow   = cstats->syncreg->nrow;
   ncol   = cstats->syncreg->ncol;
/*
 * Create 2 new regions, sync is a copy of the sync-centered star, and 
 * diff is the residual from rotation the image 180 deg. and subtracting 
 * it from itself.
 *
 * We'll use sync as scratch space before copying over the centred star
 */
   diff = shRegNew("symmetry test", nrow, ncol, TYPE_U16);
   sync = shRegNew("symmetry test", nrow, ncol, TYPE_U16);
   
   for (j = 0; j < nrow; j++) {
      for (i = 0; i < ncol; i++) {
	 int d = SOFT_BIAS + centim[j][i] - centim[(nrow-1)-j][(ncol-1)-i];
	 diff->rows_u16[j][i] = (d < 0) ? 0 : d;
      }
   }
   phConvolveWithGaussian(diff, diff, sync, 11, 1, 0, CONVOLVE_ANY);

   for (j = 0; j < nrow; j++) {
      for (i = 0; i < ncol; i++) {
	 
	 rms += pow((diff->rows_u16[j][i] - SOFT_BIAS),2); 
	 
	 if((sync->rows_u16[j][i] = centim[j][i]) > star_peak) {
	    star_peak = centim[j][i];
	 }
	 
	 if (diff->rows_u16[j][i] - SOFT_BIAS > resid_peak) {
	    resid_peak = diff->rows_u16[j][i] - SOFT_BIAS;
	 }
      }
   }
/*
 * Run the object finder to look for residuals
 */
   thresh[0] = bkgd + 0.01 * threshold * (star_peak - SOFT_BIAS);
   objsfound = phObjectsFind(diff,0,0,0,0,1,thresh,fparams,-1,0);
   shAssert(objsfound != NULL);
/*
 * fill the structure which gives diagnostics about sync-interpolation
 */
   sym = phSymdiagNew();
   sym->rms_resid = sqrt(rms/(nrow*ncol));
   sym->amp_resid = resid_peak;
   sym->star = sync;
   sym->residual = diff;
   
   if(objsfound->nElements > 0 && !(star1->flags & STAR1_SATURATED)) {
      star1->flags |= STAR1_ASYMMETRIC;
   }
/*
 * Cleanup
 */
   for(i = objsfound->nElements - 1; i >= 0; i--) {
      phObjectDel(shChainElementRemByPos(objsfound,i));
   }
   shChainDel(objsfound);  
   
   return(sym);
}  


/*****************************************************************************/
/*
 * Calculate the Stokes parameters Q and U for a STAR1, given its CELL_STATS  
 */
#if USE_U_Q
static void
calcQandU(STAR1 *star, const CELL_STATS *prof)
{
   float cts;	         	 	/* the number of counts in a cell */
   int i;
   int rowc, colc;			/* centre of object */
   int ret;				/* a return code */
   double sum, sum_Q, sum_U;
   float val;				/* a returned value */
   const REGION *const syncreg = prof->syncreg;
   float area[NANN];            	/* areas of annuli */
   int ann_min = 0;         /* first radius for QU evaluation */
   int ann_max = 5;         /* max. number of radial pts. allowed by phStokesParamEval */

/* Set geometry information  
   Area[i] is the area of the i'th annulus and r[i] is the
   value of the INNER radius (so area[0] = pi*r[1]^2).
 */ 
   const CELL_STATS *cstats = phProfileGeometry();      
   for(i = 0;i < NANN;i++) {
       area[i] = cstats->area[i];
   }
 
   rowc = syncreg->nrow/2; 
   colc = syncreg->ncol/2;
   sum = sum_Q = sum_U = 0.0;

   /* sum contributions from each annulus */

#if BAGEL
   ann_min = 3;
#endif
 
   for(i = ann_min;i < ann_max;i++) { 
      if(phStokesParamEval(syncreg,i,SOFT_BIAS,rowc,colc,'Q',0,&val) == 0) {
	 sum_Q += val;
	 ret = phStokesParamEval(syncreg,i,SOFT_BIAS,rowc,colc,'U',0,&val);
	 shAssert(ret == 0);
	 sum_U += val;
         /* flux in this annulus */
	 cts = area[i]*star->object->profMean[i];
	 sum += cts;
      } else {
         star->flags |= STAR1_NOSTOKES;
         return;
      }
   }

   if(sum == 0) {
      star->Q = star->U = -10001;
      star->flags |= STAR1_NOSTOKES;
   } else {
      star->Q = sum_Q/sum;
      star->U = sum_U/sum;
   }

   /* check for NaNs */
   if(star->Q != star->Q || star->U != star->U) {
      star->Q = star->U = -10002;
      star->flags |= STAR1_NOSTOKES;
   }

}
#endif
