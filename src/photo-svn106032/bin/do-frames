#!/bin/sh
#
# Run frames on the 6 columns of data, running one process at a time
#
# The exit status has the nth bit set if the nth column failed (col 6 => 64)
#
# Get permissions right!
#
umask 002
#
# Set default fields
#
pipelines="frames"

columns=""
planlist=""
run=""
rerun=""
show_progress=0
show_times=0
stdout=""
testbed=0
startField=0
endField=0

while [ X"$1" != X"" ]; do
	case $1 in
	 -[h\?])
		cat <<EOF
do-frames [options] [run] [camcol-list] [field]
Run the frames pipeline on specified columns (default: all).
Log files generated by this script are put in directory ./out-\$run

Options:
	-c ###		Columns to process; may be repeated (default: all)
	-d str		Directory containing plan files (may be root of
			data, e.g. /u/dss/data == $DATA_ROOT)
	-e #		Ending field (default: value in plan file)
	-f #		Only process field #
	-h		Print this message
	-m		Trace memory in mem.\$c.trace
	-M		Show progress (from mem.trace) of a do-frames command
	-psp            Run PSP first
	-plan key val	Add "key val" to cmdlinePlan; may be repeated
	-P		Show progress (from run.out) of a do-frames command
	-rerun #	Write to this rerun (default: $rerun)
	-run #		Reduce data from this run (default: $run)
	-s #		Starting field (default: value in plan file)
        -S              Write log to stdout
        -T              Show time taken by a do-frames command
        -testbed        Run the testbed
        -test_info      Generate TEST_INFO files
	-x		Be verbose
	-v #		Make photo verbose
EOF
		exit 0;;
	 -[cdefsv]|-run|-rerun)
		if [ X"$2" = X"" ]; then
			echo "Please supply a value with $1" >&2
			failed=1
		else
			case $1 in
			 -c)
			        columns="$columns `perl -e 'print join(\" \", split(//, '$2'))'`";;
			 -d)
				plandir=$2;;
			 -e)
				endField=$2;;
			 -f)
				startField=$2; endField=$2;;
			 -rerun)
				rerun=$2;;
			 -run)
				run=$2;;
			 -s)
				startField=$2;;
			 -v)
				planlist="$planlist verbose $2";;
			 *)
				echo "Impossible error" >&2;;
			esac
			shift
		fi;;
	 -m)
		trace_memory=1;;
	 -M)
		show_progress_M=1;;
	 -P)
		show_progress=1;;
	 -psp)
		pipelines="psp $pipelines";;
	 -plan)
		if [ X"$3" = X"" ]; then
			echo "Please supply a keyword/value pair with $1" >&2
		else
			planlist="$planlist $2 $3"
			shift; shift
		fi;;
	 -S)
		stdout=1;;
	 -T)
		show_times=1;;
	 -test_info)
		planlist="$planlist write_test_info 1";;
	 -testbed)
		testbed=1;;
	 -x)
		set -vx;;
	 -*)
		echo "Unknown flag $1" >&2
		exit 1;;
	 *)
		break;;
	esac
	shift
done
#
# Process remaining arguments.  If startField is specified, set endField too
#
if [ X"$startField" != X"0" ]; then
	have_startField=1
else
	have_startField=0
fi

for av in run columns startField; do
	if [ X"$1" = X"" ]; then
		break
	fi
	case $1 in
	  [0-9]*) eval $av=$1;;
	  *) echo "Expected value for $av; saw $1" >&2; exit 1;;
	esac
	shift
done

if [ $have_startField = 0 -a X"$startField" != X"0" ]; then
	endField=$startField
fi
#
# OK; all arguments should be processed
#
if [ X"$1" != X"" ]; then
	echo "Unprocessed arguments: $*" >&2
	exit 1;
fi

if [ X"$failed" != X"" ]; then
	exit 1
fi

if [ X"$PHOTO_DIR" = X"" ]; then
	echo "Please set up photo and try again" >&2
	exit 1
fi

if [ X"$columns" = X"" -o X"$columns" = X"all" ]; then
	columns="1 2 3 4 5 6"
fi

if [ X"$startField" != X"0" ]; then
	planlist="$planlist startField $startField"
fi
if [ X"$endField" != X"0" ]; then
	planlist="$planlist endField $endField"
fi

if [ X"$plandir" = X"" ]; then
	if [ X"$DATA_ROOT" != X"" ]; then
		plandir=$DATA_ROOT
	else
		plandir=/home/s1/rhl/data
	fi
fi
if [ $testbed = "1" -a X"`echo $plandir | grep testbed\$`" = X"" ]; then
	plandir=$plandir/testbed
fi
if [ X"`echo $plandir | grep photo\$`" = X"" ]; then
	plandir=$plandir/$run/$rerun/photo
fi

status=0
DERVISH_HISTFILE=""; export DERVISH_HISTFILE

outdir=out-$run
if [ ! -d $outdir ]; then
    echo "Creating $outdir" >&2
    mkdir $outdir
fi
cd $outdir

if [ X"$show_progress" = X"1" -o  X"$show_progress_M" = X"1" -o \
					    X"$show_times" = X"1" ]; then
	if [ X$show_progress_M != X"" ]; then
	    show_progress_M=1
	else
	    show_progress_M=""
	fi
	for c in $columns; do
		if [ ! "$show_progress_M" -a ! -f run.$c.out ]; then
			: No run file
		elif grep -qs "${show_progress_M}OLD RUN FILE" run.$c.out; then
			: do-frames was restarted since file was written
		else
			if [ -f mem.$c.trace -a X"$show_times" = X"1" ]; then
				perl -e '
				 while(<>) {
				     if(/Aborting field/) {
				        $bad_fields{$field}++;
				     }
				     if(/end of run/) {
				        $run_ended = 1;
				     }
				     if(/start field (\d+)/) {
				        $field = $1;
				        if($first_field == 0) {
					   $first_field = $field;
				        }
				     }
				     if(/total nobj: (\d+)/) {
				        $nf++; $n += $1;
					($f1,$f2,$f3,$f4,$f5,$ut,$st) = split;
					$t = $ut + $st;
				     }
				  }

				  $end_field = $field;
				  if(!$run_ended) {
				     $end_field--;
				  }

				  printf("Column '$c'  %3d fields (%3d-%3d) %6d obj  %7.1fs  %5.1f s/f %4.1f ms/obj/band\n",
					$nf, $first_field, $end_field,
					$n, $t, ($nf == 0 ? 0 : $t/$nf),
				        ($n == 0 ? 0 : $t/($n*5/1000)));
				  if(keys(%bad_fields)) {
				     print "     Aborted:";
				     foreach (sort(keys(%bad_fields))) {
					print " $_";
				     }
				     print "\n";
				  }
				' \
				mem.$c.trace
			fi

			if [ X"$show_progress" = X"1" -o \
			     X"$show_progress_M" = X"1" ]; then
				if [ $show_progress_M ]; then
				    status=`grep 'start field' mem.$c.trace | tail -1 | awk '{printf "%s %s %s", $8, $9, $10}'`
				    echo "mem.$c.trace $status"
				else
				    status=`tail -1 run.$c.out`
				    if [ X"$status" = X" Completed OK" ]; then
					status="$status (`ls -l run.$c.out | awk '{printf \"%s %s %s\", $6, $7, $8}'`)"
				    fi
				    echo "run.$c.out $status"
				fi
			fi
		fi
	done
	exit 0
fi

for c in $columns; do
	echo "OLD RUN FILE" >> run.$c.out
done

for c in $columns; do
	for cmd in $pipelines; do
	    if [ X"$cmd" = X"frames" ]; then
		plan=fpPlan
	    elif [ X"$cmd" = X"psp" ]; then
		plan=psPlan
	    else
		echo "Unknown command $cmd" >&2
		exit 1
	    fi
	    
	    if [ X"$trace_memory" != X"" ]; then
		trace="trace_memory mem.$c.trace"
	    fi

	    planfile=$plandir/$plan.par
	    if [ ! -f $planfile ]; then
		planfile=$plandir/$plan-$c.par
	    fi

	    if [ X"$stdout" = X"1" ]; then
		$PHOTO_DIR/bin/photo -command \
		  "do-$cmd -$plan $planfile -plan {$planlist $trace} -rerun $rerun $run $c; exit"
	    else
		uname -n > run.$c.out
		$PHOTO_DIR/bin/photo -command \
		  "do-$cmd -$plan $planfile -plan {$planlist $trace} -rerun $rerun $run $c; exit" \
							    >> run.$c.out 2>&1
	    fi
	    status=`echo $status + \($?/$?\)*2\^$c | bc 2> /dev/null`
       done
done
exit $status
