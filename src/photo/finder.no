#if 0


#include <stdio.h>			/*  */
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <alloca.h>
#include "dervish.h"
#include "atConversions.h"		/* for M_PI, M_SQRT2 */
#include "phSignals.h"
#include "phMaskbittype.h"
#include "phSkyUtils.h"

static CHAIN *gather_objs(OBJMASK *spans, int **plist, int nlevel,
			  const REGION *reg, int npixel_min_level, int npixel_min, int npeak_max,
			  int smoothed);
static CHAIN *find_objs(const REGION *reg, const OBJMASK *om,
			int nlevel, const unsigned short *levels,
			int npixel_min_level, int npixel_min, int npeak_max, int smoothed);
static void sort_spans_y(SPAN *s, int n);
/*
 * init/fini functions for object finder
 */
void
phInitObjectFinder(void)
{
   ;
}

void
phFiniObjectFinder(void)
{
   PEAK *tmp;
   PEAK *base = peak_freelist;		/* dealias peak_freelist */

   while(base != NULL) {
      tmp = base;
      base = (PEAK *)base->next;
      shFree(tmp);
   }

   peak_freelist = NULL;
}

/*
 * <AUTO EXTRACT>
 *
 * Return a PEAK that's a copy of another PEAK
 */
PEAK *
phPeakNewFromPeak(const PEAK *opeak)
{
   return(phPeakCopy(phPeakNew(), opeak));
}


/*****************************************************************************/
/*
 * <AUTO EXTRACT>
 *
 * Copy the properties of an OBJECT; that is, all except the actual OBJMASKs
 */
void
phObjectPropertiesCopy(OBJECT *obj1,const OBJECT *obj2)
{
   int i;
   
   obj1->flags |= obj2->flags;
   obj1->colc = obj2->colc; obj1->colcErr = obj2->colcErr;
   obj1->rowc = obj2->rowc; obj1->rowcErr = obj2->rowcErr;
   if(obj2->peaks->size > 0) {		/* there's a peak list */
      phPeaksRealloc(obj1->peaks, obj2->peaks->npeak);

      for(i = 0;i < obj2->peaks->npeak;i++) {
	 (void)phPeakCopy(obj1->peaks->peaks[i], obj2->peaks->peaks[i]);
      }
   }
}

/*****************************************************************************/
/*
 * Return the range of columns in a region that are not NOTCHECKED
 */
static void
find_active_columns(const REGION *reg,	/* region to examine */
		    int *acol0,		/* first active column */
		    int *acol1)		/* last active column */
{
   int i;
   const SPANMASK *sm = (SPANMASK *)reg->mask;
   int nel;				/* number of elements of notchecked */
   const CHAIN *notchecked;		/* == sm->masks[S_MASK_NOTCHECKED] */
   const int ncol = reg->ncol;
   const int nrow = reg->nrow;
   const OBJMASK *om;			/* an element of om */

   *acol0 = 0; *acol1 = ncol - 1;

   if(sm == NULL || sm->masks[S_MASK_NOTCHECKED] == NULL) {
      return;
   }

   notchecked = sm->masks[S_MASK_NOTCHECKED];
   nel = shChainSize(notchecked);
   for(i = 0; i < nel; i++) {
      om = shChainElementGetByPos(notchecked, i);
      if(om->rmin == 0 && om->cmin == 0 && om->rmax == nrow - 1) {
	 if (om->cmax < ncol - 1) {
	    *acol0 = om->cmax + 1;
	 }
      } else if(om->rmin == 0 && om->cmax == ncol - 1 && om->rmax == nrow - 1){
	 *acol1 = om->cmin - 1;
      }
   }
}

/*****************************************************************************/
/*
 * Is the specified position near the a locally-widest part of an OBJMASK?
 */
static int
at_mask_bulge(CONST OBJMASK *om,	/* the mask */
	      float rowc, int colc)	/* the position */
{
   const int cc = colc + 0.5;
   const int rc = rowc + 0.5;
   int i;
   int i0;				/* index of span including (rc, cc) */
   int r;				/* counter in row */
   int w;				/* width of a span */
   int w0;				/* with of i0th span */
/*
 * Find span containing (rc,cc)
 */
   i0 = phObjmaskFindSpan(om, rc, cc, -1);

   if(i0 < 0) {				/* not in mask */
      return(0);
   }
/*
 * OK, we've found a span including (rc, cc).  Is it wider than its
 * neighbours higher/lower in the mask?
 *
 * Start by searching down the mask
 */
   w0 = om->s[i0].x2 - om->s[i0].x1 + 1; /* width of mask at (rowc, colc) */

   i = i0; w = w0;
   for(r = rc - 3; r >= om->rmin; r--) {
      i = phObjmaskFindSpan(om, r, cc, i);
      if(i < 0) {
	 break;
      }
      
      w = om->s[i].x2 - om->s[i].x1 + 1;
      if(w != w0) {
	 break;
      }
   }

   if(i >= 0 && w > w0) {		/* wider */
      return(0);
   }
/*
 * now search up the mask
 */
   i = i0; w = w0;
   for(r = rc + 3; r <= om->rmax; r++) {
      i = phObjmaskFindSpan(om, r, cc, i);
      if(i < 0) {
	 break;
      }
      
      w = om->s[i].x2 - om->s[i].x1 + 1;
      if(w != w0) {
	 break;
      }
   }

   if(i >= 0 && w > w0) {		/* wider */
      return(0);
   }

   return(1);
}

/*****************************************************************************/
/*
 * <auto EXTRACT>
 *
 * Take a region and an array of thresholds and produce an array of
 * objects based on the connectedness of regions above the first threshold.
 *
 * if a sky level is provided in the fparams, estimate the centres of
 * the detected objects
 */
CHAIN *
phObjectsFind(const REGION *reg,	/* input region */
	      int row0_s, int col0_s,	/* starting row/column to search */
	      int row1_s, int col1_s,	/* ending row/column to search */
	      int nlevel,		/* number of levels */
	      const unsigned short *levels, /* levels in question */
	      const FRAMEPARAMS *fparams, /* gain etc.; can be NULL */
	      int npixel_min_level,	/* level to which npixel_min applies */
	      int npixel_min)		/* min number of pixels in an object
					   (<= 0 => no limit is applied) */
{
   int acol0, acol1;			/* range of non-NOTCHECKED columns */
   CENTROID_FLAGS cflags;		/* control centroiding */
   CURSOR_T curs;			/* cursor for objs */
   int npeak_max;			/* maximum number of peaks/object */
   CHAIN *objs;				/* the CHAIN to return */
   OBJECT *obj;
   int i, j, jj;
   SPANMASK *sm;			/* == reg->mask */
   OBJMASK *saturated_mask = NULL;	/* saturated pixels in object */

   shAssert(reg != NULL);
   shAssert(reg->type == TYPE_PIX);
   sm = (SPANMASK *)reg->mask;
   shAssert(sm == NULL || sm->cookie == SPAN_COOKIE);
   npeak_max = (fparams == NULL) ? -1 : fparams->npeak_per_obj_max;
/*
 * Set the mask bits where we are not looking. Do these in such an order
 * that the OBJMASKs are sorted in y, with a minor sort in x.
 *
 * If there are no bits to set, don't require a mask
 *
 * If there are NOTCHECKED regions along the left and right sides of the
 * chip, adjust the areas specified by col0_s, ncol_s so that the excluded
 * areas are relative to the edge of the previously excluded parts of the frame
 */
   find_active_columns(reg, &acol0, &acol1);
   
   row0_s += 0;
   row1_s += reg->nrow - 1;
   
   col0_s += acol0;
   col1_s += acol1;			/* acol1 == ncol - 1 if all cols good*/

   shAssert(row0_s >= 0 && row1_s < reg->nrow);
   shAssert(col0_s >= 0 && col1_s < reg->ncol);

   if(row0_s > 0 || row1_s != reg->nrow -1 ||
      col0_s > 0 || col1_s != reg->ncol - 1) {
      const char *objmask_type = (char *)shTypeGetFromName("OBJMASK");
      CHAIN *notchecked;
      OBJMASK *om;			/* element to add */

      shAssert(sm != NULL);

      /* bottom */
      notchecked = shChainNew(objmask_type);
      if(row0_s > 0) {
	 om = phObjmaskFromRect(col0_s, 0, col1_s, row0_s - 1);
	 shChainElementAddByPos(notchecked, om, objmask_type, TAIL, AFTER);
      }
      /* left */
      if(col0_s > 0) {
	 om = phObjmaskFromRect(0, 0, col0_s - 1, reg->nrow - 1);
	 shChainElementAddByPos(notchecked, om, objmask_type, TAIL, AFTER);
      }
      /* right */
      if(col1_s < reg->ncol - 1) {
	 om = phObjmaskFromRect(col1_s + 1, 0, reg->ncol - 1, reg->nrow - 1);
	 shChainElementAddByPos(notchecked, om, objmask_type, TAIL, AFTER);
      }
      /* top */
      if(row1_s < reg->nrow - 1) {
	 om = phObjmaskFromRect(col0_s, row1_s + 1, col1_s, reg->nrow - 1);
	 shChainElementAddByPos(notchecked, om, objmask_type, TAIL, AFTER);
      }

      if(notchecked->nElements == 0) {
	 shChainDel(notchecked);
      } else {
	 phCanonizeObjmaskChain(notchecked, 0, 1);

	 sm->masks[S_MASK_NOTCHECKED] =
	   phObjmaskChainMerge(sm->masks[S_MASK_NOTCHECKED], notchecked);
      }
   }
/*
 * If we've already smoothed don't smooth again while centroiding
 */
   cflags = (CENTROID_FLAGS)0;
   if(fparams != NULL && fparams->data_is_smoothed) {
      cflags |= NO_SMOOTH | SMOOTHED;
   }
/*
 * do the work
 */
   objs = find_objs(reg, NULL, nlevel, levels, npixel_min_level, npixel_min, npeak_max,
		    ((cflags & NO_SMOOTH) ? 1 : 0));
/*
 * Find the peak pixel and interpolate to find the postion of the local
 * maximum of pixel intensity, which is as a measure of the centre
 * (an optimal measure of the position if the region is smoothed with
 * the PSF and the object is fainter than sky).
 */
   curs = shChainCursorNew(objs);
   while(phTimeLeft >= 0 && (obj = shChainWalk(objs,curs,NEXT)) != NULL) {
      const OBJMASK *om = obj->sv[0];

      if(om->rmin == reg->row0 || om->rmax == reg->row0 + reg->nrow - 1 ||
	 om->cmin == reg->col0 || om->cmax == reg->col0 + reg->ncol - 1) {
	 obj->flags |= OBJECT1_EDGE;	/* OBJECT touches the edge */
      }

      if(om->rmin == row0_s + reg->row0 || om->rmax == row1_s + reg->row0 ||
	 om->cmin == col0_s + reg->col0 || om->cmax == col1_s + reg->col0) {
	 obj->flags2 |= OBJECT2_LOCAL_EDGE; /* OBJECT touches the edge
					       of !NOTCHECKED area */
      }
      
      if(sm == NULL) {
	 saturated_mask = NULL;
      } else {
	 if(phObjmaskIntersectMask(sm->masks[S_MASK_CR],om)){
	    obj->flags |= OBJECT1_CR;
	 }
	 if(phObjmaskIntersectMask(sm->masks[S_MASK_INTERP],om)){
	    obj->flags |= OBJECT1_INTERP;
	 }
	 if((saturated_mask =
	     phObjmaskIntersection(om, sm->masks[S_MASK_SATUR])) != NULL){
	    obj->flags |= OBJECT1_SATUR;
	 }
	 if(phObjmaskIntersectMask(sm->masks[S_MASK_SUBTRACTED],om)) {
	    obj->flags |= OBJECT1_SUBTRACTED;
	 }
	 if(phObjmaskIntersectMask(sm->masks[S_MASK_NOTCHECKED],om)) {
	    obj->flags |= OBJECT1_NOTCHECKED;
	 }
      }

      if(fparams != NULL) {
	 int bkgd = fparams->bkgd + SOFT_BIAS;
	 if(fparams->sky != NULL) {
	    phObjectCenterFit(obj, reg, fparams, cflags);

	    if(saturated_mask != NULL) { /* we found saturated pixels */
/*
 * If the object's saturated (as opposed to being on a saturation trail),
 * estimate radius of object that's totally destroyed by saturation, and
 * label it NOTCHECKED.
 *
 * We have to play some games to guess if this is a very bright object,
 * or merely a faint peak superimposed on a bleed trail.  Specifically,
 * demand that its peak value exceeds half the saturation level (with
 * interpolation we cannot demand that it exceed it), and that the peak's
 * near the widest point in a saturation level
 */
	       shAssert(obj->peaks != NULL && obj->peaks->npeak > 0);
	       if(obj->peaks->peaks[0]->peak >
			 0.5*(fparams->fullWell[0] + fparams->fullWell[1])/2 &&
		  at_mask_bulge(saturated_mask, obj->rowc, obj->colc)) {
		  int r1 = obj->colc - saturated_mask->cmin;
		  int r2 = saturated_mask->cmax - obj->colc;
		  int r = (r1 < r2) ? r1 : r2;
		  if(r >= 0) {
		     OBJMASK *ignore =
		       phObjmaskFromCircle(obj->rowc, obj->colc, r + 5);
		     phObjmaskAddToSpanmask(ignore, sm, S_MASK_NOTCHECKED);
		  }
	       }
	    }
	 }
/*
 * Reject peaks within NOTCHECKED areas. XXX We could get into trouble with
 * e.g. CRs superimposed on the peaks of objects
 *
 * Label peaks that lie in a BRIGHT area --- it's already been searched
 * (and may now be "saturated" if we scaled up before running the object
 * finder). We don't want to delete the peak now as it'll have an interesting
 * OBJMASK associated with it, but we do _not_ want to keep it on the
 * final peak list. It'll be deleted during merge colours.
 *
 * We need to centroid peaks in saturated regions differently too, so
 * set the PEAK_SATUR flag too
 */
	 for(j = jj = 0;j < obj->peaks->npeak;j++) {
	    const int cc = obj->peaks->peaks[j]->cpeak;
	    const int rc = obj->peaks->peaks[j]->rpeak;
	    if(sm != NULL) {
	       if(phPixIntersectMask(sm->masks[S_MASK_BRIGHTOBJECT], cc, rc)) {
		  obj->peaks->peaks[j]->flags |= PEAK_IN_BRIGHT;
	       }
	       if(phPixIntersectMask(sm->masks[S_MASK_SATUR],cc,rc)) {
		  obj->peaks->peaks[j]->flags |= PEAK_SATUR;
	       }
	       if(phPixIntersectMask(sm->masks[S_MASK_NOTCHECKED],cc,rc)) {
		  if(j == 0 && (obj->peaks->peaks[j]->flags & PEAK_SATUR)) {
		     ;			/* keep brightest saturated peak */
		  } else {
		     phPeakDel(obj->peaks->peaks[j]);
		     obj->peaks->peaks[j] = NULL;
		     phObjmaskDel(saturated_mask); saturated_mask = NULL;

		     continue;
		  }
	       }
	    }
	    
	    if(j != jj) {
	       obj->peaks->peaks[jj] = obj->peaks->peaks[j];
	       obj->peaks->peaks[j] = NULL;
	    }
	    jj++;
	 }

	 if((obj->peaks->npeak = jj) == 0) { /* all in NOTCHECKED areas */
	    shChainElementRemByCursor(objs, curs);
	    phObjectDel(obj);
	    phObjmaskDel(saturated_mask);

	    continue;
	 }
/*
 * get better centers for all those peaks
 */
	 for(i = 0;i < obj->peaks->npeak;i++) {
	    obj->peaks->peaks[i]->peak -= bkgd;
	    if(fparams->sky != NULL) {
	       phPeakCenterFit(obj->peaks->peaks[i], reg, obj->sv[0],
			       fparams, 1, cflags);
	    }
	 }
      }

      phObjmaskDel(saturated_mask);
   }
   shChainCursorDel(objs,curs);

   return(objs);
}

/******************************************************************************/
/*
 * Trim a region to a given threshold, returning a new region (not subregion);
 * the usual npixel_min and ngrow are used.
 *
 * The region is actually trimmed to the largest set of connected pixels
 * contained in the region.
 *
 * If masktype is a valid member of a SPANMASK, then that plane is set to
 * the detected pixels (this will typically be S_MASK_OBJECT)
 */
REGION *
phRegionTrimToThreshold(const REGION *in, /* the input region */
			float threshold,  /* the desired threshold */
			int npixel_min,	  /* min number of pixels in an object
					     (<= 0 => no limit is applied) */
			int ngrow,	  /* how many pixels to grow detections */
			S_MASKTYPE masktype) /* which bit plane to set in reg->mask (or -1) */
{
   const unsigned short levs[] = {threshold}; /* desired levels */
   int nobjs;				/* == objs->nElements */
   int npixel_min_level = 0;		/* XXX */
   CHAIN *objs;				/* detected objects */
   OBJECT *obj;				/* our chosen object */
   OBJMASK *om;				/* the detected object */
   REGION *out = NULL;			/* trimmed region */

   shAssert(in != NULL);

   objs = phObjectsFind(in, 0, 0, 0, 0, 1, levs, NULL, npixel_min_level, npixel_min);
   phObjectChainGrow(objs, 0, in, ngrow);
   nobjs = objs->nElements;

   if (nobjs == 0) {
       shChainDel(objs);
       return NULL;
   }

   if(nobjs > 1) {
#if 0
       shError("%d objects detected (using brightest)", nobjs);
#else
       shAssert(nobjs == nobjs);	/* for gdb's sake */
#endif
   }

   {
       int i;
       int biggest = -1;		/* the biggest object */
       int npix_max = -1;		/* biggest's size */
       for(i = 0; i < nobjs; i++) {
	   obj = shChainElementGetByPos(objs, i);
	   if (obj->sv[0]->npix > npix_max) {
	      npix_max = obj->sv[0]->npix;
	      biggest = i;
	   }
       }

       obj = shChainElementGetByPos(objs, biggest);
   }
   /*
    * OK, we've found the largest object; extract its OBJMASK
    */
   om = obj->sv[0];
   obj->sv[0] = NULL;
   shChainDestroy(objs, (void (*)(void *))phObjectDel);
   /*
    * Trim the region
    */
   {
       int nrow = om->rmax - om->rmin + 1;
       int ncol = om->cmax - om->cmin + 1;
       REGION *tmp = shSubRegNew("", in, nrow, ncol,
				 om->rmin - in->row0, om->cmin - in->col0, NO_FLAGS);
       shAssert(tmp != NULL);
       out = shRegNew("Trimmed region", nrow, ncol, in->type);
       shRegIntCopy(out, tmp);
       out->row0 += tmp->row0; out->col0 += tmp->col0;

       shRegDel(tmp);
   }
   out->row0 += in->row0; out->col0 += in->col0;
   /*
    * Did we want to add it to the mask?
    */
   if (masktype >= 0 && masktype < S_NMASK_TYPES) {
       out->mask = (MASK *)phSpanmaskNew(out->nrow, out->ncol);
       phObjmaskAddToSpanmask(om, (SPANMASK *)out->mask, masktype);
       om = NULL;
   }

   phObjmaskDel(om);		  

   return(out);
}


#endif
