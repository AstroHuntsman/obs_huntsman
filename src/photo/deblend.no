
static void average_peak_centers(const PEAK *peak1, const PEAK *peak2,
				 float *rowc, float *colc);
static void merge_peaks(PEAK *peak_i, PEAK *peak_j);


/*****************************************************************************/
/*
 * <AUTO EXTRACT>
 *
 * Delete all of an OBJC's children
 */
void
phObjcChildrenDel(OBJC *objc)
{
   phObjcDel(objc->sibbs, 1);
   objc->sibbs = NULL;

   phObjcDel(objc->children, 1);
   objc->children = NULL;

   objc->nchild = 0;
}

/*****************************************************************************/
/*
 * <AUTO EXTRACT>
 *
 * Recalculate an object's centre now that it's been deblended, based
 * on its nominal peak position
 */
void
phDeblendedObjcRecenter(OBJC *objc,	/* the object in question */
			const FIELDPARAMS *fiparams) /* properties of field */
{
   int c;
   const REGION *data;			/* == fiparams->frame[c].data */
   float drow, dcol;			/* offsets from reference colour */
   OBJECT1 *obj1;
   int rpeak, cpeak;			/* peak pixel of an object */
   float threshold;			/* threshold for accepting peaks */

   shAssert(objc != NULL && fiparams != NULL);
   
   for(c = 0;c < objc->ncolor;c++) {
      obj1 = objc->color[c];
      
      if(obj1 == NULL) {
	 continue;
      }
/*
 * Was the centre already estimated for missing detections of this object,
 * based on it's motion?
 */
      if(objc->flags2 & OBJECT2_DEBLENDED_AS_MOVING) {
	 continue;
      }
/*
 * See if the peak was bright enough to have been detected, but wasn't;
 * this can happen to children due to the vagueries of peak matching
 */
      if(objc->parent == NULL) {
	 continue;
      }

      if(obj1->peaks == NULL || obj1->peaks->npeak == 0) {
	 shAssert(!(obj1->flags & OBJECT1_DETECTED));

	 phOffsetDo(fiparams, objc->rowc, objc->colc, 
		    fiparams->ref_band_index, c,
		    1, NULL, NULL, &drow, NULL, &dcol, NULL);

	 rpeak = objc->rowc + drow;
	 cpeak = objc->colc + dcol;
	 data = fiparams->frame[c].data;
	 shAssert(data != NULL);
	 
	 threshold = fiparams->frame[c].ffo_threshold +
					   fiparams->frame[c].bkgd + SOFT_BIAS;

	 if(rpeak < 0 || rpeak >= data->nrow ||
	    cpeak < 0 || cpeak >= data->ncol ||
					data->ROWS[rpeak][cpeak] < threshold) {
	    continue;
	 } else {
	    obj1->flags  |= OBJECT1_BINNED1;
	    obj1->flags2 |= OBJECT2_DEBLEND_NOPEAK;
	    
	    if(obj1->peaks == NULL) {
	       obj1->peaks = phPeaksNew(1);
	    } else {
	       phPeaksRenew(obj1->peaks, 1);
	    }
	    
	    obj1->peaks->npeak = 1;
	    obj1->peaks->peaks[0]->rpeak = rpeak;
	    obj1->peaks->peaks[0]->cpeak = cpeak;
	 }
      }

      phObject1CenterFit(obj1, fiparams->frame[c].data,
			 &fiparams->frame[c], 32, ALWAYS_SMOOTH);
   }

   if(objc->peaks != NULL) {
      objc->peaks->npeak = 0;		/* discard old peaks list */
   }
   phObjcPeaksSetFromObject1s(objc, fiparams);
  
   objc->flags3 &= ~OBJECT3_HAS_CENTER;
   phObjcCenterCalc(objc, fiparams, 0);	/* find canonical centre */
}



