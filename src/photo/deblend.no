static void average_peak_centers(const PEAK *peak1, const PEAK *peak2,
				 float *rowc, float *colc);
static void merge_peaks(PEAK *peak_i, PEAK *peak_j);

/*****************************************************************************/
/*
 * <AUTO EXTRACT>
 *
 * Setup scratch space for the deblender
 */
void
phDeblendSet(REGION *i_scr0,
	     REGION *i_scr1,
	     REGION *i_scr2,
	     REGION *i_scr3)
{
   int i;
   
   scr0 = i_scr0; scr1 = i_scr1; scr2 = i_scr2;

   if(scr0 == NULL) {
      shAssert(scr1 == NULL && scr2 == NULL && i_scr3 == NULL);
      return;
   }

   shAssert(scr0->type == TYPE_PIX);
   shAssert(scr1 != NULL && scr1->type == TYPE_PIX);
   shAssert(scr1->nrow == scr0->nrow && scr1->ncol == scr0->ncol);
   shAssert(scr2 != NULL && scr2->type == TYPE_PIX);
   shAssert(scr2->nrow == scr0->nrow && scr2->ncol == scr0->ncol);
   shAssert(i_scr3 != NULL && i_scr3->type == TYPE_PIX);
   shAssert(i_scr3->nrow == scr0->nrow && i_scr3->ncol == scr0->ncol);
/*
 * we want to make a MASK out of the i_scr3
 */
   shAssert(sizeof(mscr0->rows[0][0]) <= sizeof(PIX));

   mscr0 = shMaskNew("deblender", i_scr3->nrow, 0);
   for(i = 0; i < mscr0->nrow; i++) {
      mscr0->rows[i] = (unsigned char *)i_scr3->ROWS[i];
   }
   mscr0->ncol = i_scr3->ncol;
}

/*****************************************************************************/
/*
 * Note that we don't actually own this scratch space, we merely borrowed
 * it in phDeblendSet
 */
void
phDeblendUnset(void)
{
   scr0 = scr1 = scr2 = NULL;
   mscr0->rows[0] = NULL;		/* memory belongs to i_scr3 */
   shMaskDel(mscr0); mscr0 = NULL;
}

/*****************************************************************************/
/*
 * <AUTO EXTRACT>
 *
 * delete an OBJC which is a descendent of some other OBJC
 */
void
phObjcChildDel(OBJC *child)		/* the child to destroy */
{
   OBJC *objc;
   OBJC *parent;
   
   shAssert(child != NULL && child->children == NULL);
   parent = child->parent;
   shAssert(parent != NULL && parent->nchild > 0);
   shAssert(parent->children != NULL || parent->sibbs != NULL);
   parent->nchild--;
 
   if(parent->sibbs == child) {		/* at start of parent's sibbs chain*/
      parent->sibbs = child->sibbs;
      phObjcDel(child, 0);
      
      return;
   }

   if(parent->children == child) {	/* at start of childrens' sibbs chain*/
      parent->children = child->sibbs;
      phObjcDel(child, 0);
      
      return;
   }

   for(objc = parent->children;objc != NULL;objc = objc->sibbs) {
      if(objc->sibbs == child) {	/* a sibbling not at start of chain */
	 objc->sibbs = child->sibbs;
	 phObjcDel(child, 0);

	 return;
      }
   }
   shFatal("phObjcChildDel: Cannot find the child's family");
}


   
/*****************************************************************************/
/*
 * <AUTO EXTRACT>
 *
 * Delete all of an OBJC's children
 */
void
phObjcChildrenDel(OBJC *objc)
{
   phObjcDel(objc->sibbs, 1);
   objc->sibbs = NULL;

   phObjcDel(objc->children, 1);
   objc->children = NULL;

   objc->nchild = 0;
}

/*****************************************************************************/
/*
 * <AUTO EXTRACT>
 *
 * Recalculate an object's centre now that it's been deblended, based
 * on its nominal peak position
 */
void
phDeblendedObjcRecenter(OBJC *objc,	/* the object in question */
			const FIELDPARAMS *fiparams) /* properties of field */
{
   int c;
   const REGION *data;			/* == fiparams->frame[c].data */
   float drow, dcol;			/* offsets from reference colour */
   OBJECT1 *obj1;
   int rpeak, cpeak;			/* peak pixel of an object */
   float threshold;			/* threshold for accepting peaks */

   shAssert(objc != NULL && fiparams != NULL);
   
   for(c = 0;c < objc->ncolor;c++) {
      obj1 = objc->color[c];
      
      if(obj1 == NULL) {
	 continue;
      }
/*
 * Was the centre already estimated for missing detections of this object,
 * based on it's motion?
 */
      if(objc->flags2 & OBJECT2_DEBLENDED_AS_MOVING) {
	 continue;
      }
/*
 * See if the peak was bright enough to have been detected, but wasn't;
 * this can happen to children due to the vagueries of peak matching
 */
      if(objc->parent == NULL) {
	 continue;
      }

      if(obj1->peaks == NULL || obj1->peaks->npeak == 0) {
	 shAssert(!(obj1->flags & OBJECT1_DETECTED));

	 phOffsetDo(fiparams, objc->rowc, objc->colc, 
		    fiparams->ref_band_index, c,
		    1, NULL, NULL, &drow, NULL, &dcol, NULL);

	 rpeak = objc->rowc + drow;
	 cpeak = objc->colc + dcol;
	 data = fiparams->frame[c].data;
	 shAssert(data != NULL);
	 
	 threshold = fiparams->frame[c].ffo_threshold +
					   fiparams->frame[c].bkgd + SOFT_BIAS;

	 if(rpeak < 0 || rpeak >= data->nrow ||
	    cpeak < 0 || cpeak >= data->ncol ||
					data->ROWS[rpeak][cpeak] < threshold) {
	    continue;
	 } else {
	    obj1->flags  |= OBJECT1_BINNED1;
	    obj1->flags2 |= OBJECT2_DEBLEND_NOPEAK;
	    
	    if(obj1->peaks == NULL) {
	       obj1->peaks = phPeaksNew(1);
	    } else {
	       phPeaksRenew(obj1->peaks, 1);
	    }
	    
	    obj1->peaks->npeak = 1;
	    obj1->peaks->peaks[0]->rpeak = rpeak;
	    obj1->peaks->peaks[0]->cpeak = cpeak;
	 }
      }

      phObject1CenterFit(obj1, fiparams->frame[c].data,
			 &fiparams->frame[c], 32, ALWAYS_SMOOTH);
   }

   if(objc->peaks != NULL) {
      objc->peaks->npeak = 0;		/* discard old peaks list */
   }
   phObjcPeaksSetFromObject1s(objc, fiparams);
  
   objc->flags3 &= ~OBJECT3_HAS_CENTER;
   phObjcCenterCalc(objc, fiparams, 0);	/* find canonical centre */
}

/*****************************************************************************/
/*
 * Find the largest objmask that _excludes_ the point (rout, cout)
 * but _includes_ (rin, cin) in the mask om
 */
static OBJMASK *
find_maximal_objmask(const REGION *reg,	/* region that object exists in */
		     const OBJMASK *om,	/* mask of possible pixels */
		     int rin, int cin,	/* peak to be included */
		     int rout, int cout, /* peak to be excluded */
		     int low, int high,	/* range of thresholds to consider */
		     int ngrow,	 	/* number of pixels to grow mask */
		     int *critical)	/* critical threshold */
{
   OBJMASK *highmask = NULL;		/* mask corresponding to level high */
   int mid;				/* intermediate threshold */
   const OBJMASK *mask = om;		/* desired mask */
   OBJMASK *midmask = NULL;		/* mask corresponding to level mid */
/*
 * find critical threshold by binary search
 */
   for(;;) {
      mid = (low + high)/2;
      if(mid == low) {			/* got it */
	 break;
      }

      midmask = phObjmaskFindInObjmask(reg, mask, rin, cin, mid);
      if(midmask == NULL) {
	 high = mid;
      } else {
	 if(phPixIntersectObjmask(midmask, cout, rout)) {
	    low = mid;
	    if(mask != om) {
	       phObjmaskDel((OBJMASK *)mask);
	    }
	    mask = midmask; midmask = NULL;
	 } else {
	    high = mid;
	    phObjmaskDel(highmask);
	    highmask = midmask; midmask = NULL;
	 }
      }
   }
   phObjmaskDel(midmask);
/*
 * find the mask that didn't _quite_ contain both peaks. If highmask is
 * NULL it must because the original high threshold was never used, so
 * use it now and see if it includes (rout, cout)
 */
   if(highmask == NULL) {
      if(high == low) high++;
      
      highmask = phObjmaskFindInObjmask(reg, mask, rin, cin, high);
      if(highmask != NULL && phPixIntersectObjmask(highmask, cout, rout)) {
	 phObjmaskDel(highmask);
	 highmask = NULL;
      }
   }
   shAssert(highmask == NULL || !phPixIntersectObjmask(highmask,cout,rout));
#if 1
/*
 * grow highmask, but not into object containing (rout, cout)
 */
   if(ngrow > 0 && highmask != NULL && highmask->npix > 2) { /* npix XXX */
       OBJMASK *grown = phObjmaskGrow(highmask, reg, ngrow);
       OBJMASK *out_mask;	 /* pixels above critical containing (rout, cout) */
       phObjmaskDel(highmask);
       out_mask = phObjmaskFindInObjmask(reg, mask, rout, cout,
					 SOFT_BIAS + 4*(*critical - SOFT_BIAS));
       if(out_mask != NULL) {	 /* grow object containing desired peak, (rout,cout) */
	   OBJMASK *gout_mask = phObjmaskGrow(out_mask, reg, ngrow);
	   phObjmaskDel(out_mask);
	   out_mask = gout_mask;
       }
       highmask = phObjmaskAndNotObjmask(grown, out_mask);
       phObjmaskDel(out_mask);
   }
#endif
/*
 * clean up
 */
   if(mask != om) {
      phObjmaskDel((OBJMASK *)mask);
   }
/*
 * return desired mask and threshold
 */
   if(critical != NULL) {
      *critical = mid;
   }

   return(highmask);
}

/*****************************************************************************/
/*
 * return a better estimate of a deblending template. The template is
 * specified as the values of the data region, within the master_mask
 *
 * We pass in the scratch buffers purely for efficiency; that way we
 * can allocate them once per object rather than once per colour
 *
 * If no template is detected after smoothing, return NULL. Otherwise
 * return the mask of pixels in the template
 */
static OBJMASK *
improve_template(const OBJMASK *mask,	/* OBJC's master_mask */
		 int band,		/* which band are we processing? */
		 int rpeak, int cpeak,	/* position of peak of object */
		 REGION *data,		/* region specifying template */
		 int drow,		/* offset of mask to convert to */
		 int dcol,		/*     this band's coordinate system */
		 REGION *scra, REGION *smoothed, /* two buffers for smoothing*/
		 int rsize, int csize,	/* size of smoothing buffers */
		 float sigma,		/* s.d. of smoothing filter */
		 int filtsize,		/* size of smoothing filter */
		 int npeak_max,         /* max number of peaks/object */
		 ATLAS_IMAGE **smoothed_ai, /* ATLAS_IMAGE containing smoothed
					      templates */
		 int threshold,		/* object finding threshold */
		 int ngrow)		/* how far to grow objects */
{
   int i;
   unsigned short levels[1];		/* thresholds for object finder */
   int nobj;				/* number of objects detected */
   CHAIN *objs;				/* all objects in mask above levels */
   OBJECT *obj = NULL;			/* an object on the objs list */
   OBJMASK *objmask;			/* OBJMASK of desired object */
   int r0, c0;				/* origin of subdata in data */
   REGION *subdata;			/* subregion around peak */
   
   c0 = mask->cmin + dcol - filtsize/2;
   r0 = mask->rmin + drow - filtsize/2;
   shAssert(r0 >= 0 && r0 + rsize - 1 < data->nrow);
   shAssert(c0 >= 0 && c0 + csize - 1 < data->ncol);
/*
 * smooth the input data. Note that we don't own smoothed, so no memory
 * leak is occuring when we set it to a subregion of itself
 */
   subdata = shSubRegNew("", data, rsize, csize, r0, c0, NO_FLAGS);
   if(sigma <= 0) {
      smoothed = (REGION *)subdata;
   } else {
      phConvolveWithGaussian(smoothed, subdata, scra, filtsize, sigma,
			     0, CONVOLVE_ANY);
   }
   smoothed = shSubRegNew("", smoothed, rsize - filtsize, csize - filtsize,
			  filtsize/2, filtsize/2, NO_FLAGS);
   smoothed->row0 = mask->rmin; smoothed->col0 = mask->cmin;
/*
 * save the smoothed image in an atlas image of its own. We'll use this
 * for assigning the light in pixels with very low S/N per pixel
 */
   {
      const int s_drow = (*smoothed_ai)->drow[band];
      const int s_dcol = (*smoothed_ai)->dcol[band];

      (*smoothed_ai)->drow[band] = (*smoothed_ai)->dcol[band] = 0;
      phAtlasImageSetFromRegion(*smoothed_ai, band, smoothed);
      (*smoothed_ai)->drow[band] = s_drow; (*smoothed_ai)->dcol[band] = s_dcol;
   }
/*
 * set a suitable set of thresholds
 */
   levels[0] = SOFT_BIAS + threshold;
/*
 * now look for objects. Note that the mask is the object's master_mask,
 * and is therefore in canonical coordinates. We faked the origin of
 * smoothed to allow for this, but as a consequence the detected objects
 * are also in the canonical coordinate system. For simplicity, we'll
 * convert cpeak and rpeak too
 */
   rpeak -= drow; cpeak -= dcol;

   objs = phObjectsFindInObjmask(smoothed, mask, 1, levels, -1, 0, 100*npeak_max); /* XXX 100 */
   shAssert(objs != NULL);
   nobj = objs->nElements;
/*
 * Dump a region for debugging?
 */
   {
       static char *dump_filename = NULL; /* write data to this file?
					     For use from gdb */
       if(dump_filename != NULL) {
	   shRegWriteAsFits(smoothed,
			    dump_filename, STANDARD, 2,DEF_NONE,NULL,0);
	   dump_filename = NULL;
       }
   }
/*
 * Look for the peak that led to this template
 */
   for(i = 0;i < nobj;i++) {
      obj = shChainElementRemByPos(objs,HEAD);
/*
 * is this our object, that is, does it contain our peak?
 */
      if(phPixIntersectObjmask(obj->sv[0], cpeak, rpeak)) {
	 i++;
	 break;
      }
      phObjectDel(obj); obj = NULL;
   }
   for(;i < nobj;i++) {			/* destroy all unwanted objects */
      phObjectDel(shChainElementRemByPos(objs, HEAD));
   }
   shChainDel(objs);
/*
 * Correct the peaks for smoothed's origin ; this should really be done by
 * phObjectsFindInObjmask()
 */
   if(obj != NULL) {
      for(i = 0; i < obj->peaks->npeak; i++) {
	 obj->peaks->peaks[i]->rpeak += smoothed->row0;
	 obj->peaks->peaks[i]->rowc += smoothed->row0;
	 obj->peaks->peaks[i]->cpeak += smoothed->col0;
	 obj->peaks->peaks[i]->colc += smoothed->col0;
      }
   }
/*
 * process our object. We found it with a variety of different thresholds,
 * and in general the higher detection thresholds will lead to non-simply-
 * -connected OBJMASKs. If this is the case (i.e. if it has more than one
 * peak) we now remove the non-connected parts from the template.
 */
   if(obj == NULL) {
      objmask = NULL;
   } else {
      OBJMASK *clipped = phObjmaskNew(0); /* which pixels have been clipped */
      int critical = 0;			/* critical threshold to split peaks */
      OBJMASK *max_mask;		/* maximal mask including a peak,
					   but excluding main peak */
      PEAK *peak;			/* a peak in the object */

      if(obj->peaks->npeak > 1) {
	 for(i = 0; i < obj->peaks->npeak; i++) {
	    peak = obj->peaks->peaks[i];
/*
 * find the lowest threshold that includes peak->[cr]peak but not [cr]peak.
 */
	    max_mask = find_maximal_objmask(smoothed, obj->sv[0],
					    peak->rpeak, peak->cpeak,
					    rpeak, cpeak,
					    SOFT_BIAS, SOFT_BIAS + peak->peak,
					    ngrow, &critical);
#if 0
	    if(max_mask != NULL && max_mask->npix > 2) { /* XXX */
	       phObjmaskAndNotObjmask(max_mask, clipped);
	       phRegIntClipValInObjmask(data, max_mask, 0, 0, critical);
	       phRegIntClipValInObjmask(data, max_mask, 0, 0, SOFT_BIAS);
	       phObjmaskOrObjmask(clipped, max_mask);
	    }
#else
	    if(max_mask != NULL && max_mask->nspan > 0) {
	       OBJMASK *grown = phObjmaskGrow(max_mask, smoothed, ngrow);
	       phObjmaskAndNotObjmask(grown, clipped);
	       phRegIntClipValInObjmask(data, grown, 0, 0, critical);
	       phObjmaskOrObjmask(clipped, grown);
	       phObjmaskDel(grown);
	    }
#endif
	    phObjmaskDel(max_mask);	/* may be NULL */
	 }
      }
      phObjmaskDel(clipped);
/*
 * grow the original mask, and convert to object's coordinate system
 */
      {
	  OBJMASK *grown = phObjmaskGrow(obj->sv[0], smoothed, ngrow);
	  objmask = phObjmaskCopy(grown, drow, dcol);
	  phObjmaskDel(grown);
      }

      phObjectDel(obj);
   }
/*
 * clean up
 */
   shRegDel(subdata);
   if(smoothed != data) {
      shRegDel(smoothed);
   }
   
   return(objmask);
}

/*****************************************************************************/
/*
 * copy the pixels in <in> to <out> within the <mask>
 *
 * The region <in> is supposed to have its origin at the point (rmin,cmin)
 */
static void
copy_region_within_mask(REGION *out,	/* region to copy to */
			const REGION *in, /* input region */
			const OBJMASK *mask, /* the mask to use */
			int drow, int dcol) /* offset to apply to mask */
{
   int i;
   const int nrow = out->nrow;
   const int ncol = out->ncol;
   const int cmin = mask->cmin + dcol;
   const int rmin = mask->rmin + drow;
   int x1, x2, y;			/* unpacked from a span */
   
   for(i = 0;i < mask->nspan;i++) {
      y = mask->s[i].y + drow;
      x1 = mask->s[i].x1 + dcol; x2 = mask->s[i].x2 + dcol;
      if(y < 0 || y >= nrow) {
	 continue;
      }
      if(x1 < 0) x1 = 0;
      if(x2 >= ncol) x2 = ncol - 1;
      
      memcpy(&out->ROWS[y][x1], &in->ROWS[y - rmin][x1 - cmin],
						    (x2 - x1 + 1)*sizeof(PIX));
   }
}

/*****************************************************************************/
/*
 * Find an object's deblend template.
 *
 * It's stored in the OBJC's ATLAS_IMAGE, as there exists convenient code
 * to do so. While this routine is running, however, the template is
 * accumulated in a scratch region (sym), and then within the parent
 * data region. The original pixels are preserved in the parent's
 * atlas image structure, so this is OK.
 *
 * N.b. The amplitude of the PSF fit is in objc->color[c]->profMean[0],
 * the value of the template at the original peak is in profMean[1],
 * the maximum value of the template is in profMean[2], and the amplitude
 * of the pedestal in profMean[3]
 */
#define DONT_USE_SUBTRACTED 0		/* don't use PSF-subtracted pixels */
#define MISSING_TEMPLATES_ARE_PSF 0	/* objects with no template are
					   taken to be PSFs */

static int
deblend_template_find(OBJC *objc,	/* the OBJC in question */
		      OBJMASK **psfmasks, /* masks for pixels in PSFs */
		      const FIELDPARAMS *fiparams, /* gain etc. */
		      ATLAS_IMAGE **smoothed_ai, /* ATLAS_IMAGE containing
						   smoothed templates */
		      int filtsize,	/* size of smoothing filter */
		      int ngrow)	/* how many pixels to grow objects */
{
   int aimage_drow, aimage_dcol;	/* ==objc->parent->aimage->d{row,col}*/
   int bias;				/* bias in sky level */
   int bkgd;				/* == bkgd from fiparams + SOFT_BIAS */
   int c;				/* counter in colour */
   int cmin, rmin;			/* origin of master_mask, as corrected
					   by aimage->d{row,col}[] */
   int csize, rsize;			/* size of master_mask's BBox */
   REGION *data;			/* fiparams->frame[].data */
   int i;
   OBJMASK *mmask;			/* objc->parent->aimage->master_mask */
   int my, mx1, mx2;			/* mirrored values of y, x2, x1 */
   int nrow = 0, ncol = 0;		/* == data->n{row,col} */
   int npeak_max = 10;			/* max number of peaks per object */
   OBJECT1 *obj1;			/* == objc->color[c] */
   MASK *psfmask;			/* MASK equiv to psfmasks[c] */
#if DONT_USE_SUBTRACTED
   unsigned char *psfrow, *mpsfrow;	/* psfmask->rows[] and its mirror */
#endif
   PIX *row, *mrow;			/* data[]->ROWS[] and its mirror */
   int rowc, colc;			/* centre of object */
   int ncolor;				/* == objc->ncolor */
   REGION *scra, *scrb;			/* two buffers for smoothing */
   PIX *srow;				/* sym->ROWS[] */
   REGION *sym;				/* symmetrised object */
   int template_max;			/* maximum allowed value of template */
   PIX val, mval;			/* data[]->ROWS[][] and its mirror */
   PIX tval;				/* value of template */
   int x, mx;				/* column counters */
   int y, x1, x2;			/* unpacked from mmask->s[] */

   shAssert(scr0 != NULL && scr1 != NULL && mscr0 != NULL);
   shAssert(fiparams != NULL);
   shAssert(objc->parent != NULL && objc->parent->aimage != NULL);
   shAssert(smoothed_ai != NULL);
   ncolor = objc->ncolor;
   mmask = objc->parent->aimage->master_mask;
   shAssert(mmask != NULL);
/*
 * set up the buffers for smoothing the initial estimates of the deblended
 * children
 */
   rsize = (mmask->rmax - mmask->rmin + 1);
   csize = (mmask->cmax - mmask->cmin + 1);
   
   if(rsize + filtsize > scr0->nrow || csize + filtsize > scr0->ncol ||
      (fiparams->deblend_npix_max > 0 && mmask->npix > fiparams->deblend_npix_max)) {
      objc->parent->flags |= OBJECT1_TOO_LARGE;	/* too large to process */
      return(-1);
   } 
/*
 * if the object hangs over the edge of the data region in any band,
 * give up now
 */
   for(c = 0;c < ncolor;c++) {
      if(c == 0) {
	 nrow = fiparams->frame[c].data->nrow;
	 ncol = fiparams->frame[c].data->ncol;
      } else {
	 shAssert(nrow == fiparams->frame[c].data->nrow);
	 shAssert(ncol == fiparams->frame[c].data->ncol);
      }

      cmin = mmask->cmin + objc->parent->aimage->dcol[c];
      rmin = mmask->rmin + objc->parent->aimage->drow[c];
      if(rmin < filtsize/2 + 1 || rmin + rsize - 1 + filtsize/2 + 1 >= nrow ||
	 cmin < filtsize/2 + 1 || cmin + csize - 1 + filtsize/2 + 1 >= ncol) {
	 objc->parent->flags |= OBJECT1_EDGE;
	 if(objc->parent->flags2 & OBJECT2_DEBLENDED_AT_EDGE) {
	    objc->parent->flags2 &= ~OBJECT2_DEBLENDED_AT_EDGE; /* it wasn't */
	 }
	 return(-1);
      }
   }
/*
 * create scratch buffers, and a region into which we symmetrise the
 * original data.
 *
 * We also need an atlas image in which to save the smoothed template,
 * so make that now
 */
   scra = shSubRegNew("scra", scr0, rsize + filtsize, csize + filtsize,
		      0, 0, NO_FLAGS);
   scrb = shSubRegNew("scrb", scr1, rsize + filtsize, csize + filtsize,
		      0, 0, NO_FLAGS);
   sym = shSubRegNew("symmetrised", scra, rsize, csize, 0, 0, NO_FLAGS);
   psfmask = shSubMaskNew("psfmask", mscr0, rsize, csize, 0, 0, NO_FLAGS);
   
   if(*smoothed_ai != NULL) {
      phAtlasImageDel(*smoothed_ai, 0);
      for(c = 0; c < ncolor; c++) {
	 phObjmaskDel(objc->aimage->mask[c]);
	 phObjmaskDel(objc->color[c]->mask);
	 objc->aimage->mask[c] = objc->color[c]->mask = NULL;
      }
   }

   *smoothed_ai = phAtlasImageCopy(objc->parent->aimage, 0);
/*
 * now go through each colour and construct the first estimate of the
 * deblended image, based on the minimum value of pairs of pixels (unless
 * we think that it is a PSF, in which case use that)
 *
 * If it wasn't detected in this band (i.e. there was no peak), don't generate
 * a template here. We'll deal with missing templates later.
 */
   for(c = 0;c < ncolor;c++) {
      if(!(objc->color[c]->flags & OBJECT1_DETECTED)) {
	 continue;
      }
      
      data = (REGION *)fiparams->frame[c].data;

      bkgd = fiparams->frame[c].bkgd + SOFT_BIAS;
      {
	  shAssert(objc->color[c] != NULL);
	  const float gain = phGain(&fiparams->frame[c], objc->color[c]->rowc, objc->color[c]->colc);
	  const float dark_variance = phDarkVariance(&fiparams->frame[c], objc->color[c]->rowc, objc->color[c]->colc);
	  bias =				/* n.b. bias is -ve, hence "- 0.5" */
	      MIN_2N_BIAS*sqrt(objc->parent->color[c]->sky/gain + dark_variance) - 0.5;
      }
      shRegIntSetVal(sym, bkgd);

      aimage_drow = objc->parent->aimage->drow[c];
      aimage_dcol = objc->parent->aimage->dcol[c];
      cmin = mmask->cmin + aimage_dcol;
      rmin = mmask->rmin + aimage_drow;
/*
 * unpack OBJMASK psfmasks[c] bits into MASK psfmask, as it's simpler
 * than using the OBJMASK directly
 */
      psfmask->row0 = rmin; psfmask->col0 = cmin;
      shMaskClear(psfmask);
      phMaskSetFromObjmask(psfmasks[c], psfmask, 1);
	   
/*
 * Find which pixel that peak lies in, so (40.6, 40.5) --> (40, 40)
 * (adding 0.5 and truncating is the wrong thing to do)
 */
      rowc = objc->color[c]->rowc;
      colc = objc->color[c]->colc;
/*
 * done with checks and unpacking. To work.
 *
 * If the object is consistent with being a PSF use a PSF as the template,
 * otherwise use the minimum-of-pixel-pair method.
 *
 * Set the amplitude of the PSF to a bit more than the expected deblended
 * amplitude, so that the best-fit coeffs will be of order unity, but
 * truncation errors in the template won't be too bad
 */
      if(objc->color[c]->flags & OBJECT1_DEBLENDED_AS_PSF) {
	 int rad;			/* radius to mask */

	 i = rowc - rmin;
	 if(rowc < rmin) {		/* something's rotten in the state
					   of the astrometry */
	    i = 0;
	 } else if(rowc >= rmin + rsize) { /* something's wrong here too */
	    i = rsize - 1;
	 }
	 row = sym->ROWS[i];

	 template_max = objc->color[c]->profMean[0] + 100;
	 objc->color[c]->profMean[2] = template_max;

	 rad = 0.5*((rsize < csize) ? rsize : csize);
	 if(rowc - rmin <= 0 || rowc - rmin >= sym->nrow - 1 ||
	    colc - cmin <= 0 || colc - cmin >= sym->ncol - 1) {
	    objc->parent->flags2 |= OBJECT2_CENTER_OFF_AIMAGE;
	    objc->parent->color[c]->flags2 |= OBJECT2_CENTER_OFF_AIMAGE;
	    objc->flags &= ~OBJECT1_DETECTED; /* it'll be deleted later */

	    shMaskDel(psfmask);
	    phAtlasImageDel(*smoothed_ai, 0); *smoothed_ai = NULL;
	    shRegDel(scra);
	    shRegDel(scrb);
	    shRegDel(sym);
	    
	    return(0);
	 }

	 phDgpsfAdd(sym, fiparams->frame[c].psf, rad,
		    rowc - rmin, colc - cmin, template_max);
	 
	 if(objc->color[c]->mask != NULL) {
	    phObjmaskDel(objc->color[c]->mask);
	 }

	 rad = phDgpsfSize(fiparams->frame[c].psf, template_max, 1);
	 objc->color[c]->mask = phObjmaskFromCircle(rowc, colc, rad);
	 template_max += SOFT_BIAS;
      } else {				/* not a PSF; symmetrise image */
	 template_max = objc->color[c]->profMean[2]; /* max. val. of template*/
	 template_max += SOFT_BIAS;

	 for(i = 0;i < mmask->nspan;i++) {
	    y = mmask->s[i].y + aimage_drow;
	    x1 = mmask->s[i].x1 + aimage_dcol;
	    x2 = mmask->s[i].x2 + aimage_dcol;
	    if(y < 0 || y >= nrow) {
	       continue;
	    }
	    if(x1 < 0) x1 = 0;
	    if(x2 >= ncol) x2 = ncol - 1;
	    
	    my = rowc + (rowc - y);
	    mx1 = colc + (colc - x2); mx2 = colc + (colc - x1); /* mx1 <= mx2*/
/*
 * check if the mirrored span lies outside mmask's bounding box; if so, leave
 * sym at the background level
 */
	    if(my < rmin || my >= rmin + rsize ||
	       mx2 < cmin || mx1 >= cmin + csize) {
	       continue;
	    }
	    
	    if(mx1 < cmin) {		/* partially outside psfmask */
	       mx1 = cmin;
	       x2 = colc - (mx1 - colc);
	    }
	    if(mx2 >= cmin + csize) {	/* partially outside psfmask */
	       mx2 = cmin + csize - 1;
	       x1 = colc - (mx2 - colc);
	    }
/*
 * OK, everything's in range. Time to take the minimum of the pixel and
 * its mirror. The minimum of two N(0,1) variates is biased by MIN_2N_BIAS,
 * so correct for this effect in the sky level.
 */
	    shAssert(y - rmin >= 0 && y - rmin < rsize);
	    shAssert(y >= 0 && y < nrow && my >= 0 && my < nrow);
	    row = data->ROWS[y];
	    mrow = data->ROWS[my];
#if DONT_USE_SUBTRACTED			/* don't use PSF-subtracted pixels */
	    psfrow = psfmask->rows[y - rmin];
	    mpsfrow = psfmask->rows[my - rmin];
#endif
	    srow = sym->ROWS[y - rmin];
	    for(x = x1, mx = mx2;x <= x2;x++, mx--) {
	       shAssert(x - cmin >= 0 && x - cmin < csize);
	       shAssert(x >= 0 && x < ncol && mx >= cmin && mx < cmin + csize);
	       val = row[x];
	       mval = mrow[mx];
#if DONT_USE_SUBTRACTED			/* don't use PSF-subtracted pixels */
	       if(psfrow[x - cmin] != 0) { /* pixel is part of a PSF object */
		  if(mpsfrow[mx - cmin] != 0) {	/* so is mirror pixel */
		     tval = 0.5*(val + mval);
		  } else {
		     tval = mval;
		  }
	       } else if(mpsfrow[mx - cmin] != 0) {
		  tval = val;
	       } else {
		  tval = (val < mval ? val : mval) - bias;
	       }
#else
	       tval = (val < mval ? val : mval) - bias;
#endif
#if 0
	       srow[x - cmin] = (tval < template_max) ? tval : template_max;
#else
	       srow[x - cmin] = tval;
#endif
	    }
	 }
      }
/*
 * copy the symmetrised image back to the original data region, where
 * it will become the deblending template (the original pixel values
 * are preserved in the parent's atlas image).
 *
 * We must of course only do this within the master_mask
 */
      copy_region_within_mask((REGION *)data, sym, mmask,
						     aimage_drow, aimage_dcol);
/*
 * Possibly dump image for debugging
 */
      {
	  static char *dump_filename = NULL; /* write data to this file?
						For use from gdb */
	  if(dump_filename != NULL) {
	      shRegWriteAsFits(data,
			       dump_filename, STANDARD, 2,DEF_NONE,NULL,0);
	      dump_filename = NULL;
	  }
      }
/*
 * we next want to run the object finder on that symmetrised image; the image
 * is smoothed, and extra peaks rejected --- see improve_template() for details
 */
      obj1 = objc->color[c];
      if(obj1->flags & OBJECT1_DEBLENDED_AS_PSF) {
/*
 * no need to check template, as we created it as a multiple of PSF
 */
      } else {
	 float sigma = 4*fiparams->frame[c].smooth_sigma; /* smoothing sigma XXX multiplier */
	 float threshold = fiparams->frame[c].ffo_threshold; /* XXX Reconsider this threshold */
	 if (sigma != 0.0) {
	     threshold /= sigma;
	 }

	 shAssert(obj1->mask == objc->aimage->mask[c]);
	 phObjmaskDel(obj1->mask); objc->aimage->mask[c] = NULL;
	 obj1->mask = 
	   improve_template(mmask, c, rowc,colc, data, aimage_drow,aimage_dcol,
			    scra, scrb, rsize + filtsize, csize + filtsize,
			    sigma, filtsize, npeak_max, smoothed_ai, threshold, ngrow);

	 if(obj1->mask == NULL) {
	    objc->flags &= ~OBJECT1_DETECTED;
	    obj1->flags &= ~OBJECT1_DETECTED;
	 }
      }
   }
/*
 * Possibly dump image for debugging
 */
   for(c = 0; c < ncolor; c++) {
       static char *dump_filename = NULL; /* write data to this file?
					     For use from gdb */
       if(dump_filename != NULL) {
	   shRegWriteAsFits((REGION *)fiparams->frame[c].data,
			    dump_filename, STANDARD, 2,DEF_NONE,NULL,0);
	   dump_filename = NULL;
       }
   }
/*
 * we've found the templates in all colours. They are represented by the
 * pixels in the original data region, within the OBJECT1->mask
 *
 * Now go through them looking for objects which we didn't detect
 * in any band; in this case, the object wouldn't have been found at all
 * if it wasn't part of a blend, so dump it.
 *
 * Actually we cannot just dump it here as we've got an array with all the
 * children in it, and we'd have to move the others down. Instead, mark
 * the entire OBJC as not DETECTED, and we'll dump it when we get a chance.
 */
   for(c = 0;c < ncolor;c++) {
      objc->flags |= (objc->color[c]->flags & OBJECT1_DETECTED);
   }
   if(phStrategicMemoryReserveIsEmpty() ||
      !(objc->flags & OBJECT1_DETECTED)) { /* not detected in any band */
      phAtlasImageDel(*smoothed_ai, 0); *smoothed_ai = NULL;
      shRegDel(scra);
      shRegDel(scrb);
      shRegDel(sym);
      shMaskDel(psfmask);

      return(0);
   }
#if MISSING_TEMPLATES_ARE_PSF == 1
/*
 * create minimal templates in the bands where we failed to detect
 * the object; we need these to define the deblended objects, and
 * to cut atlas images. See note above call to copy_region_within_mask()
 * as to why it's OK to cast away the const for fiparams->frame[c].data
 */
   for(c = 0;c < ncolor;c++) {
      obj1 = objc->color[c];

      if(!phStrategicMemoryReserveIsEmpty() && obj1->mask == NULL) {
	 obj1->mask = phObjmaskFromCircle(obj1->rowc, obj1->colc, 2 + ngrow);
	 obj1->flags |= OBJECT1_DEBLENDED_AS_PSF;
	 phRegIntSetValInObjmask((REGION *)fiparams->frame[c].data,
				 obj1->mask, bkgd);
	 phDgpsfAdd((REGION *)fiparams->frame[c].data, fiparams->frame[c].psf,
		    0.5*((rsize < csize) ? rsize : csize),
		    obj1->rowc, obj1->colc, 100);
      }
   }
#endif
/*
 * Time to cut an "atlas image"; it's actually the templates in each band
 */
   phAtlasImageCut(objc, -1, fiparams, -1, -1, NULL);

#if MISSING_TEMPLATES_ARE_PSF == 0
/*
 * We may not have templates in some bands; go ahead and make them from the
 * average of the bands where we _do_ have them
 */
   for(c = 0;c < ncolor;c++) {
      if(objc->color[c]->mask == NULL) {
	 break;
      }
   }

   if(!phStrategicMemoryReserveIsEmpty() && c != ncolor) { /* at least one missing template */
      const int missing0 = c;		/* first missing template */
      int ngood = 0;			/* number of good templates */
      OBJMASK *uni = NULL;		/* union of all non-NULL obj1->masks,
					   in canonical coordinates */
      
      phAtlasImageConstSet(objc->aimage, missing0, SOFT_BIAS);
      
      for(c = 0;c < ncolor;c++) {
	 if(objc->color[c]->mask != NULL) {
	    ngood++;

	    uni = phObjmaskMerge(uni, objc->color[c]->mask, 
				 -objc->parent->aimage->drow[c],
				 -objc->parent->aimage->dcol[c]);
	    

	    phAtlasImagesPlusEquals(objc->aimage, missing0, objc->aimage, c, 0);
	 }
      }
/*
 * subtract bias from templates. They are scaled up by a factor of ngood,
 * but that doesn't really matter (their fitted amplitudes will be smaller)
 */
      phAtlasImageConstAdd(objc->aimage, missing0, -SOFT_BIAS*ngood, 0);
/*
 * Generate the correct masks in each missing band and copy over the
 * average template
 */
      shAssert(uni != NULL);
      (void)phObjmaskAndObjmask(uni, objc->parent->aimage->master_mask);

      for(c = missing0; c < ncolor; c++) {
	 if(objc->color[c]->mask == NULL) {
	    objc->color[c]->mask =
	      phObjmaskCopy(uni, objc->parent->aimage->drow[c],
			         objc->parent->aimage->dcol[c]);

	    phAtlasImagesPixelsCopy(objc->aimage, c, objc->aimage, missing0);
	 }
      }

      phObjmaskDel(uni);
   }
#endif
/*
 * Did we give up?
 */
   if(phStrategicMemoryReserveIsEmpty()) {
       shRegDel(scra);
       shRegDel(scrb);
       shRegDel(sym);
       shMaskDel(psfmask);
       
       return(-1);
   }
/*
 * We need smoothed templates too, even for DEBLENDED_AS_PSF objects.
 * The unsmoothed one is noise-free, so we don't really need to smooth,
 * and it's simpler not to bother
 */
   for(c = 0;c < ncolor;c++) {
      if(objc->color[c]->flags & OBJECT1_DEBLENDED_AS_PSF) {
	  phAtlasImagesPixelsCopy(*smoothed_ai, c, objc->aimage, c);
      }
   }
/*
 * Remove the background from the templates (we leave in the SOFT_BIAS)
 */
   for(c = 0;c < ncolor;c++) {
      phAtlasImageConstAdd(objc->aimage, c, -fiparams->frame[c].bkgd, 0);
      phAtlasImageConstAdd(*smoothed_ai, c, -fiparams->frame[c].bkgd, 0);
   }   
/*
 * Set the parts of the template that aren't in obj1->mask to 0
 */      
   for(c = 0;c < ncolor;c++) {
      obj1 = objc->color[c];

      phAtlasImageSetIfNotInObjmask(objc->aimage, c, obj1->mask, 0);

      phAtlasImageSetIfNotInObjmask(*smoothed_ai, c, obj1->mask, 0);
   }
/*
 * and clean up
 */
   shRegDel(scra);
   shRegDel(scrb);
   shRegDel(sym);
   shMaskDel(psfmask);

   return(0);				/* OK */
}

/*
 * Set up the normal equations, Aw = b
 */
static void
setup_normal(const OBJC *parent,	/* parent object */
	     const OBJC **children,	/* array of children */
	     int nchild,		/* dimension of children[] */
	     int c,			/* the colour in question */
	     int bkgd,			/* == (bkgd from fparams) + SOFT_BIAS*/
	     MAT *A,			/* The LSQ problem is */
	     VEC *b,			/*    A w = b */
	     VEC *norm)			/* normalisation of templates */
{
   int i, j;
   float *maxpix = alloca(nchild*sizeof(float)); /* max. value for templates */
   int npix = parent->aimage->master_mask->npix;

   for(i = 0;i < nchild;i++) {
      shAssert(children[i]->aimage->master_mask->npix == npix);
   }
/*
 * First A.
 */
   for(i = 0;i < nchild;i++) {
      for(j = 0;j <= i;j++) {
	  A->me[i][j] = A->me[j][i] = phAtlasImageDotProduct(children[i]->aimage, c, bkgd,
							     children[j]->aimage, c, bkgd);
      }
   }
/*
 * and now b
 */
   for(i = 0;i < nchild; i++) {
      b->ve[i] = phAtlasImageDotProduct(children[i]->aimage, c, bkgd,
					parent->aimage,      c, bkgd);

      maxpix[i] = phAtlasImageMaximum(parent->aimage, c) - bkgd;
      if(maxpix[i] <= 0) {
	  maxpix[i] = 1;			/* don't divide by zero */
      }
   }
/*
 * Now renormalise to try to control overflows etc., and to make the values
 * of the eigenvalues more comprehensible. We renormalise each template
 * to have a maximum value of unity rather than an rms of unity to avoid
 * problems with poorly known sky levels
 */
   for(i = 0;i < nchild;i++) {
      norm->ve[i] = maxpix[i];
      b->ve[i] /= maxpix[i];
      for(j = 0;j <= i;j++) {
	 A->me[i][j] /= maxpix[i]*maxpix[j];
	 A->me[j][i] = A->me[i][j];
      }
   }
/*
 * write out template and data vectors, for debugging
 */
#if 0
   {
      FILE *fil = fopen("template.dat","w");
      if(fil != NULL) {
	  const OBJMASK *mmask = parent->aimage->master_mask;
	  for(k = 0; k < mmask->nspan; k++) {
	      int x1 = mmask->s[k].x1, x2 = mmask->s[k].x2;
	      int x;
	      int y = mmask->s[k].y;

	      fprintf(fil,"(%d, %d): ", y, x);
	      for(x = x1; x <= x2; x++) {
		  fprintf(fil," %d", phAtlasImagePixelGet(parent->aimage, c, y, x));
		  for(j = 0; j < nchild;j++) {
		      fprintf(fil," %d", phAtlasImagePixelGet(children[j]->aimage, c, y, x));
		  }
	      }
	      fprintf(fil,"\n");
	  }
	  fclose(fil);
      }
   }
#endif
}

/*****************************************************************************/
/*
 * Find the sum of I_i * r_i^2 for an object in a given band
 *
 * Note that, because the master mask's in the canonical band, that's
 * the coordinate system we use in this routine
 */
static float
find_Isigma2(const OBJC *objc,		/* the object in question */
	     int c,			/* in this band */
	     int bkgd)			/* background level */
{
   const int colc = objc->color[c]->colc - objc->aimage->dcol[c] + 0.5;
   int i;				/* span counter */
   const OBJMASK *mmask = objc->aimage->master_mask;
   const int nspan = mmask->nspan;
   int peakval;				/* peak value in objc */
   int r2;				/* == (distance from object centre)^2*/
   const int rowc = objc->color[c]->rowc - objc->aimage->drow[c] + 0.5;
   int row2, col2;			/* == ({row,col} - {row,col}c)^2 */
   float sum = 0;			/* the desired sum */
   int val;				/* == pix[j] */
   int x, y;				/* column/row counters */
   int x1, x2;				/* ends of this span */

   if(objc->color[c]->peaks == NULL || objc->color[c]->peaks->npeak == 0) {
      return(0.0);
   }
   
   peakval = 1.1*objc->color[c]->peaks->peaks[0]->peak + bkgd;

   for(i = 0; i < nspan; i++) {
      x1 = mmask->s[i].x1; x2 = mmask->s[i].x2;
      y = mmask->s[i].y;

      row2 = y - rowc; row2 *= row2;
      col2 = x1 - colc; col2 *= col2;
      for(x = x1; x <= x2; x++) {
	 r2 = row2 + col2;
	 val = phAtlasImagePixelGet(objc->aimage, c, y, x);
	 if(val > bkgd && val < peakval) {
	    sum += (val - bkgd)*r2;
	 }

	 col2 += 2*(x - colc) + 1;	/* ((x-xc)+1)^2 == (x-xc)^2+2(x-xc)+1*/
      }
   }

   return(sum);
}

/*****************************************************************************/
/*
 * go through a set of children's atlas images, and for pixels where the
 * sum of the children's fluxes doesn't equal the parent, assign the balance
 * based on Is2/R^2
 *
 * Return the total number of DN that this routine was forced to share out
 * among the children
 */
static float
assign_missing_flux(const OBJC **children, /* the children in question */
		    int nchild,		/* number of children */
		    int c,		/* in this band */
		    const float *Is2)	/* children's I*sigma^2 values */
{
   int best_k;				/* best choice of child to get flux */
   const OBJC *child;			/* == children[k] */
   int drow, dcol;			/* distance to an object's centre */
   int i, j, k;				/* span and pixel counter resp. */
   float max;				/* maximum weight of any object */
   const OBJMASK *mmask = children[0]->parent->aimage->master_mask;
   const int nspan = mmask->nspan;
   int r2;				/* == (distance from object centre)^2*/
   float unassigned = 0;		/* flux unassigned to any object */
   int val;				/* value of a pixel to be assigned */
   float weight;			/* an object's weight */
#define USE_WEIGHTS 0
#if USE_WEIGHTS
   float *weights = alloca(nchild*sizeof(float)); /* weights for all children */
#endif
   int x;				/* column counter */
   int y, x1, x2;			/* SPAN.{y,x[12]} */
/*
 * assign fluxes
 */
   for(i = j = 0; i < nspan; i++) {
      y = mmask->s[i].y;
      x1 = mmask->s[i].x1; x2 = mmask->s[i].x2;
      for(x = x1; x <= x2; x++, j++) {
	 for(k = 0; k < nchild; k++) {
	    if(phAtlasImagePixelGet(children[k]->aimage, c, y, x) != SOFT_BIAS) {
	       break;			/* we assigned flux to someone */
	    }
	 }
	 if(k == nchild) {		/* unassigned pixel */
#if USE_WEIGHTS
	    double sum = 0;
	    val = phAtlasImagePixelGet(children[0]->parent->aimage, c, y, x) - SOFT_BIAS;
	    max = -1e9; best_k = 0;
	    for(k = 0; k < nchild; k++) {
	       child = children[k];
	       drow = y - child->rowc + 0.5;
	       dcol = x - child->colc + 0.5;
	       r2 = drow*drow + dcol*dcol;
	       if(r2 == 0) {
		  best_k = k;
		  break;
	       }

	       if(weight > max) {
		  max = weight; best_k = k;
	       }

	       weight = weights[k] = Is2[k]/r2;
	       sum += weight;
	    }
	    if(k < nchild) {
		phAtlasImagePixelSet(children[k]->aimage, c, y, x, val + SOFT_BIAS);
	    } else {
		for(k = 0; k < nchild; k++) {
		    int dval = val*weights[k]/sum + 0.5;
		    if(dval > 0) {
			phAtlasImagePixelSet(children[k]->aimage, c, y, x, dval + SOFT_BIAS);
			val -= dval;
		    }
		}
		phAtlasImagePixelSet(children[best_k]->aimage, c, y, x,
				     phAtlasImagePixelGet(children[best_k]->aimage, c, y, x) + val); /* left over flux*/
	    }
#else
	    val = phAtlasImagePixelGet(children[0]->parent->aimage, c, y, x) - SOFT_BIAS;
	    max = -1e9; best_k = 0;
	    for(k = 0; k < nchild; k++) {
	       child = children[k];
	       drow = y - child->rowc + 0.5;
	       dcol = x - child->colc + 0.5;
	       r2 = drow*drow + dcol*dcol;
	       if(r2 == 0) {
		  best_k = k; break;
	       }

	       weight = Is2[k]/r2;

	       if(weight > max) {
		  max = weight; best_k = k;
	       }
	    }
	    phAtlasImagePixelSet(children[best_k]->aimage, c, y, x, val + SOFT_BIAS);
#endif
	    unassigned += val;
	 }
      }
   }

   return(unassigned);
}

#endif // NOPE

#if defined(NOPE)

/*****************************************************************************/
/*
 * If we are reduced to only a single child, make sure that the parent
 * has the child's positions in all bands; as the parent was a deblend
 * candidate it may have a mixture of the candidate peaks
 */
static void
set_parent_position_from_child(OBJC *objc,
			       const OBJC *child)
{
   int c;

   objc->flags &= ~OBJECT1_CANONICAL_CENTER;
   objc->flags |= (child->flags & OBJECT1_CANONICAL_CENTER);
   objc->rowc = child->rowc;
   objc->rowcErr = child->rowcErr;
   objc->colc = child->colc;
   objc->colcErr = child->colcErr;
   
   for(c = 0; c < objc->ncolor; c++) {
      objc->color[c]->flags &= ~OBJECT1_CANONICAL_CENTER;
      objc->color[c]->flags |=
	(child->color[c]->flags & OBJECT1_CANONICAL_CENTER);
      objc->color[c]->rowc = child->color[c]->rowc;
      objc->color[c]->rowcErr = child->color[c]->rowcErr;
      objc->color[c]->colc = child->color[c]->colc;
      objc->color[c]->colcErr = child->color[c]->colcErr;
   }
}

/*****************************************************************************/
/*
 * Reject a template
 */
static int
reject_template(OBJC *objc,
		int nchild,
		int reject,
		OBJC *children[],
		ATLAS_IMAGE *smoothed_ai[],
		MAT *A[],
		VEC *b[],
		VEC *norm[],
		VEC *lambda[],
		MAT *Q[],
		VEC *w[])
{
   int c;
   int i;

   objc->flags |= OBJECT1_DEBLEND_PRUNED;
   for(c = 0; c < objc->ncolor; c++) {
      objc->color[c]->flags |= OBJECT1_DEBLEND_PRUNED;
   }
/*
 * and reject it
 */
   phObjcChildDel(children[reject]);
   phAtlasImageDel(smoothed_ai[reject], 0);
   for(i = reject;i < nchild - 1;i++) { /* move the others down */
      children[i] = children[i + 1];
      smoothed_ai[i] = smoothed_ai[i + 1];
   }
   nchild--;
   
   for(c = 0; c < objc->ncolor; c++) { /* reject from Normal eqs.*/
      A[c] = phMatDelRowCol(A[c], reject, reject);
      b[c] = phVecDelElement(b[c], reject);
      norm[c] = phVecDelElement(norm[c], reject);
      phVecDel(w[c]); w[c] = NULL;
   }

   if(nchild <= 1) {
      for(c = 0; c < objc->ncolor; c++) {
	 phMatDel(A[c]);
	 phVecDel(b[c]);
	 phVecDel(norm[c]);
	 phVecDel(lambda[c]);
	 phMatDel(Q[c]);
      }
      
      if(nchild == 1) {
	 set_parent_position_from_child(objc, children[0]);
      }
      
      objc->flags |= OBJECT1_NODEBLEND;
      for(c = 0; c < objc->ncolor; c++) {
	 objc->color[c]->flags |= OBJECT1_NODEBLEND;
      }
      shFree(children);
      for(i = 0;i < nchild;i++) {
	 phAtlasImageDel(smoothed_ai[i], 0);
      }
      shFree(smoothed_ai);
      return(0);
   }

   return(nchild);
}

/*****************************************************************************/
/*
 * Copy peaks in reject into keep, if the object isn't detected in that
 * band in object keep.  Move the centroid over too, as it came from the peaks
 */
static void
transfer_centers_and_peaks(OBJC *keep, OBJC *reject)
{
   int c;
   
   for(c = 0; c < keep->ncolor; c++) {
      if((keep->color[c]->flags & OBJECT1_DETECTED) != 0 ||
	 reject->color[c]->peaks == NULL) {
	 continue;			/* nothing to do */
      }

      phPeaksDel(keep->color[c]->peaks);
      keep->color[c]->peaks = reject->color[c]->peaks;
      reject->color[c]->peaks = NULL;
/*
 * We should copy over the centers too, but it seems rather scary to do
 * so at this late stage (v5_4_24).
 */
#if 1
      keep->color[c]->rowc = reject->color[c]->rowc;
      keep->color[c]->rowcErr = reject->color[c]->rowcErr;
      keep->color[c]->colc = reject->color[c]->colc;
      keep->color[c]->colcErr = reject->color[c]->colcErr;
#endif
      
      keep->flags &= ~OBJECT1_CANONICAL_CENTER; /* we need reject's value of */
      keep->color[c]->flags &= ~OBJECT1_CANONICAL_CENTER; /* CANONICAL_CENTER*/
      
      keep->flags |= reject->color[c]->flags & OBJECT1_DETECTED;
      keep->color[c]->flags |= reject->color[c]->flags & OBJECT1_DETECTED;
   }
}

/*****************************************************************************/
/*
 * look at the potential children and see if there are any `local'
 * modifications to the list that would improve the deblend.
 *
 * Initially, the only such case is re-assembling unrecognised moving objects
 */

static int
peephole_optimizer(OBJC *objc,		/* parent */
		   const FIELDPARAMS *fiparams, /* astrometry etc. */
		   int nchild,		/* number of children */
		   OBJC *children[],	/* list of children */
		   ATLAS_IMAGE **smoothed_ai)/* list of atlas images containing
						smoothed templates. Not used,
						but may need to be freed */
		   
{
   int c;				/* counter in colour */
   float col[NCOLOR], colErr[NCOLOR];	/* estimated col centre in each band */
   OBJC *child;				/* == children[] */
   int *detected;			/* Which bands are present
						   in each of the children[] */
   float drow[NCOLOR], dcol[NCOLOR];	/* _Add_ to convert to canon. band */
   float drowErr[NCOLOR], dcolErr[NCOLOR]; /* errors in drow/dcol */
   int i, j;
   OBJC *merged = NULL;			/* candidate merged object */
   const float min_peak_spacing = fiparams->deblend_min_peak_spacing;
   int did_merge = 0;			/* did I merge any bands together? */
   float row[NCOLOR], rowErr[NCOLOR];	/* estimated row centre in each band */
/*
 * Find astrometric offsets
 */
   for(c = 0; c < objc->ncolor; c++) {
      phOffsetDo(fiparams, objc->rowc, objc->colc, 
		 c, fiparams->ref_band_index,
		 0, NULL, NULL, &drow[c], &drowErr[c], &dcol[c], &dcolErr[c]);
   }
/*
 * Go through list of children setting bits for which bands are present;
 * not totally by coincidence these are the same as PEAK_BAND0 etc. although
 * we don't use this fact.
 */
   detected = shMalloc(nchild*sizeof(int));

   for(i = 0; i < nchild; i++) {
      child = children[i];
      detected[i] = 0;
      for(c = 0; c < objc->ncolor; c++) {
	 if(child->color[c]->flags & OBJECT1_DETECTED) {
	    detected[i] |= (1 << c);
	 }
      }
   }
/*
 * Go through all pairs of children that don't have any peaks in
 * common, and see if it makes sense to merge them
 */
   for(i = 0; i < nchild; i++) {
      for(j = i + 1; j < nchild; j++) {
	 if((detected[i] & detected[j]) != 0) { /* they have bands in common */
	    continue;
	 }
	 /*
	  * Copy OBJECT1s from i and j into merged
	  */
	 if(merged == NULL) {
	    merged = phObjcNew(objc->ncolor);
	 }
	 for(c = 0; c < objc->ncolor; c++) {
	    if((detected[i] & (1 << c))) {
	       merged->color[c] = children[i]->color[c];
	    } else if((detected[j] & (1 << c))) {
	       merged->color[c] = children[j]->color[c];
	    }
	 }
	 /*
	  * estimate the velocity
	  */
	 if(phVelocityFind(merged, fiparams,
			   row, rowErr, col, colErr, NULL) != 0) {
	    for(c = 0; c < objc->ncolor; c++) {	/* Not a good candidate */
	       merged->color[c] = NULL;
	    }
	    
	    continue;
	 }
	 /*
	  * Hmm, a good candidate for a merger.  Replace i with merged
	  * (well, actually overlay i with merged) and prepare to discard j
	  */
	 {
	    long mask = ~(OBJECT2_NODEBLEND_MOVING |
			  OBJECT2_BAD_MOVING_FIT |
			  OBJECT2_BAD_MOVING_FIT_CHILD |
			  OBJECT2_TOO_FEW_DETECTIONS);

	    objc->flags2 &= mask;
	    children[i]->flags2 &= mask;
	 }

	 objc->flags2 |=
	    OBJECT2_DEBLENDED_AS_MOVING | OBJECT2_DEBLEND_PEEPHOLE;
	 children[i]->flags2 |=
	    OBJECT2_DEBLENDED_AS_MOVING | OBJECT2_DEBLEND_PEEPHOLE;
	 did_merge = 1;

	 detected[i] |= detected[j];

	 for(c = 0; c < objc->ncolor; c++) {
	    if(merged->color[c] == NULL) {
	       OBJECT1 *obj1 = children[i]->color[c];
	       shAssert(obj1 != NULL);
	       if(obj1->flags & OBJECT1_DETECTED) {
		  shAssert(obj1->flags & OBJECT1_CANONICAL_CENTER);
	       }
	       
	       obj1->colc = col[c] - dcol[c];
	       obj1->colcErr = sqrt(pow(colErr[c],2) + pow(dcolErr[c],2));
	       obj1->rowc = row[c] - drow[c];
	       obj1->rowcErr = sqrt(pow(rowErr[c],2) + pow(drowErr[c],2));
	       
	       obj1->flags |= OBJECT1_CANONICAL_CENTER;
	    } else {
	       if(children[i]->color[c] == merged->color[c]) {
		  ;			/* nothing to do */
	       } else if(children[j]->color[c] == merged->color[c]) {
		  phObject1Del(children[i]->color[c]);
		  children[i]->color[c] = merged->color[c];
		  children[j]->color[c] = NULL;
		  
		  shAssert(children[i]->aimage->mask[c] == NULL);
		  children[i]->aimage->mask[c] = children[j]->aimage->mask[c];
		  children[j]->aimage->mask[c] = NULL;
		  
		  phAtlasImagePixReplace(children[i]->aimage, c, children[j]->aimage, c);
		  phAtlasImagePixReplace(smoothed_ai[i],      c, smoothed_ai[j],      c);
	       } else {
		  shFatal("You cannot get here");
	       }
	       
	       merged->color[c] = NULL;
	    }
	 }
	 /*
	  * and discard j, filling its slot in children[]
	  */
	 phObjcChildDel(children[j]); children[j] = NULL;
	 phAtlasImageDel(smoothed_ai[j], 0);

	 for(; j < nchild - 1; j++) {
	    detected[j] = detected[j + 1];
	    children[j] = children[j + 1];
	    smoothed_ai[j] = smoothed_ai[j + 1];
	 }

	 nchild--;

	 i--;				/* try a further merge */
	 break;				/*       by continuing with i loop */
      }
   }
/*
 * If we merged any children to create a new moving object, see if
 * there are other detections of the moving object that weren't merged
 * into the new object.  In other words, look for detections in other
 * children at the correct calculated position.
 *
 * We need to do this to avoid shredding objects that now appear in
 * two objects 
 */
   if(did_merge) {
      for(i = 0; i < nchild; i++) {
	 if(!(children[i]->flags2 & OBJECT2_DEBLEND_PEEPHOLE)) {
	    continue;
	 }

	 for(j = 0; j < nchild; j++) {
	    int nmatch_j = 0;		/* number of matched objects in j */

	    if(i == j) {
	       continue;
	    }
	    if((detected[i] & detected[j]) != 0) { /* bands in common */
	       continue;
	    }

	    for(c = 0; c < objc->ncolor; c++) {
	       OBJECT1 *obj1_i = children[i]->color[c];
	       OBJECT1 *obj1_j = children[j]->color[c];
	       float rowc_i, rowcErr_i, colc_i, colcErr_i;
	       float rowc_j, rowcErr_j, colc_j, colcErr_j;

	       if((obj1_i->flags & OBJECT1_DETECTED) ||
		  !(obj1_j->flags & OBJECT1_DETECTED)) {
		  continue;
	       }

	       rowc_i = obj1_i->rowc;
	       colc_i = obj1_i->colc;
	       rowcErr_i = obj1_i->rowcErr;
	       colcErr_i = obj1_i->colcErr;

	       rowc_j = obj1_j->rowc;
	       colc_j = obj1_j->colc;
	       rowcErr_j = obj1_j->rowcErr;
	       colcErr_j = obj1_j->colcErr;

	       if(pow(fabs(rowc_i - rowc_j) - rowcErr_i - rowcErr_j, 2) +
		  pow(fabs(colc_i - colc_j) - colcErr_i - colcErr_j, 2) <
					   min_peak_spacing*min_peak_spacing) {
		  obj1_i->flags |= (obj1_j->flags & OBJECT1_DETECTED);
		  nmatch_j++;
	       } else {
		  break;
	       }
	    }

	    if(c == objc->ncolor && nmatch_j > 0) { /* all peaks match */
	       /*
		* and discard j, filling its slot in children[]
		*/
	       phObjcChildDel(children[j]); children[j] = NULL;
	       phAtlasImageDel(smoothed_ai[j], 0);
	       
	       for(; j < nchild - 1; j++) {
		  detected[j] = detected[j + 1];
		  children[j] = children[j + 1];
		  smoothed_ai[j] = smoothed_ai[j + 1];
	       }
	       
	       nchild--;
	       
	       i--;			/* try a further merge */
	       break;			/*       by continuing with i loop */
	    }
	 }
      }
   }
/*
 * Clean up
 */
   if(merged != NULL) {
      for(c = 0; c < objc->ncolor; c++) {
	 merged->color[c] = NULL;	/* merged never owned them */
      }
      phObjcDel(merged, 1);
   }
   shFree(detected);

   return(nchild);
}

/************************************************************************************************************/
/*
 * Calculate the inner product of a pair of columns of two matrices
 */
static double
columnDotColumn(const MAT *Q1, const MAT *Q2, /* the two matrices */
		const int c1, const int c2) /* the two columns */
{
    int i;
    double sum = 0;

    for (i = 0; i < Q1->n; i++) {
	sum += Q1->me[i][c1]*Q2->me[i][c2];
    }

    return sum;
}

/*
 * Swap columns c1 and c2 of matrix Q and the corresponding
 * elements of vector lambda (if non-NULL)
 */
static void
swap_columns(MAT *Q, VEC *lambda,
	     const int c1, const int c2)
{
    int i;

    if (c1 == c2) return;

    for (i = 0; i < Q->n; i++) {
	const double tmp = Q->me[i][c1];
	Q->me[i][c1] = Q->me[i][c2];
	Q->me[i][c2] = tmp;
    }

    if (lambda != NULL) {
	const double tmp = lambda->ve[c1];
	lambda->ve[c1] = lambda->ve[c2];
	lambda->ve[c2] = tmp;
    }
}

/************************************************************************************************************/
/*
 * Given a set of Q and lambda (the eigenvectors and values of a matrix),
 * one for each of a set of colours, sort the eigenobjects so that they
 * are in the same order as the canonical colour.  This is done by looking
 * at each eigenvector in turn, and seeing with which eigenvector in
 * Q[canonical_color] it has the largest |inner product|
 */
static void
sort_Q(const int ncolor,		/* dimen of lambda and Q arrays */
       const int canonical_color,	/* sort to match this colour */
       VEC **lambda,			/* eigenvalues */
       MAT **Q)				/* eigenvectors */
{
    int c;
    int i, j;

    for (c = 0; c < ncolor; c++) {
	if (c == canonical_color) continue; /* already sorted */

	for (i = 0; i < Q[c]->m; i++) {
	    int best_column = i;
	    double best_dot = columnDotColumn(Q[canonical_color], Q[c], i, best_column);
	    for (j = i + 1; j < Q[c]->m; j++) {
		double dot = columnDotColumn(Q[canonical_color], Q[c], i, j);
		if (fabs(dot) > fabs(best_dot)) {
		    best_column = j;
		    best_dot = dot;
		    
		}
	    }
	    swap_columns(Q[c], lambda[c], i, best_column);
	}
    }
}

/*****************************************************************************/
/*
 * Average the per-band templates.
 *
 * This is a bit of a pain... First set the pixels outside the detection footprint to SOFT_BIAS (not 0),
 * then add a fraction 1/ncolor of each template to the 0th (also scaled down by 1/ncolor); this scaling
 * avoids overflows.  Then clip the resulting mean template to the union of the input masks, and copy
 * it back into the per-band templates.
 */
static void
average_templates(OBJC *child)
{
    int c;
    OBJMASK *mask = phObjmaskCopy(child->color[0]->mask, 0, 0);
    
    for(c = 0; c < child->ncolor;c++) {
	OBJECT1 *obj1 = child->color[c];
	phAtlasImageSetIfNotInObjmask(child->aimage, c, obj1->mask, SOFT_BIAS);

	phAtlasImagesTimesEquals(child->aimage, c, 1/(float)child->ncolor);
	if (c > 0) {
	    phObjmaskOrObjmask(mask, child->color[c]->mask);
	    phAtlasImagesPlusEquals(child->aimage, 0, child->aimage, c, 0);
	}
    }
	   
    for(c = 0; c < child->ncolor;c++) {
	phAtlasImageSetIfNotInObjmask(child->aimage, c, mask, 0);
	if (c > 0) {
	    phAtlasImagesPixelsCopy(child->aimage, c, child->aimage, 0);
	}
    }

    phObjmaskDel(mask);
}

#endif // NOPE

#if defined(NOPE)

/*****************************************************************************/
/*
 * Given an OBJC that is thought to be moving, generate proper centres
 * and atlas images
 *
 * Return 0 if OK, -1 in case of trouble; in this case, the object is
 * deleted
 */
int
phObjcDeblendMovingChild(OBJC *objc,	/* OBJC to deblend */
			 const FIELDPARAMS *fiparams) /* info about frame */

{
   float col[NCOLOR], colErr[NCOLOR];	/* estimated col centre in each band */
   float drow, dcol;			/* offset from canonical band */
   float drowErr, dcolErr;		/* errors in drow, dcol */
   int flags2;				/* flags2 bits set in velocity fit */
   int i;
   OBJECT1 *obj1;			/* == objc->color[] */
   int ndetect;				/* how many times was object found? */
   float row[NCOLOR], rowErr[NCOLOR];	/* estimated row centre in each band */

   shAssert(objc != NULL && (objc->flags2 & OBJECT2_DEBLENDED_AS_MOVING));
   shAssert(objc->parent != NULL && objc->parent->aimage != NULL);
   shAssert(fiparams != NULL);
/*
 * In how many bands was the object detected? Was this enough?
 */
   ndetect = 0;
   for(i = 0; i < objc->ncolor; i++) {
      if(objc->color[i]->flags & OBJECT1_BINNED1) {
	 ndetect++;
      }
   }
   if(ndetect <= 2) {
      objc->parent->flags2 |= (OBJECT2_TOO_FEW_DETECTIONS |
			       OBJECT2_NODEBLEND_MOVING);
      objc->parent->flags2 &= ~OBJECT2_DEBLENDED_AS_MOVING;
      phObjcChildDel(objc);
      
      return(-1);
   }
/*
 * estimate the velocity
 */
   flags2 = phVelocityFind(objc, fiparams, row, rowErr, col, colErr, NULL);

   if(flags2 & OBJECT2_TOO_FEW_GOOD_DETECTIONS) { /* too few good detections */
      objc->parent->flags2 |= (OBJECT2_TOO_FEW_GOOD_DETECTIONS |
			       OBJECT2_NODEBLEND_MOVING);
      objc->parent->flags2 &= ~OBJECT2_DEBLENDED_AS_MOVING;
      phObjcChildDel(objc);
      
      return(-1);
   } else if(flags2 & OBJECT2_BAD_MOVING_FIT) {
      objc->parent->flags2 |= (OBJECT2_BAD_MOVING_FIT_CHILD |
			       OBJECT2_NODEBLEND_MOVING);
      objc->parent->flags2 &= ~OBJECT2_DEBLENDED_AS_MOVING;
      phObjcChildDel(objc);
      
      return(-1);
   }
/*
 * If the velocity is consistent with zero, don't deblend as moving
 */
   if(flags2 & OBJECT2_STATIONARY) {
      objc->parent->flags2 |= (OBJECT2_STATIONARY |
			       OBJECT2_NODEBLEND_MOVING);
      objc->parent->flags2 &= ~OBJECT2_DEBLENDED_AS_MOVING;
      phObjcChildDel(objc);
      
      return(-1);
   }
/*
 * The positions in bands that weren't detected should be those from
 * the velocity fit, suitably transformed, rather than a suitably
 * transformed canonical centre
 */
   for(i = 0; i < objc->ncolor; i++) {
      obj1 = objc->color[i];
      shAssert(obj1 != NULL);
      
      if(obj1->flags & OBJECT1_CANONICAL_CENTER) {
	 phOffsetDo(fiparams, objc->rowc, objc->colc, 
		    fiparams->ref_band_index, i,
		    0, NULL, NULL, &drow, &drowErr, &dcol, &dcolErr);
	 obj1->colc = col[i] + dcol;
	 obj1->colcErr = sqrt(pow(colErr[i],2) + pow(dcolErr,2));
	 obj1->rowc = row[i] + drow;
	 obj1->rowcErr = sqrt(pow(rowErr[i],2) + pow(drowErr,2));
      }
   }

   return(0);
}

#endif // NOPE
